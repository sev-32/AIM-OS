# Atoms L1: Component Overview

**Detail Level:** 1 of 5 (500 words)  
**Context Budget:** ~8k tokens  
**Purpose:** Understand atom structure and usage

---

## What Are Atoms?

Atoms are CMC's fundamental memory units—the smallest indivisible piece of context with complete metadata, semantics, and provenance. Every piece of information in AIM-OS starts as an atom: a conversation turn, a code snippet, a decision record, a tool invocation. Unlike traditional database records, atoms are memory-aware objects that understand their semantic meaning, temporal validity, hierarchical position, and creation provenance.

## The Atom Schema (8 Key Parts)

### 1. Identity
Every atom has a unique ID (`atom_{uuid}`) that never changes. This ID is the primary reference throughout the system.

### 2. Content & Modality
**Modality** determines what type of content this is:
- `text` - Natural language (docs, conversations, notes)
- `code` - Programming code (functions, classes, scripts)
- `event` - System or user events (actions, state changes)
- `tool:call` - Tool invocation request
- `tool:result` - Tool execution result

**ContentRef** stores the actual payload:
- **Inline:** Small content (<1KB) embedded directly
- **URI:** Large content referenced by s3:// or file:// URI
- Includes media type, size, and SHA-256 hash for integrity

### 3. Semantic Layer (Embeddings & Tags)
**Embedding:** 384-1536 dimension vector representation enabling semantic search. Generated by sentence-transformers or OpenAI/Anthropic models.

**Tags:** Key-value pairs with weights for categorization:
```python
Tag(key="topic", value="authentication", weight=0.9, confidence=0.85)
```

Supports complex queries like: "Find all high-priority authentication-related atoms from last week."

### 4. Hierarchical Position (HHNI Path)
Every atom knows where it sits in the 6-level fractal index:
```python
HHNIPath(path=["system:auth", "section:oauth2", "paragraph:12"])
```

This enables hierarchical queries: "Give me everything under system:auth" or "What's at paragraph:12?"

### 5. Quality & Priority (TPV)
**Tag Priority Vector** tracks atom importance:
- **Priority:** Overall importance (0.0-1.0)
- **Relevance:** How relevant to current context (0.0-1.0)
- **Decay τ:** Time constant for exponential decay (seconds)
- **Last Accessed:** When atom was last used

Formula: `relevance(t) = relevance₀ × exp(-(t - t₀) / τ)`

Fresh atoms have high relevance; old unused atoms decay over time.

### 6. Temporal Bounds (Bitemporal)
**Two time dimensions:**
- **Transaction Time (TT):** When the atom was created in CMC (`created_at`)
- **Valid Time (VT):** When the information was true in the world (`valid_from`, `valid_to`)

This enables powerful queries:
- "What did we know about OAuth on Oct 1?" (as-of query)
- "Show me all changes made yesterday" (transaction time query)
- "Find atoms valid during Q3 2024" (valid time range)

### 7. Provenance (VIF - Witness Envelope)
Every atom records **how it was created:**
- **Model ID:** Which LLM generated this (gpt-4, claude-sonnet-4.5)
- **Weights Hash:** Model version identifier
- **Prompt Template:** Which prompt was used
- **Tools:** What tools were invoked
- **Writer:** System or user identifier
- **Confidence Band:** A (high), B (medium), C (low)
- **Entropy:** Uncertainty measure

This makes atoms **verifiable** - you can trace every atom back to its creation context.

### 8. Extensibility (Metadata Dict)
Freeform dictionary for custom fields without schema changes. Enables experimentation and domain-specific extensions.

## Atom Lifecycle

**Create:**
1. Parse input → determine modality
2. Generate unique ID
3. Decide inline vs. external storage
4. Generate embedding (if applicable)
5. Assign HHNI path
6. Create VIF witness
7. Persist to storage
8. Add to current snapshot

**Read:**
- Query by ID (direct lookup)
- Query by tags (filtered search)
- Query by time (bitemporal)
- Semantic search (embedding similarity)

**Update:**
- Content: **IMMUTABLE** (never changes)
- Metadata: Can evolve (tags, TPV, valid_to)

**Tombstone:**
- Mark `valid_to = now()` (logical delete)
- Atom remains in storage (for replay/audit)
- No longer returned in current queries

## Why This Design?

**Traditional Database Row:**
```
id | content | created_at
```

**Atom:**
```
id | modality | content_ref | embedding | tags | hhni_path | 
tpv | created_at | valid_from | valid_to | snapshot_id | vif | metadata
```

The difference: Atoms are **memory**, not data. They understand meaning (embeddings), hierarchy (HHNI), time (bitemporal), and origin (VIF).

## Composition Into Molecules

Atoms can group into **molecules** with semantic relationships:
```python
Molecule(
    atoms=["atom_123", "atom_456", "atom_789"],
    relationships=[
        Relationship(from="atom_123", to="atom_456", type="parent"),
        Relationship(from="atom_456", to="atom_789", type="supports")
    ]
)
```

Use cases:
- Function + docstring + test (parent-child-sibling)
- Claim + evidence (supports)
- Conflicting requirements (contradicts)

## Key Takeaways

1. **Atoms are the fundamental unit** - everything in CMC is atoms
2. **Immutable content** - once created, content never changes
3. **Rich metadata** - semantics, hierarchy, time, provenance
4. **Bitemporal** - transaction time + valid time enable time-travel
5. **Verifiable** - VIF witness makes every atom traceable
6. **Composable** - atoms group into molecules for complex structures

---

**Word Count:** ~500  
**Next Level:** [L2_architecture.md](L2_architecture.md) (2k words - implementation details)  
**Parent:** [README.md](README.md) (Atoms component navigation)

