 The deterministic properties rely on the transactional nature of the CMC write pipeline (C-1 Single Writer) and the fidelity of the HHNI/DVNS indices. Future documentation should detail the distributed implementation of these components, ensuring that determinism and performance (SLOs) are maintained at petabyte scale and under high-concurrency loads typical of AGI systems (e.g., specifying shard distribution strategies for the DVNS super-index and resilience strategies for the single-writer constraint).
Detailing Distributed Scalability and Resilience:
 While ACL provides symbolic checks and type safety, moving closer to absolute guarantees requires deeper integration with formal methods. It is recommended that core ACL steps used by the Builder Programs for code synthesis be integrated with explicit SMT solvers or theorem provers (e.g., Lean) at the provenance gate (G-Trace). This would allow the system to discharge functional proofs for critical logic generated by the AGI, marrying the pragmatic verifiability of VIF with the mathematical rigor sought by the IPS research community.   
Enhancing Formal Verification at the Gate Level:
The analysis suggests two paths for future hardening:
6.2 Future Work and Recommendations
 (Figure N: Title • Purpose • Takeaway • Link to Appendix).
Use consistent figure grammar
 in procedures (reads as an engineering spec).
imperative
 with 
Replace future tense
: budgets, latencies, thresholds — even provisional — to anchor the reader.
Surface numbers
: “Contract • Inputs • Outputs • Invariants • Failure modes”.
Prefer spec boxes
 (target ≤2).
Reduce acronym density per paragraph
Stylistic edits to apply as you revise
Gold sets, dashboards for κ/ECE, token/latency budgets; add OpenTelemetry spans per agent step.
Evaluation pack v0.1
Finalize JSON-LD & SHACL; build “Replay Harness v0.1” (pin model+tools, re-execute a chain, compare outputs).
VIF/SEG substrate
Implement path cost, basic forces, and a policy tensor; compare vs. static KNN on RS-lift and abstention quality.
DVNS micro-pilot
Outputs: Atoms, Snapshots, SEG edges, VIF logs with hashes. (This is the smallest “system that manufactures the system”.)
Agents: Ingestor → Atomizer → Schema-Validator → DD-Gate → Snapshot-Writer → Evidence-Linker.
The Foundry (bootstrap chain)
Implementation tracks (start building tomorrow)
, not just design.
falsifiable engineering
 measurable claims and acceptance tests so this is 
Added
 long proofs to appendices so the main arc remains executable.
Demoted
 system).
verifiable, steerable
 DVNS and VIF/SEG to co-equal pillars with CMC/APOE (they are the legs that make this a 
Promoted
 through the system.
one object
 storyline. Readers can now trace 
data-in → memory → retrieval physics → orchestration → provenance
 Parts II–V around a concrete 
Regrouped
Process Notes (what changed & why)
 at the end.
index
 at the front; 
Glossary card
; keep the mainline persuasive and fast.
Move heavy math and proofs to appendices
: 3 DAGs with minimal YAML and screenshots of telemetry.
Make a “Chain Gallery”
 for each store (Vector/SEG/Object/Snapshot) — request+response examples.
Ship a one-page API
 (e.g., summarize and ground an RFC) that flows through Parts II→V.
Insert a single “running example”
Quick wins (high leverage, low effort)
SEG completeness (% steps with linked evidence).
Replay success rate,
Mean time to abstention (MTA),
Claim-with-evidence rate,
Task success @ budget,
 KPIs (not just retrieval):
system
Define 
End-to-end success metrics
 (must_abstain_if: clauses).
abstention semantics
formal 
capability tokens per tool,
,
budget/type checks
static 
Your chain language is a gem. Add:
AIMOS/ACL hardening
 (already alluded to). Bake these into HHNI.
dependency hashing
 (e.g., “evidence as of T−7d”) and “impact previews” from 
time-slicing queries
Add 
SEG temporal reasoning
: fixed seeds, frozen tool versions, pinned models (weights hash), and input slices. Make “replay ok” a gate in SDFCVF.
deterministic replay harness
Specify a 
VIF replayability
persist a partial result with VIF.
trigger a reduced-fidelity route, or
refuse chain expansion,
 that can:
admission controller
Turn “budgets (tokens, time, tools)” into an 
APOE budgets as first-class citizens
 avoids off-policy traversals (safety as geometry, not just post-hoc checks).
physically
path energy near restricted evidence nodes; DVNS then 
 that raises 
policy tensor
Right now DVNS defines path costs and stability. Add a 
DVNS ←→ Policy coupling
 where systems without the invariant fail.
counter-examples
within latency budget). Provide 
 per invariant (e.g., CMC must survive context reset and still retrieve a prior “Atom” with 
acceptance tests
Add 
Make the invariants falsifiable
Concept upgrades (substance)
: full EBNF + static checks; sample pipelines.
ACL / AIMOS Chain Language
: proofs, DVNS integration schemes (Verlet vs. Euler), κ-calibration, uncertainty estimation.
Mathematical Details
Appendices (new)
 pattern library.
Builder Program
Provide a 
 end-to-end (incl. SEG exports and VIF replays).
two worked case studies
Ship at least 
Part X — Case Studies & Patterns
 and drift monitors.
token/latency budgets
 spans around agent steps; set 
OpenTelemetry
Add 
.
κ/ECE dashboards
, plus 
long-horizon agents
, 
reasoning (task suites)
, 
retrieval (p@k, nDCG, RS lift)
Define benchmark packs: 
Part IX — Evaluation & Observability
 via trace fields coming from VIF/SEG.
SOC2/ISO
 and 
EU AI Act logging
Map to 
 where DVNS forbids crossings into restricted subgraphs; log abstentions into VIF.
policy-aware retrieval demo
Keep threat model; add a 
Part VIII — Security, Safety & Compliance
 template and automated parity checks (spec↔code).
Blueprint YAML
Include a 
 walkthrough for a tiny app (e.g., RAG microservice).
Blueprint→Scaffold→Code→Test→Deploy→Observe
Provide a concrete 
Part VII — IDE-in-the-Loop
 with rollback.
quarantine flow
 and a 
DORA-style metrics
Add 
 (parity, tests, safety, provenance, HITL).
gate catalog
: atomic commits across code/docs/tags/traces; 
DevOps for cognition
Treat this as 
Part VI — Atomic Evolution (SDFCVF)
 for audits.
export profile
 triple with timestamps and cryptographic digests. Provide an 
claim→evidence→decision
 profile; show a 
JSON-LD + SHACL
: lock in 
SEG
: {model, weights_hash, prompts, data_slice_ids, tools_used, uncertainty} + replay recipe.
provenance schema
: minimal 
VIF
Part V — Verifiable Intelligence (VIF) & Shared Evidence Graph (SEG)
: Research, Coding, Operations — each with inputs, tools, gates, and success criteria.
three prebuilt chains
Provide 
 gates.
auto-abstention
 (not linear), with health metrics (κ_chain, budget adherence) and 
DAG
: present the master chain as a 
DEPP
.
budget rules
 and 
I/O schemas
 (planner, retriever, reasoner, verifier, builder, critic, operator, witness) with 
Roles & Contracts
Part IV — Orchestration: APOE & DEPP
 and failure modes (oscillation, collapse) with guardrails.
Convergence criteria
with terms (length, smoothness, block penalties, density) and constraints for policy-aware geometry.
 for path cost 
energy function
A compact 
 (not “nice-to-have”). Provide:
core retrieval physics
Promote DVNS as 
Part III — Dynamic Vector Navigation System (DVNS)
 (CRUD, versioning, TTL).
Snapshot Log
, 
Object Store
, 
Evidence Graph Store
, 
Vector Store
: finalize API stubs for 
Ch7 Storage Substrate
 with explicit numbers and back-pressure behavior.
SLOs
 (Ingest→Atomize→Gate→Snapshot). Add 
state diagram
: include end-to-end 
Ch6 Write/Read Pipelines
 (gold sets, nDCG, ablations).
offline evaluation recipe
 precisely with calibration protocol; add 
RS
: define 
Ch5 Hyper-Hierarchical Neural Indexing (HHNI)
 (one email thread) showing Atom→Molecule→Document→Thread→Project.
running example
: add 
Ch4 Fractal Memory Hierarchy
Part II — Context–Memory Core (CMC) & HHNI
: safety-as-capability, κ-gating, “IDE-in-the-loop” rationale — keep, but anchor to concrete scenarios (e.g., regulatory brief, on-call ops).
Ch3 North Star
; keep body crisp with definitions + falsifiable predictions. Map each invariant to measurable acceptance criteria.
appendix
: move proofs to 
(formal, testable)
 
Ch2 Axioms & Invariants
.
table of failure modes if each invariant is absent
; the five invariants and why each is non-optional (CMC, APOE, VIF, SDFCVF, SEG). Include a 
native, verifiable, agentic intelligence
: from “beyond chat” to 
(short)
 
Ch1 The Why
Part I — Why this must exist (tightened)
 used consistently everywhere. (Right now, acronyms are powerful but heavy; give the reader a “Rosetta card”.)
single-page legend
: convert to a 
Notation & Acronyms
: collapse to 3 lanes (Executive • Architect • Implementer).
Reading Roadmaps
 (bulleted, non-technical): problem → invariants → capabilities → risks → proof plan.
1-page Executive Overview
Front matter (keep, but sharpen)
Final Draft v0.2 — proposed structure
I’m giving you a tightened outline (“Final Draft v0.2 – proposed”), plus a change log (“Process Notes”) so it’s easy to track what moved and why — very “Marg/Hamilton”.
 (structure, flow, style, reader experience).
the artifact
 (architecture, gaps, proofs, roadmap), and
the idea
 along two axes:
A Total System of Memory
below is a crisp, hands-on upgrade plan for 
MARG-gpt-5:
: Aligns with breakthroughs like fusion/quantum, fostering emergent intelligence.
Enhancement to AGI
: Expand negotiation (Chapter 24) with resonant dynamics.
Multi-Agent Extensions
: Use APOE to refine ACL via evidence (e.g., optimize budgets from traces).
Self-Improvement Loops
:
Detailed Recommendations
: No direct mechanism for online learning from SEG.
Challenges/Gaps
: Invariants promote verifiability, but explicit self-improvement loops could push toward AGI.
Rationale
6. Broader AGI Alignment
: Enables faster iteration on atomic evolution.
Enhancement to AGI
: Add labs for edge cases (Appendix G).
Testing
: Provide TS/Python snippets for key flows (e.g., write_context). Use Genkit for Fractal Memory Hierarchy integration.
Code Artifacts
:
Detailed Recommendations
: Pseudocode is solid, but full examples for ACL (Chapter 13) or DVNS (Chapter 10) are sparse.
Challenges/Gaps
: Reference impls (Part XI) are schemas/APIs, but code snippets would aid prototyping.
Rationale
5. Implementation Gaps
: Builds resilience for untrusted environments.
Enhancement to AGI
: Extend risk taxonomy (Appendix J) with specifics: e.g., on poisoning, quarantine affected HHNI branches.
Playbooks
: Add robustness checks in gates (e.g., g_safety verifies embedding norms). For VIF, use Merkle trees for tamper-evidence (Section 14.4).
Adversarial Defenses
:
Detailed Recommendations
: Policy-aware DVNS avoids forbidden crossings, but adversarial examples could manipulate GODN forces.
Challenges/Gaps
: Chapter 20 covers injections/SSRF, but AGI-scale threats like embedding poisoning or VIF forgery need deeper playbooks.
Rationale
4. Threat Model Depth
: This bridges to quantum neuromorphic ideas, allowing emergent multimodal reasoning.
Enhancement to AGI
: Enable APOE to generate fine-tuning data from high-RS SEG nodes, using DEPP to orchestrate (e.g., planner → builder for datasets). Example: In IDE-in-the-loop (Chapter 18), use witnessed outputs to tune codegen models.
Feedback Integration
: Use SDF-CVF for model commits: treat weights as code, with parity to updated prompts/docs (Chapter 16). On update, recompute ECE on a sample SEG slice; if drift > ε (0.05), rollback or quarantine. Metrics: Replay fidelity % post-update (Chapter 22).
Update Handling
: Expand atom schemas to include vision/audio embeddings (e.g., via CLIP or Whisper hashes). In HHNI, add modality-specific indices (e.g., pixel → feature). For DVNS, incorporate cross-modal forces: gravity weighted by modality similarity (cosine on joint embeddings).
Multimodal Extensions
:
Detailed Recommendations
: No explicit loop for models to refine based on SEG evidence, limiting AGI self-improvement.
Bootstrap Feedback
: Weights hashes ensure reproducibility, but updating (e.g., GPT-5t to newer) could invalidate prior calibrations, causing drift (Chapter 23) without automated migration.
Model Updates
: Atoms support text/code/event/tool (Section 1.2), but richer inputs (images, audio) might require custom enrichers, impacting QS and embeddings.
Modality Limits
:
Challenges/Gaps
: APOE assumes models via VIF (model_id, weights_hash in Chapter 14), but for multimodal or evolving models, CMC's modality independence (Chapter 4) could be extended to handle non-text payloads more natively, reducing silos.
Rationale
3. Integration with Foundation Models
: This fosters safer emergence—e.g., in self-rewrite, adaptive κ prevents runaway loops, enabling verifiable evolution toward general intelligence.
Enhancement to AGI
code in examples); aim for true-positive abstentions > 0.9 on adversarial suites (Chapter 22). Example: In a protocol translation (Section 1.1), if PII redaction UQ > κ, abstain and quarantine the bundle under SDF-CVF.
: Use APOE's critic role (Section 11.1) to fine-tune calibrators on held-out data from SEG exports. Metrics: Stratified ECE by domain (e.g., logs vs. 
Learning Loops
: Add UQ edges in the graph schema (JSON-LD in Section 15.1): each supports/contradicts carries a propagated entropy (e.g., entropy_out = entropy_in + log(1 - weight)). Time-slicing queries then aggregate: for a claim at t, sum UQ over paths, abstaining if total > κ_chain (Section 12.3). This aligns with convergence proofs (Chapter 31), treating UQ as a damping term.
Propagation in SEG
: Make κ context-dependent using a risk scorer (e.g., κ' = κ * (1 + risk_tier / 3), where tier from 0–3). Integrate Bayesian UQ: replace sweeps with evidential networks, where uncertainty is a Dirichlet distribution over confidence buckets (A/B/C in Section 14.3). For example, compute posterior variance on ensembles: if spread > 0.15, escalate to HITL with a VIF note explaining the band (e.g., "ECE drift detected: 0.024 → 0.031").
Adaptive Thresholds
:
Detailed Recommendations
: In high-stakes flows (e.g., compliance-critical in Chapter 25), abstention precision ≥ 0.8 (Chapter 22) is targeted, but without adaptive learning, false negatives could cascade, especially if calibration dashboards (Section 14.3) aren't real-time.
False Negatives
: Methods like entropy and ECE are per-artifact, but in SEG's temporal graphs (Chapter 15), propagated uncertainty (e.g., via contradiction edges) isn't explicitly modeled, risking overconfidence in lineage queries.
UQ Granularity
: κ is a fixed abstention threshold (e.g., RS < κ or UQ > κ), but doesn't adapt to context—e.g., high-risk tiers (R2/R3 in Chapter 17) might need tighter bands, while low-risk (R0) could loosen for exploration.
Static vs. Dynamic κ
:
Challenges/Gaps
: κ-gating (Chapters 3, 11, 14) and UQ methods (temperature sweeps, ensembles, ECE in Section 14.2) are strong for trust, tying into VIF's witness invariant (Section 1.4). But in AGI contexts, where decisions compound (e.g., DEPP self-rewrites in Chapter 12), static thresholds might miss nuanced risks, like domain shifts or adversarial inputs.
Rationale
2. Uncertainty and Abstention
benchmarks: nDCG@20 on streamed agents (Chapter 22), ensuring no more than 5% degradation under 10x load.
: This scales toward emergent behaviors, like self-organizing knowledge in large-scale planning (thousands of nodes in Section 12.4). Test with 
Enhancement to AGI
: Parallelize force integration across nodes using GPU-accelerated simulations (e.g., via PyTorch tensors for potentials). Tune parameters (G, k, δ, c, α, β, γ in Section 10.2) dynamically with a meta-optimizer that samples from stability regions (Lemma 31.2.4). Example: For a 500-atom corpus, simulate convergence: start with underdamped ζ < 1 for fast exploration, then overdamp to ζ > 1 for settling, reducing iterations by 30–50%.
DVNS Optimization
: Introduce asynchronous queues before the single-writer gate, batching atoms into molecules (Chapter 4) with temporary QS approximations. For SLOs, add adaptive throttling: if mean DD > θ_d (e.g., 0.3), escalate to HITL (Chapter 17) or degrade to coarse reads. Metrics: Track p99 latency on writes; aim for RS-lift ≥ +20% vs. baselines under load (empirical lift in Section 9.4).
Burst Handling
: Extend HHNI to a sharded, vector-graph hybrid using tools like Apache Cassandra for the evidence graph store (Chapter 7) or Faiss for embeddings. For super-index precomputation (Section 9.3), implement a MapReduce-style offline job that partitions by TPV priority vectors—e.g., high-priority atoms (priority > 0.7) on faster shards. This could integrate with Markov traversals for caching (Section 6.3), preloading likely paths based on historical queries.
Distributed Variants
:
Detailed Recommendations
: GODN forces (gravity/elastic/repulse/damping in Chapter 31) converge via Velocity-Verlet integration, but for large top-k (e.g., 64+ candidates), iterations might exceed budgets (e.g., tokens/time in APOE, Chapter 11). Stability regions (CFL bounds) are well-defined, but without parallelization, online refinement could lag in distributed setups.
DVNS Compute
: HHNI's multi-granular embeddings (system → sub-word) with dependency hashing scales O(log N) for lookups, but building impact previews on edits (DD computation) could be O(N) in dense graphs, especially if edges (supports/contradicts) proliferate in SEG (Chapter 15).
Indexing Overhead
: The write path (ingest → atomize → enrich → index → score → gate → snapshot in Section 1.2) is transactional and single-writer (Constraint C-1), which ensures determinism but could serialize high-volume inputs (e.g., 3GB logs in your example). If bursts exceed SLOs, DD previews might delay gates, leading to quarantines under SDF-CVF (Chapter 16).
Ingestion Bursts
:
Challenges/Gaps
: Your design emphasizes efficiency through mechanisms like HHNI's fractal indexing (Chapter 5), DVNS's physics-inspired refinement (Chapters 8–10), and SLOs (e.g., p95 write < 200ms in Chapter 6). However, for AGI-scale operations—handling petabyte corpora, real-time multi-user queries, or dynamic growth—the system might encounter bottlenecks in ingestion, indexing depth, or force computations. Static KNN baselines are useful for RS-lift metrics (Chapter 22), but without distributed handling, super-index precomputation could become a single point of failure, especially with recursive hierarchies that grow fractally to atomic levels (e.g., word/sub-word).
Rationale
1. Scalability and Performance
 (Appx-G)
Quickstarts & Labs
 (Ch.16, Ch.20)
Gate catalog & policies
 (Ch.13, Ch.27)
ACL grammar & examples
 (Ch.15, Ch.27, Appx-I)
SEG JSON-LD
 (Ch.14, Appx-I)
VIF schema
Ready-to-Use Artifacts (recap)
 every section is versioned as atoms/molecules with SEG lineage and ADR cross-links.
Living doc:
 short nouns, typed schemas, examples > exposition.
Style:
—specs you can run, decisions you can audit, plans you can replay.
working textbook
 make a 
Intent:
Author/Editor Notes
• SDKs — Ch.29 • Math — Ch.30–31 • Logic — Ch.32 • Roadmap — Ch.33 • Community — Ch.34 • Glossary — Appx-A.
AIMOS (overview) — Part I Ch.1 • CMC — Ch.4–7 • HHNI — Ch.5 • DVNS — Ch.8–10 • APOE — Ch.11–12 • ACL — Ch.13 • VIF — Ch.14 • SEG — Ch.15 • SDF-CVF — Ch.16 • HITL — Ch.17 • IDE-in-loop — Ch.18–19 • Security — Ch.20 • Compliance — Ch.21 • Benchmarks — Ch.22 • Observability — Ch.23 • Cases — Ch.24–26 • Schemas — Ch.27 • APIs — Ch.28 
Subject Index (Mini)
 The project repository links each reference to SEG nodes for machine-readable lineage.
Note:
 Prompt-injection mitigations; capability sandboxing; privacy-preserving ML.
Safety & Security:
 OpenTelemetry specs; SRE handbooks; calibration (ECE) and LLM evals (HELM-style).
Observability & Reliability:
 EU AI Act texts and summaries; model cards & data statements; content provenance standards.
Provenance & Compliance:
 Dense embeddings, hybrid retrieval, calibration & reranking literature.
Retrieval & Indexing:
 Multi-agent planning frameworks; evaluator-optimizer patterns; chaining & routing guides.
Prompt Orchestration & Agents:
 Hyena Hierarchy papers; Liquid Neural Networks (MIT); state-space models.
Sub-Quadratic Alternatives:
; “Lost in the Middle” analyses; efficient long-context surveys.
Attention Is All You Need
 Vaswani et al. 
Transformer & Long-Context:
Bibliography (Selected, neutral)
Back Matter
 Auto-fix PR; else quarantine; owner escalation.
Actions:
 code passes but spec/tags/trace missing.
Signals:
Parity Violation (SDF-CVF)
 Re-run retrieval with policy expansion; if absent, downgrade confidence or retract.
Actions:
 claim without supporting edges.
Signals:
Evidence Gap
 Recalibrate bins → temperature sweep → update UQ model → publish VIF deltas.
Actions:
 ECE ↑, κ false negatives.
Signals:
Calibration Drift
 κ-abstain → sandbox halt → SEG tag contradicts → patch guardrails → retrospective ADR.
Actions:
 unusual tool calls, outbound spikes.
Signals:
Prompt Injection Detected
Playbooks (abridged)
 — Critical: TSC approval + staged rollout + rollback plan.
R3 Security/Compliance
 + HITL logs.
two-key
 — High: 
R2 Orchestration/Agents
 — Medium: 1 approver + green gates.
R1 Retrieval/UX
 — Low: lazy consensus merge.
R0 Docs/UI
Risk tiers
Appendix J — Risk Taxonomy & Playbooks
Log retention manifest (≥6 months), lineage coverage %, κ-abstention policy, synthetic labeling config, DPIA summary, incident response checklist, model card.
I.3 EU AI Act Pack
}
  ]
    {"@id":"e:1","@type":"Evidence","source":"snap-...","supports":"claim:42","valid":"[2025-10-17T12:00Z, )"}
    {"@id":"claim:42","@type":"Claim","text":"Anomaly rate 2.3%"},
  "@graph":[
  "@context":"https://schema.aimos.dev/seg/v1",
{
I.2 SEG Export (JSON-LD)
}
  "created_at":"2025-10-17T12:35:22Z"
  "uncertainty":{"ece":0.031,"band":"green"},
  "tools":["retriever@1.4","verifier@2.0"],
  "prompt_template_id":"PT-claims-v3",
  "model":{"id":"gpt-x@2025.10","weights_hash":"sha256:..."},
  "snapshot_id":"snap-2025-10-17T12:34Z",
  "artifact_id":"claim-42",
{
I.1 VIF Bundle (JSON)
Appendix I — Compliance Artifacts (Sample Export Packs)
Two-key policy adjustments
Review thresholds; risk-tier overrides
Over-strict gates
Quarantine storms
Enable TTL for stale nodes
Add temporal filters; prune low-weight edges
Time-slice explosion
SEG queries slow
Add seed discipline in ACL
Pin tool versions; freeze snapshot
Hidden tool variability
Chain nondeterminism
Temperature sweep; retrain UQ head
Run ECE calibration; widen κ bands
Poor calibration
Frequent κ-abstentions
Re-index; raise preload.depth
Deepen HHNI; add paragraph/sentence indices
Shallow IDS
Low RS despite good QS
Fix
Triage
Likely Cause
Symptom
Appendix H — Troubleshooting Guide
Verify SDF-CVF parity: changing spec breaks tests until code updated.
Blueprint YAML → scaffold REST service → generate tests → local deploy.
G.4 IDE-in-Loop Mini-App
Run, capture VIF at boundaries, replay against a frozen snapshot.
Write a pipeline research_then_build { … } with budgets and gates.
G.3 Orchestration Lab (ACL)
Plot convergence (ΔE per iteration) and abstentions by κ-band.
Tune (G,k,α,β,γ); observe RS-lift vs. static KNN.
Seed 500 atoms; run DVNS refinement on Top-k=20.
G.2 DVNS Retrieval Lab
GET /v1/memory/snapshots/{id}
Inspect snapshot
{ "query":"AIMOS", "top_k":5 }
POST /v1/memory/search
Search
{ "modality":"text", "content":"Hello, AIMOS.", "metadata":{"src":"lab"} }
POST /v1/memory/atoms
Create atom
G.1 10-Minute Memory Atom
Appendix G — Quickstarts & Labs
LIMIT 50;
ORDER BY tpv.priority DESC
AND tags CONTAIN '#definition'
WHERE path LIKE '//cmc/%/sentence/%'
SELECT word FROM hhni
Query examples (pseudo-QL)
 on edit computes DD = Σ w_i · |Δtag_i| with alert if DD > θ.
Impact preview
Every node carries dep_hash, parents[], siblings[], cross[] (semantic) with weight and immutability_flag.
Cross-links
//cmc/schemas/1/4/* → all words in §4 of schemas section.
//apoe/acl/2/5/3 → 3rd sentence of §5 in Chapter 2 (APOE grammar).
Example:
//system/section[n]/paragraph[m]/sentence[k]/word[j]
Path syntax
Appendix F — Index of Indexes (HHNI Cross-Reference)
Known gaps: ACL formal semantics examples (more), additional export pack recipes, extended labs.
Appendices A–J and Back Matter established.
Parts I–XIII complete: invariants, CMC/HHNI, DVNS, APOE/DEPP, VIF/SEG, SDF-CVF, IDE-in-loop, security/compliance, benchmarks, observability, cases, reference impls, math, governance.
v0.1 — Initial Extreme Textbook
Appendix E — Change Log (Excerpt)
T8. Cost budgets (tokens/time/tools) by plan class
T7. Observability fields (OTel span schema)
T6. Compliance artifact mapping (EU AI Act/SOC2/ISO)
T5. Risk taxonomy (R0–R3) vs. required controls
T4. Gate catalog and default policies
T3. κ-bands and UI confidence cues
T2. RS components (QS/IDS/DD) and calibration bins
T1. Invariants→Constraints Traceability
Tables
F7. IDE-in-the-loop: blueprint→scaffold→code→test→deploy→observe
F6. SDF-CVF parity across code/docs/tags/traces
F5. SEG time-sliced lineage (claim→evidence→decision)
F4. APOE plan execution DAG with gates and witness emission points
F3. DVNS field lines (grav/elastic/repulse/damping) over embedding space
F2. HHNI fractal index (system→…→sub-word) with dependency hashing
F1. CMC Write/Read pipeline (atoms→indices→snapshot→graph)
Figures
Appendix D — Figures & Tables List
Post-incident ADR links to SEG, adds guardrail tests; all parity gates pass.
Autoremediation plan (APOE) proposes rollback; κ triggers HITL (two-key).
DVNS clusters two commits + config change; RS=0.91 for culprit chain.
Query SEG for last 48h changes touching transform.
Flow
 Error budget burn on /transform p95 latency.
Symptom
C.3 Ops Incident: RCA & Safe Autoremediation
OTel spans emit VIF snippets at step boundaries; SEG accumulates claim→evidence→decision.
Deploy & Observe
IDS rises as documentation and tests index deeper; RS-lift observed in code search.
; molecules represent packages.
atom
Each route, schema, and test is an 
CMC/HHNI
.
✅
 g_safety
✅
 g_trace
✅
 g_tags
✅
 g_tests
✅
SDF-CVF gate summary on PR: g_spec
Generates service skeleton, tests, IaC stubs, SEG exporter.
APOE compile → scaffold
nonfunc: {slo: {latency_p95_ms: 120}, budget: {tokens: 40k}}
  outputs: SEG nodes + metrics
  storage: vector+object
  ingest: http POST /v1/events
spec:
domains: [ingest, transform, observe]
app: telemetry-bridge
Blueprint YAML (excerpt)
C.2 Builder Program: From Blueprint to Running Service
RS rises to 0.86; κ passes; answer emitted with confidence band ±0.4%.
Forces pull time-adjacent atoms; elastic forbids crossing batches.
Query: “spike between 14:20–14:30 UTC?”
DVNS retrieval
summary_claim ("2.3% anomaly rate") <- detect <- evidence:set
   supports                 derives                 supports
log_lines -> normalized_events -> anomaly_candidates
SEG lineage (compact)
}
  "uncertainty": { "ece": 0.027, "entropy": 0.18, "kappa": 0.75 }
  "snapshot_id": "snap-2025-10-17T12:00Z",
  "tools": ["csv@1.2","json@2.1","anomaly@0.9"],
  "prompt_template_id": "PT-logs-std-v7",
  "weights_hash": "sha256:f3…",
  "model_id": "apoe-evaluator@2025.10",
{
VIF (attached to detect)
Snapshot snap-2025-10-17T12:00Z is created before analysis.
HHNI builds sentence/word sub-indices for field names/values.
 (type: log_line), embeddings, tags (#timestamp, #source).
atoms
ingest → 
CMC write path
}
  step summarize(report:r, witness:w) -> brief:txt gate g_prov;
  step detect(atoms:b[]) -> report:r, witness:w gate g_safety;
  step normalize(atoms:a[]) -> atoms:b[] gate g_spec;
  step ingest(input:file.csv) -> atoms:a[] gate g_trace;
  budget tokens=12k, tools=["csv", "json", "anomaly"], time="2m";
pipeline translate_and_analyze {
APOE plan (ACL excerpt)
 Convert a proprietary CSV log → standardized JSON events, detect anomalies, and produce an auditable summary.
Goal
C.1 Machine Communication: Protocol Translation (with VIF/SEG)
Appendix C — Extended End-to-End Examples
AIMOS, APOE, ACL, ADR, AUP, CMC, CVE, DAG, DVNS, ECE, GNN, GODN, HITL, HHNI, KNN, MTTR, nDCG, NP (Natural Processes), OTel (OpenTelemetry), PII, PR, QA, RAG, RCA, RS, SBOM, SEG, SDF-CVF, SLO, SOP, TPV, TSC, UQ, VIF.
Appendix B — Acronyms
 — Verifiable condition (tests/spec/safety/provenance/trace) required at plan boundaries and merges.
Gate
 — Content-addressed, immutable bundle of atoms, indices, and references; basis for replayability.
Snapshot
 — Expected Calibration Error; gap between predicted confidence and empirical accuracy.
ECE
 — Abstention threshold; if uncertainty > κ or RS < κ, the system declines and routes to HITL.
κ (kappa)
 [priority, relevance, decay] used for compression, caching, and preloading.
Tag Priority Vector.
 — 
TPV
 RS = norm(QS · IDS · (1−DD)), calibrated to approximate p(relevance).
Retrieval Score.
 — 
RS
 Change impact across the dependency graph ([0,1]); high DD triggers impact previews/HITL.
Dependency Delta.
 — 
DD
 Structural coverage (hierarchy depth × density).
Indexing Depth Score.
 — 
IDS
 Local content quality/fitness (normalized [0,1]).
Quality Score.
 — 
QS
 with parity gates & rollback.
code/docs/tags/traces
 Atomic commits across 
Same-Delta Fusion / Cohesive Versioning Framework.
 — 
SDF-CVF
 Machine-readable provenance bundle: model id, weights hash, prompt template id, tools, snapshot id, uncertainty.
Verifiable Intelligence Frame.
 — 
VIF
 JSON-LD/temporal graph for claims, sources, derivations, tools, and decisions; time-sliced queries and export packs.
Shared Evidence Graph.
 — 
SEG
 Force model: gravitational (attract), elastic (stabilize), repulsion (avoid density), damping (converge).
Graviton Organic Dynamics Network.
 — 
GODN
 Physics-inspired retrieval using GODN forces and NP path costs over embedding space.
Dynamic Vector Navigation System.
 — 
DVNS
 Indices from system→section→paragraph→sentence→word→sub-word, with dependency hashing & impact previews.
Hyper-Hierarchical Neural Indexing.
 — 
HHNI
 Write/read pipelines, HHNI indexing, snapshots, rollback.
Context Memory Core.
 — 
CMC
 — Higher-order grouping of atoms (e.g., function, paragraph, session). Recursively nestable.
Molecule
 — Smallest persisted unit (text, code line, log record, user event). Carries content, modality, tags, embedding, and provenance.
Atom (Memory Atom)
 Minimal DSL to define pipelines/steps/gates/budgets; statically checkable with types & effects.
AIMOS Chain Language.
 — 
ACL
 Compiles reasoning into typed chains (DAGs) with budgets, gates, and witnessed traces.
AIMOS Prompt Orchestration Engine.
 — 
APOE
 The substrate that converts context into atoms, indices, snapshots, and evidence graphs.
AI Memory Operating System.
 — 
AIMOS
Appendix A — Glossary (Expanded)
: crisp definitions, runnable labs, line-of-sight examples, exportable compliance bundles, and operational playbooks. Everything here is memory-native (CMC), orchestrated (APOE), witnessed (VIF), atomically evolved (SDF-CVF), and anchored in the shared evidence graph (SEG).
builders, auditors, and readers-at-speed
This section packages the system for 
Appendices & Back Matter
—so progress compounds without sacrificing safety or trust.
governs by invariants
, and 
evolves atomically
, 
thinks in evidence
 a community that 
Outcome:
Merge (bot enforces green checks); release notes & SEG lineage auto-updated.
 approvals.
two-key
Respond to reviews; for R2/R3, obtain 
Open PR with gates summary; reviewers auto-assigned by rotation.
.
VIF
Run tests + policy suite; attach 
.
ADR
. If decided, write 
RFC
If in doubt, open 
Fork & branch (feat/…).
34.14 Quickstart for contributors (TL;DR)
“Good-first-issue” + “mentored-PR” lanes.
Community RFC weeks (no merges except fixes; discuss long-range proposals).
Quarterly public roadmap review (recorded, minutes published).
34.13 Community roadmap hooks
 with redacted details for transparency.
SEG records
All enforcement events create 
Graduated responses: mediation → temporary restrictions → removal.
 Contributor Covenant; reports to conduct@aimos.dev.
Code of Conduct:
34.12 Enforcement & dispute resolution
Model & prompt versions recorded (VIF)
HITL configured for R2/R3 flows
κ-abstention bands set for new surfaces
PII redaction validated
Data sources licensed & documented (SEG link)
ETHICS_CHECKLIST.md (per change)
- Amendments (ADR-backed)
- Conflict resolution & appeals
- Elections & terms for TSC
- Decision process (lazy consensus, two-key)
- Roles (contributors, maintainers, TSC)
- Charter & invariants
GOVERNANCE.md (outline)
  rollover_weekday: Mon
  timezone: UTC
schedule:
  safety_co_reviewer: true
  backup_after_days: 3
  max_active_prs_per_reviewer: 5
rule:
  security: [sam, taye]
  vifseg: [hugo, ida]
  apoe:   [frank, gita]
  dvns:   [dave, erin]
  cmc:    [alice, bob, carol]
areas:
```yaml
**REVIEW_ROTATION.yaml**
/seg/ @area-vif
/audit/ @area-vif @area-security
/orchestration/acl/ @area-apoe
/dvns/ @area-dvns
/cmc/ @area-cmc
**CODEOWNERS**
## 34.11 Templates & skeletons
---
| Quarantine resolution | p95 ≤ 3d | From isolation to merge |
| VIF coverage at boundaries | ≥ 99% | CI guardrail |
| ADR age (open) | p75 ≤ 10d | Exceptions require TSC note |
| PR review turnaround | p75 ≤ 3d | From ready-for-review |
| Time to first response (issues) | ≤ 24h | Business days |
|---|---|---|
| KPI | Target | Notes |
## 34.10 Community KPIs
---
- Weekly tech talk; monthly “ADR retrospective”; quarterly architecture review with external advisors.
**Learning rituals**
- **First week:** shadow a review; author a doc PR; run a red-team drill in staging.
- **First day:** read 3 foundational ADRs; pass policy quiz (AUP).  
- **First hour:** clone, run `make dev-up`, write your first **memory atom**, run **SEG query**.  
## 34.9 Onboarding & education
---
- Structured by area; include **migration** steps and **risk** callouts; link ADPs (audit data packs).
**Release notes**
- Every page ends with **SEG lineage** and “last reviewed” stamp.
- “Explain → Decide → Evidence → How-to”.  
**Docs style**
{ "snapshot_id":"...", "tools":["..."], "model_id":"..." }
```json
## VIF (machine-readable)
- g_spec: ☐  g_tests: ☐  g_tags: ☐  g_trace: ☐  g_safety: ☐
## Gates (paste CI summary)
- [ ] ADR-XXXX attached  -or-  N/A (low risk)
## ADR / RFC
## Linked Issue(s)
## What & Why
 (excerpt)
PR template
doc_gap.md (missing, audience, acceptance).
feature_request.md (problem, proposal, alternatives, risks).
bug_report.md (repro, expected/actual, logs, version).
 (select at creation)
Issue templates
34.8 Community ops
CVSS: NVD scoring; patches shipped before disclosure
Triage SLA: 3 business days
Embargo: 90 days by default
Email: security@aimos.dev  •  PGP: https://aimos.dev/pgp.txt
SECURITY.md (vuln disclosure skeleton)
 SBOM + license scan in CI; failing scan blocks merge.
Third-party deps:
 (Developer Certificate of Origin) — one is mandatory.
DCO
 
or
 (individual & corporate) 
CLA
 model cards + separate license notices.
Models/artifacts:
 CC-BY-4.0.
Content/specs:
 Apache-2.0 (patent grant).
Code license:
34.7 Legal: licensing, CLA/DCO, IP
 with issued tokens; report via security policy; no public disclosure before fix window ends.
staging
Only against 
Attack surfaces: prompt injection, tool SSRF, data exfiltration.
Red-team rules
; DP/noise where aggregation is published.
ingest
PII: redact at 
; SEG nodes for source → slice → usage.
required
License & provenance 
Dataset policy
Biometric identification without explicit, lawful basis.
Discrimination or harmful profiling.
Generation of malware or exploit kits.
Surveillance that violates local law or user consent.
Prohibited uses (non-exhaustive)
 κ-abstain on uncertainty; HITL for high risk.
Safety over speed:
 opt-outs for data reuse; meaningful consent.
User agency:
 what is necessary.
only
 collect, store, and expose 
Minimality:
 machine-readable provenance by default.
Transparency:
Core principles
34.6 Ethics & use policies (AUP)
 with Decision scope.
ADRs
 TSC decisions are 
Decision log:
 uphold invariants (CMC/APOE/VIF/SDF-CVF/SEG), arbitrate disputes, freeze plans for releases, own roadmap.
Charter:
 area leads + security lead + PM.
TSC (Technical Steering Committee):
34.5 Governance structure
 release manager.
Informed:
 safety, compliance; 
Consulted:
 area owner; 
Accountable:
 PR author; 
Responsible:
RACI
 unresolved after 5 business days → TSC vote (simple majority).
Escalation:
 (R2/R3): domain + safety must approve; HITL record attached (SEG).
Two-key approval
 (R0/R1): merge if no substantive objections in 48h and gates green.
Lazy consensus
Decision rules
Load balancing: max 5 active PRs per reviewer; auto-reassign on breach.
 (capability owner).
one safety reviewer
 + 
one area reviewer
Each PR auto-assigns 
 rotations: CMC, DVNS, APOE, VIF/SEG, Security, IDE/DX.
area-based
Weekly 
Rotations
34.4 Review rotations & decision rules
- Draft ADR? Pilot spike? Abort?
## Proposed Next Step
|--------|------|------|------|------------|------------|
| Option | Perf | Cost | Risk | Compliance | Complexity |
## Evaluation Matrix
- Option B ...
- Option A (pros/cons, risks, cost)
## Options
## Goals / Non-goals
Facilitator: @handle
Window: 2025-10-17 → 2025-10-31
Status: Open | Closed  
# RFC: <Problem/Opportunity>
```markdown
**RFC Template (short)**
- Time-boxed (typically 7–14 days), with explicit call for dissent and alternatives.
- **RFC** precedes ADR for **ambiguous** or **cross-cutting** design questions.  
## 34.3 RFCs — when & how
---
SEG node: seg://adr/XXXX
PRs: !789, !790
Issues: #123, #456
Links
 κ-bands honored; policy tests pass
✅
g_safety: 
 SEG lineage query returns non-empty
✅
g_trace: 
 HHNI tags + TPV updated
✅
g_tags: 
 unit/integration load
✅
g_tests: 
 docs updated
✅
g_spec: 
Gates & Verification (SDF-CVF)
}
  "snapshot_id": "snap-2025-10-17T12:34Z"
  "tools": ["benchmark:rs_lift@v2", "proof:acl_checker@v1"],
  "prompt_template_id": "PT-123",
  "weights_hash": "sha256:...",
  "model_id": "xxx",
{
```json
## Evidence (VIF)
- Deprecations/tombstones; impact on SLOs/cost.
- Benefits, trade-offs, risks, migration plan.
## Consequences
- Interfaces affected (APIs, schemas, ACL constructs).
- Chosen approach; diagrams or schemas as needed.
## Decision
- Prior art / alternatives considered (link RFCs, issues).
- Problem statement, constraints, stakeholders.
## Context
Scope: area:cmc, area:apoe (labels)
Risk: R0 | R1 | R2 | R3  
Owners: @handle1 (@area), @handle2 (@safety)  
Date: YYYY-MM-DD  
Status: Proposed | Accepted | Superseded by ADR-YYYY | Rejected  
# ADR XXXX: <Title>
ADR Template (docs/adr/XXXX-title.md)
 with edges to the PRs, tests, and benchmarks that evidence it.
SEG node
Every ADR gets a 
Proposed → Accepted → Superseded or Rejected.
ADR lifecycle
.
understand or challenge
Anything a future maintainer would need to 
Anything that changes an interface, storage schema, ACL semantics, security posture, or compliance behavior.
When to write an ADR
34.2 ADRs — templates & process
.
SEG
 reviewers (domain owner + safety owner); human-in-the-loop sign-off recorded in 
two-key
High-risk (R2/R3): 
 (chosen option) → PR(s) → Merge (if gates green) → Release note.
ADR
 (design options) → 
RFC
Idea → Issue → 
Decision flow
Outcomes: needs-adr, needs-rfc, needs-hitl, quarantined.
Areas: area:cmc, area:dvns, area:apoe, area:vif, area:seg, area:ide, area:security.
Risk tiers: risk:R0 (docs), R1 (low), R2 (med), R3 (high).
Labels
 status (tests/spec/tags/trace/safety).
gates
 (VIF JSON), 
witness
All PRs must include: linked issue, 
 required for memory, orchestration, and audit packages.
CODEOWNERS
main (protected, signed, green-only), develop (integration), feature branches feat/*, hotfix fix/*.
Repos & branches
34.1 Contribution model
 lazy consensus for low risk; two-key for high risk.
Open by default, governed by evidence:
, not suggestions.
policies
 abstention, redaction, and HITL are 
Safety-first:
 (SDF-CVF).
together
 code/docs/tags/traces change 
Atomic evolution:
.
SEG
 and a link into the 
VIF
 every decision is an artifact (ADR/RFC) with 
Memory-native community:
34.0 Scope & principles
.
transparent process
, and community trust is earned through 
atomically
, contributions evolve 
witnessed decisions
 project where ideas become 
living, accountable
Objective: make AIMOS/APOE a 
Chapter 34. Community & Contribution — ADR templates, review rotations, ethics & use policies
Part XIII — Roadmap & Governance
 traces, cost-bounded orchestration, and policy-enforced guardrails—ready to scale or harden per domain.
witnessed, reproducible
 delivering two pilots with 
auditable, memory-native, agentic system
 in 90 days we stand up an 
Outcome:
 blocked policy violations, injection detections, residual risk.
Security:
 blueprint→deploy lead time, preview pass rate.
IDE-loop:
 CFR, MTTR, spec↔code parity score.
SDF-CVF:
 lineage completeness %, replay fidelity, export validity.
VIF/SEG:
 plan determinism rate, budget adherence %, κ precision/recall.
APOE:
 precision@k@latency, RS-lift vs. KNN, snapshot replay pass %.
CMC:
33.9 Program KPIs (tied to invariants)
 compliance snapshot (export pack), security tabletop.
Monthly:
 pilot steering—SEG lineage demo; incident learnings.
Bi-weekly:
 gate review (failed gates, quarantines), budget & drift review, ADR board.
Weekly:
 standup (risks, blockers, κ events).
Daily:
33.8 Governance rituals
 passes gates (spec/tests/tags/trace/safety); witness present; docs updated; SEG lineage query returns non-empty; dashboards show green SLOs.
DOD (feature):
 ADR exists; inputs/schemas fixed; owners named; tests & gates listed; budget class assigned.
DOR (any task):
33.7 Definitions of Ready/Done
, daily spend alerts, breaker on budget breach (emits VIF).
token budgets
 per-project 
Controls:
Infra: $12–20k, Models: $15–30k, People: team-dependent.
90-day envelope (illustrative):
 two providers for ensemble UQ + low-cost model for bulk.
Model spend:
 vector store, graph DB, object store, CI runners, observability stack.
Infra:
33.6 Budget & cloud footprint (order-of-magnitude)
 Designer (confidence UX), Tech Writer (ADRs), Program Manager.
Adjunct:
DX/SDK Eng (TS/Py/CLI) ×1
Security/Policy Eng (caps, guardrails, compliance) ×1
Platform/SRE (OTel, CI/CD, cost) ×1
Orchestration Eng (ACL/DEPP compiler) ×1
Retrieval/ML Eng (DVNS, ranking) ×1
Memory/Storage Eng (CMC/HHNI, perf) ×2
Lead Architect (overall invariants & interfaces)
Core (7–9 FTE):
33.5 Resourcing plan (people/roles)
Temperature sweeps + tie-break; determinism flags; verifier acceptance tests
Irreproducibility
Nondeterminism
Risk tiering; two-key only for ≥R2; reviewer rotations; SLAs
Throughput drops
HITL bottleneck
Boundary macros emit VIF; coverage monitors; build breaks < 98%
Audit failure
VIF gaps
Capability tokens; sandbox FS/NET; policy engine; redaction gates
Data exfiltration, corruption
Tool prompt injection
Budget indices in ACL; compile-time fail; runtime breaker w/ VIF
Cost/SLO violations
Over-budget chains
Adaptive pruning by TPV; shard super-index; impact previews before persist
Slow writes/reads
Index bloat / DD spikes
Damping + step-size schedule; auto-tuner; abstention bands
Bad retrieval, cost blowups
DVNS oscillation/instability
Mitigation
Impact
Risk
33.4 Risks & mitigations
.
OTel stitching (WS-X)
 + 
SEG time-slicing (WS-V)
 depends on 
Compliance export (WS-V)
.
witnessed tests (WS-I)
 and 
Snapshot log (WS-M)
 depends on 
Quarantine/rollback (WS-E)
.
HHNI read APIs (WS-M)
 depends on 
DVNS (WS-R)
.
capability catalog (WS-S)
 and 
VIF/SEG shapes (WS-V)
 depends on 
ACL checker (WS-O)
33.3 Dependency graph (high level)
One greenfield + one brownfield pilot running with on-call playbooks.
No P0/P1 security findings; policy engine blocks forbidden capability paths.
κ-abstention precision ≥ 0.8 (manual judged on sampled queries).
Reproducible replay on frozen snapshot across all pilots.
Exit gates (pilot-go)
CLI golden paths; SDK samples (memory write/read; plan compile/run; audit query).
WS-K:
OTel traces stitched to SEG lineage; cost/latency error budgets enforced.
WS-X:
Risk registers; residual-risk sign-off; two-key HITL for high-risk merges.
WS-S:
IDE-in-the-loop demo: blueprint→running app→observe with full witnesses.
WS-I:
DORA telemetry live (CFR, MTTR); quarantine auto-unblock with evidence.
WS-E:
Compliance export pack (EU-style logging bundle; synthetic content labels).
UQ+confidence UX (bands, tooltips, stratified warnings).
WS-V:
DEPP thousand-node planning with budget adherence alarms.
 (SMT + SHACL + Datalog policies); proof artifacts to SEG.
v1.0
ACL checker 
WS-O:
DVNS parameter auto-tuner; stability regions documented; abstention bands.
WS-R:
Snapshot log with tombstones; retention configs.
SLOs met (p95 write < 200 ms; read < 150 ms on top-k 64; p95 DD preview < 50 ms).
WS-M:
Deliverables
Day 61 → Day 90 (“Pilot-ready, auditable”)
Incident drill: SEG-driven replay + RCA in ≤ 30 min.
RS-lift ≥ +20% and nDCG@20 ≥ baseline +0.06 on two domains.
VIF lineage completeness ≥ 98% (measured over all boundaries).
 documented nondeterminism with verifier stabilization.
or
Chain determinism (under fixed seeds/tools) 
Exit gates
Python client parity; paginators, retries; end-to-end examples.
WS-K:
Drift & prompt-rot monitors; budget SLOs; cost dashboards.
WS-X:
Capability sandbox for tools; SSRF/injection playbooks; policy packs (PII/licensing).
WS-S:
; coverage gates + parity checks.
Test/Preview Deploy
Pipeline to 
WS-I:
Auto-fix strategies; rollback catalog; MTTR SLO.
Same-commit parity enforcement across code/docs/tags/traces; ADR templates.
WS-E:
SEG time-slicing queries; lineage → decision views; export pack v1.
UQ ensembles (two models) + calibration (per-domain bands).
WS-V:
Router (role-aware), parallelization, tool contracts; plan diff + health (κ_chain).
; determinism flags.
budget indices
 and 
with linear capabilities
ACL type-and-effect 
WS-O:
Super-index refresh strategy; convergence monitors.
Online DVNS refinement on retrieval results; policy-aware geometry (forbidden crossings).
WS-R:
Caching/preload (Markov traversals), perf targets documented.
Impact previews (DD) + dependency hashing; partial rollback.
WS-M:
Deliverables
Day 31 → Day 60 (“Beta orchestration”)
Budget checker blocks over-budget plans at compile time.
RS-lift ≥ +10% vs. static KNN on a seed task; κ-abstentions logged with rationale.
VIF coverage ≥ 90% at boundaries; replay on frozen snapshot succeeds.
Snapshot-first: no user-visible state without snapshot id.
Exit gates (must pass)
TS client (Memory API + Audit read-only); basic CLI.
WS-K:
OTel spans for steps/tools; token/latency meters; cost model stub.
WS-X:
Threat model; capability tokens; redaction; abstention/κ rules.
WS-S:
Blueprint YAML and scaffolder for one stack (UI/API/Auth/Data).
WS-I:
Gate catalog v1 (g_spec, g_tests, g_tags, g_trace, g_safety); quarantine workflow.
WS-E:
SEG JSON-LD shapes; write path for boundary events.
UQ baseline: temperature sweep + entropy; calibration dashboard (ECE).
VIF tuple (model id, weights hash, prompt template id, snapshot id, tools).
WS-V:
DEPP skeleton: plan graph + evaluator-optimizer loop.
ACL grammar (EBNF), minimal type/effect checker (budgets, capabilities).
WS-O:
Super-index offline precompute for a seed corpus.
 cost functions.
C(P)
DVNS core loop (grav/elastic/repulse/damping) on top-k rerank; 
WS-R:
Read path v1: dumbbell compression, two-stage read (C-3).
 builder (system→…→sub-word) with TPV and DD computation.
Index-of-Indexes
HHNI 
 transactional flow (C-1/C-2).
CreateMemory
Fractal Memory Hierarchy schemas (Atom/Edge) and 
WS-M:
Deliverables
Day 0 → Day 30 (“Alpha substrate”)
33.2 0-30-60-90 plan (deliverables, exit gates)
 SDKs/Clients (TS, Python, CLI) + API surface.
WS-K:
 Observability & Costing (OTel for agents, budgets, drift).
WS-X:
 Security & Compliance (guardrails, policies, mapping).
WS-S:
 IDE-in-the-Loop pipeline (blueprint→deploy).
WS-I:
 Atomic Evolution (SDF-CVF gates, quarantine/rollback).
WS-E:
 Verifiability (VIF schema, UQ, replay, SEG & time-slicing).
WS-V:
 Orchestration (APOE/DEPP, ACL compiler & checker).
WS-O:
 Retrieval (DVNS physics layer, super-index, online refinement).
WS-R:
 Memory Core (CMC/HHNI, write/read pipelines, storage substrate).
WS-M:
33.1 Workstreams (WS)
 one primary vector store + one evidence graph store; access to ≥2 foundation models; small cross-functional team (see 33.5).
Assumptions:
 custom base model training; full enterprise rollouts.
Non-goals in 90d:
 CMC+HHNI (memory), DVNS (retrieval), APOE/DEPP (orchestration), VIF/SEG (provenance), SDF-CVF (atomic evolution), IDE-in-the-loop, security/compliance, observability, SDKs.
Scope:
33.0 Scope & assumptions
 pilots in 90 days—with clear exit criteria, owners, budgets, and gates tied to the invariants (CMC/APOE/VIF/SDF-CVF/SEG).
auditable
, 
running
Objective: take AIMOS/APOE from spec to 
Chapter 33. 0-30-60-90 — milestones, risks, dependencies, resourcing & budgets
Part XIII — Roadmap & Governance
 become operational rather than aspirational.
SEG
 and 
VIF
 and the substrate upon which 
APOE’s reliability
: if it compiles, it respects capabilities, budgets, and provenance duties by construction. That is the core of 
plans into proofs
 ACL’s type-and-effect discipline turns 
Outcome:
 type cert, effect summary, budget cert, policy proof — bound to snapshot id.
Artifacts written to SEG:
Datalog/OPA for policies
SHACL for SEG payloads
SMT (Z3/CVC5) for refinements & gates
Back-end:
 Hindley–Milner + effect rows + linear capabilities; interval arithmetic for indices; global fold for budgets.
Middle-end:
 EBNF from Ch.13 extended with type annotations and with Budget[…] clauses.
Front-end:
32.12 Implementation notes
 assumes no shared mutable state beyond typed capabilities.
Parallelism
 are only as strong as predicates and solver timeouts; we cache and bound.
Refinements
 are upper bounds; real usage may be lower; we treat tool slack as OK.
Budgets
 are assumed correct; breakage is caught at runtime with VIF.
Model/tool contracts
32.11 Soundness notes & limitations
 and links to the violated rule.
fix-its
Each error includes 
 “source of nondeterminism: CallLLM(temp=0.8); add verifier or relax claim.”
Determinism claim failed:
 “net[external] forbidden without HITL proof (Policy §7.2).”
Policy violation:
 “merge lacks Emit[VIF] — add gate(g_trace) or emit_vif.”
Unwitnessed boundary:
 “call_llm needs Tokens≥12 345; declared ≤8 000.”
Budget under-spec:
 “call(tool) requires seg_write; have seg_read.”
Missing capability:
32.10 Diagnostic strategy
 unless verify stabilizes (e.g., temperature sweep + tie-break); checker suggests mitigations.
non-deterministic
Determinism: flagged 
Budget ceiling: Tokens≤8k, Secs≤3.7
Effects: {SEG[read], CallLLM, CallTool["lint"], Emit[VIF]}
Type: Query -> Answer×Witness
Whole pipeline summary:
merge requires gate proofs → emits Witness.
Parallel reason || verify: budgets sum → (≤8k, ≤3.5); effects union.
0.5)
≤
 (0,
▷
verify effects {CallTool["lint"], Emit[VIF]} 
3)
≤
8k,
≤
 (
▷
reason effects {CallLLM, Emit[VIF]} 
0.2)
≤
 (0,
▷
retrieve effects {SEG[read]} 
Typing facts (selected):
 g_safety)
∧
 g_trace 
∧
  gate(g_spec 
step merge : (Draft×Verdict) -> Answer×Witness
  with Budget[0, secs≤0.5]
  using Tool["lint", caps={exec[js]}] 
step verify : Draft -> Verdict×Witness
  with Budget[tokens≤8k, secs≤3]
  using Model["gpt-x", temp=0.2] 
step reason : List[Atom] -> Draft
  with Budget[tokens=0, secs≤0.2]
  using Tool["vecstore", caps={seg_read}] 
step retrieve : Query -> List[Atom] 
 retrieve → (reason || verify) → merge → emit.
Plan:
32.9 Worked example (derivation sketch)
 ready for execution.
witness-carrying plan
 typed AST; effect summary; budget table; solver proofs; 
Artifacts:
Datalog policy: polynomial; incremental.
SHACL (SEG shapes): linear in graph size.
SMT (refinements/gates): worst-case NP-hard; in practice small and cached.
 obligations to solvers:
Pass 4:
 budget aggregation (monoid fold).
Pass 3:
 type/effect inference with capability linearity (near-linear in |AST|).
Pass 2:
 kinding, name resolution, role/capability binding (linear).
Pass 1:
32.8 Checker architecture & complexity
 all via induction on typing derivations and small-step operational semantics for ACL; budget safety leverages potential-style indices; noninterference follows classic security typing.
Sketches:
If a plan type-checks under labels and has no declassify edges, then changes to High inputs cannot alter Low outputs (modulo Abstain), i.e., confidentiality holds.
Theorem 32.7.5 (Noninterference, optional).
Every boundary (plan start/end; tool/LLM call; gate) in a well-typed trace produces a Witness that links artifacts to inputs/tools/snapshots, ensuring VIF completeness.
Theorem 32.7.4 (Lineage totality).
 static Budget unless a tool violates its contract; such violations surface as Overbudget errors carrying VIF of the offender.
do not exceed
For any well-typed plan, at runtime cumulative tokens/seconds 
Theorem 32.7.3 (Budget safety).
(budgets don’t grow; effects don’t appear from nowhere). Capability multiset evolves linearly.
and 
with 
, then 
and 
If 
Theorem 32.7.2 (Preservation).
with Witness{reason}.
 
or
(a reduction step exists) 
 
or
 
either
and all external tools/models are available, then 
If 
Theorem 32.7.1 (Progress).
32.7 Soundness theorems (informal but precise)
Confirms capability use matches policy; produces human-readable “why allowed” proof trace.
Policy/Datalog engine.
Flags nondeterministic sources (Random, Time, CallLLM with temp>τ, external net) unless bound behind Verifier gates with stabilization (e.g., temperature sweep + tie-break).
Determinism checker.
Ensures lineage graphs satisfy shape constraints (nodes, edges, temporal validity).
SEG/JSON-LD validator (SHACL).
Unprovable → plan refuses to compile unless an Abstain[κ] arm exists.
Proves predicates used by g_spec, g_tests, g_tags, g_trace, g_safety.
Gate satisfiability (SMT).
.
obligation set
Outputs: typed AST, global effect row, budget ceiling, 
Linear capability accounting; row-polymorphic effects; budget addition; refinement constraints to SMT (Z3).
Type/Effect/Budget checker (ACL-TC).
32.6 Symbolic checkers (toolchain)
 during checking.
unsatisfied proof obligations
 Datalog/OPA-style rules over VIF + SEG (e.g., “no seg_write to external tenant without HITL witness”). Violations become 
Policy logic:
 with Witness{policy}.
declassified gates
 well-typed plan prevents High→Low leaks except through 
Noninterference:
 Low ≤…≤ High; types lifted to T@ℓ.
Security labels:
32.5 Information-flow & policy logic (optional layer)
: if it type-checks, runtime cannot exceed the budget unless a tool violates its contract (then the runtime raises Overbudget with VIF).
amortized resource analysis
This yields 
 a bounded slice; the checker ensures final total ≤ declared pipeline budget.
consumes
Each LLM/tool rule 
.
Subtyping: Budget[t1,s1] <: Budget[t2,s2] iff 
.
:
Budget[t:idx, s:idx] with monoid 
 at compile-time:
potential
We track resource 
32.4 Budgets as indexed types
 0
▷
) : Result[T,Abstain] ! {Abstain[κ], Emit[VIF]} 
κ
 abstain(
⊢
Γ; Φ; Δ 
———————————————
}
κ
 
≥
 risk : Score{risk 
⊢
Γ; Φ 
 if preconditions cannot be proved or UQ exceeds risk bands:
return Abstain[κ]
A step may 
(ABSTAIN)
 join(B_i)
▷
_i 
ε
⋃
 route(pred){arm_i} : T ! 
⊢
Γ; Φ; Δ 
———————————————
 B_i
▷
_i 
ε
 arm_i : T ! 
⊢
 
Δ
; 
Φ
; 
Γ
i. 
∀
 pred : Score
⊢
Γ; Φ 
 by static branch coverage bounds or worst-case:
weighted joins
 and budgets are 
type-agree
All branches must 
(ROUTE)
 B2)
⊕
 (B1 
▷
 ε2) 
∪
 p || q : T×U ! (ε1 
⊢
Γ; Φ; Δ 
———————————————————————————————
 Δ2         // disjoint linear split
⊎
Δ = Δ1 
 B2
▷
 q : U ! ε2 
⊢
Γ; Φ; Δ2 
 B1
▷
 p : T ! ε1 
⊢
Γ; Φ; Δ1 
:
split
 effects; capability tokens must be 
union
Parallel branches sum budgets and 
(PAR)
(no duplication).
Capabilities flow linearly: 
:
monoidally
Sequential composition accumulates effects and adds budgets 
(SEQ)
 0
▷
 gate(pred) : Witness ! {Emit[VIF]} 
⊢
Γ; Φ; Δ 
———————————————
 pred : Bool
⊢
Γ; Φ 
A gate checks a predicate, emits a Witness, no effects beyond Emit[VIF]:
(GATE)
 emits VIF (model id, weights hash, prompt template id, snapshot id).
Obligation:
 B'
▷
Witness ! {CallLLM, Emit[VIF]} 
×
UQVec
×
 call_llm(m,e) : Text
⊢
Γ; Φ; Δ 
———————————————
B' = { tokens = T_max, secs = SLA(id,T_max) }
 prompt(e)+ctx}
≥
 T_max : Tokens{T_max 
⊢
Γ; Φ 
 m : Model[id, temp, top_p]
⊢
Γ; Φ; Δ 
Requires declared Model and budget token bound:
(LLM-CALL)
 B'
▷
 eff(e)} 
∪
 call(tool,e) : Out ! {CallTool[name] 
⊢
Γ; Φ; Δ 
———————————————
B' = cost_model(tool, e)    // static upper bound
 needed_caps(e)      // capability check
⊇
caps 
 tool : Tool[name, caps]
⊢
Γ; Φ; Δ 
(TOOL-CALL)
Literals have ground types with empty effects and zero budget.
(CONST)
.
, then 
If 
(VAR)
32.3 Core typing & composition rules (selected)
 emit_vif(meta) obligation at boundaries
Emit:
 assertions g_spec, g_tests, g_trace, g_safety, producing Witness
Gate:
 p1 |> p2 (seq), p1 || p2 (parallel), route on pred { … }
Pipeline:
 step name : (In) -> (Out) when Gate using Tool with Budget
Step:
Key constructs:
 (tokens/sec upper bounds)
budget summary
: 
: latent effect row
: result type
: ACL term (pipeline, step, call…)
: capability context (linear multiset of tokens)
: refinement constraints (SMT-discharged)
: value environment (names → types)
We write judgments as:
32.2 ACL typing surfaces
S}
≤
 secs
∧
Claim{has_lineage}, Budget{tokens≤T 
Tokens{n ≥ 0}, Score{0 ≤ s ≤ 1}, Embedding[d]{norm≤1}
Any base/parametric type may be refined with guards:
32.1.7 Refinements (lightweight dependent predicates)
 rows.
joins
 effects; composition 
add
Row polymorphism allows steps to 
          | Time | Random | Abstain[κ] | Emit[VIF] }
          | Net[domain] | File[scope] | SEG[mode] 
 { ReadMem | WriteMem | CallLLM | CallTool[t] 
∪
    | ε 
ε ::= {} 
Effect rows describe latent side effects a step may perform:
32.1.6 Effects (kind ε)
 consumed or re-scoped at call sites.
linear tokens
: capabilities are 
No ambient authority
net[domain], fs[scope], exec[lang], llm[provider]
seg = seg_read | seg_write
mem = read_mem | write_mem
32.1.5 Capabilities (kind cap)
Tool[name, caps:cap] (e.g., caps = {net[domain], fs[scope], seg[mode]})
Model[id, temp:idx, top_p:idx]
Role = Planner | Retriever | Reasoner | Verifier | Builder | Critic | Operator | Witnesser
32.1.4 Roles & tools
Result[Ok, Err]
Budget (phantom-typed: Budget[tokens:idx, secs:idx])
Gate[T] (a check producing a Witness for T)
List[T], Option[T], Map[K,V], Stream[T]
32.1.3 Parametric data types
Graph (SEG slice), HL7, PDF, Parquet (domain wrappers)
Claim, Evidence, Witness, UQVec (all carry VIF metadata)
Atom, Molecule, Edge, SnapshotId
Embedding[d] (fixed dimension d)
Score (0..1), Tokens (int), Seconds (float), Energy (float)
Text, Bytes, JSON, YAML, UUID, Time, URL, Path
32.1.2 Base value types (*)
idx — budget indices (compile-time naturals / intervals)
ε — effect rows (latent side effects)
cap — capability kinds (authority to act)
* — value types (data)
32.1.1 Kinds
32.1 ACL kinds & types
, plus symbolic constraints discharged by SMT/SHACL/Datalog checkers.
capability tokens
 and 
budget indices
 system with 
type-and-effect
 a 
How we do it:
 (i) no missing inputs, (ii) no illegal capabilities, (iii) budgets won’t underflow, (iv) every boundary emits VIF + UQ, (v) optional information-flow safety, (vi) determinism flags when claimed.
What we prove:
 pipelines, steps, tools, models, gates, budgets, and evidence emissions.
What we type-check:
32.0 Overview
 before it runs. ACL’s type-and-effect discipline guarantees that plans are well-formed, budget-bounded, policy-lawful, and witness-producing by construction.
legible, checkable, and safe
Objective: make orchestration 
Chapter 32. Type Systems & Logic — ACL types & effects, symbolic checkers, soundness notes
Part XII — Mathematics & Formal Methods
.
implementable with predictable behavior
 
⇒
 bounds 
CFL-like
 (31.2.4–5) under 
Discrete stability
.
we converge to useful minima
 
⇒
 under PL/strict convexity in basin (31.2.3) 
Local optimality
.
fixed points are stationary
 
⇒
 (31.2.2) 
Critical-point convergence
.
no hidden energy sources
 
⇒
 with damping (31.2.1) 
Monotone energy
31.3.9 Guarantees we rely on (summary)
 switch to Velocity-Verlet.
Mitigation:
. 
 Explicit Euler with stiff 
Discrete drift.
.
, or relax/rest-length 
 increase damping, reduce 
Mitigation:
 Large projections each step. 
Constraint thrashing.
, enforce gain ratio, stronger repulsion.
 softening 
Mitigation:
 Gravity dominates at short range. 
Cluster collapse.
 R2 + R4.
Mitigation:
→ oscillations. 
or too large 
 Too small 
Mode coupling & chatter.
31.3.8 What can go wrong (and how we prevent it)
(estimated), adapt by Rule R4.
.
(heavier for high-priority atoms).
(rescale with embeddings).
(structural), 
, 
median inter-candidate distance.
median inter-candidate distance (embedding space).
31.3.7 Practical defaults (good starting priors)
 Adaptive step ties naturally to token/time budgets: when energy trends poorly, tighten step or early-stop with a VIF note.
Budget coupling.
 rather than silent failure.
abstention
 (guardrails) are respected, turning instability into 
forbidden crossings
 Projection ensures 
Policy-aware geometry.
 deterministic, low-variance re-ranking.
⇒
 on top-k candidates; no ringing 
semantic path/cluster
 a stable 
⇒
 Convergence 
DVNS retrieval.
31.3.6 Mapping to AIMOS/APOE behavior
 suggestions).
 and surface diagnostics (G/k/
abstain
for 3 consecutive steps, or projection residual > threshold, 
, 
If any of: 
Abstain on instability.
, and projection norm.
, 
Enforce barriers; track 
Run with adaptive step + projection.
per density; ensure gain ratio bound (above).
Choose 
Anti-collapse.
(critical-ish).
Set damping.
.
(start), clamp by 
.
Pick 
node degree.
, with 
Quick bound: 
Estimate curvature.
31.3.5 Composite stability map (operational)
.
and residual low, set 
; if 
(energy increased) or constraint residual grew, set 
If 
 to adapt:
energy trending
 Use 
Rule R4 (adaptive step).
.
 similar to VV provided projection residuals are bounded; if projections are large, reduce 
Projected VV:
).
(not recommended for stiff 
 requires very small 
Explicit Euler (position–velocity):
. Region widens with higher damping up to critical.
and 
 stability if 
Velocity-Verlet + damping:
31.3.4 Discrete stability charts (per integrator)
by 10–20% and restart the current micro-iteration (abstain if repeats).
or decrease 
, automatically increase 
; if 
 Monitor minimum distance 
Rule R3 (no-collapse margin).
This ensures gravity cannot overpower short-range stabilization.
:
and structural 
 with 
balanced
 Keep 
Gain ratio.
near expected minimum separation (e.g., HHNI layer spacing).
 Set 
).
Repulsion radius (
 weak clustering.
⇒
 singular pull; too large 
⇒
. Too small 
 Use 
).
Softening (
31.3.3 Anti-collapse & anti-crowding
(sum of adjacent spring curvatures + local Hessian contribution from gravity/repulsion).
is local effective stiffness seen by node 
where 
. Operationally,
 Target per-mode 
Rule R2 (critical-ish damping).
: monotone but slower.
 
Overdamped
: fastest non-oscillatory approach.
 
Critically damped
: oscillatory; fast but may ring.
 
Underdamped
.
, define 
For a scalar damped mode 
31.3.2 Damping regimes
(or upper bound via Gershgorin/diag dominance). Choose
 Measure/estimate 
Rule R1 (CFL bound).
 stability region.
increases
 
⇒
reduces curvature of the gravity kernel at short distances 
Softening 
.
reduce allowable 
 
⇒
(hard core) increase 
large 
(tight structure springs) and 
Large 
,
be the Hessian. Near any stable configuration 
Let 
31.3.1 Spectral stiffness & natural frequencies
.
fast settling
, and 
no oscillation
, 
no collapse
that guarantee 
We now chart parameter regimes 
31.3 Stability regions — parameter maps & operational rules
under the same step bounds.
and retain energy decay up to projection residuals. Standard projected heavy-ball analysis yields convergence to a KKT point of 
 to 
Fejér monotonicity
(policy geometry), we obtain 
onto convex feasible 
 
projection
and post-step 
With barriers 
Projected & constrained dynamics
to ensure practical decay and avoid ringing.
Pick
Corollary 31.2.5 (CFL-like step bound, multi-dimensional)
.
and 
 Reduce to scalar damped oscillator; use known VV stability chart. The global condition uses 
Sketch.
(proof via modified energy / backward error analysis).
 decays for sufficiently small 
discrete energy
Moreover, with damping, the 
 if
stable
, Velocity-Verlet is 
. For the decoupled mode with frequency 
, 
, and set 
, where 
Linearize around a strict local minimum 
Theorem 31.2.4 (Energy stability region, linearized)
:
Consider Velocity-Verlet with step 
Discrete-time convergence (Velocity-Verlet with damping)
 around desired configurations (clusters at rest-lengths, no overlaps), satisfying the PL condition locally.
gradient-dominated
 terms. In practice this yields a landscape that is (piecewise) 
convex repulsive/constraint
 plus 
attractive kernels with softening
 Our potentials are sums of 
Design note.
 Standard heavy-ball/gradient flow arguments: PL yields energy–gradient coupling; damping kills kinetic energy; LaSalle’s invariance principle finishes.
Sketch.
at least linearly in energy gap.
and 
Then the damped dynamics converge to 
:
 inequality in a neighborhood of the set of minimizers 
Polyak–Łojasiewicz (PL)
-smooth (Lipschitz gradient) and satisfies a 
is 
Assume 
Proposition 31.2.3 (Convergence to local minima under PL/gradient–dominance)
.
, energy would strictly decrease further, contradicting convergence of 
, then for small neighborhood the system experiences nonzero conservative force; with 
 If 
Sketch.
.
satisfies 
of 
-limit point 
Every 
Lemma 31.2.2 (Limit set is critical)
along some subsequence.
 
⇒
converges and 
 
⇒
 is bounded below by design via softening/barriers) 
is nonincreasing and bounded below (
 
Consequence.
and the equation of motion to cancel conservative work; damping contributes the negative term.
, use 
 Differentiate 
Sketch.
. Then
Define total energy 
Lemma 31.2.1 (Energy decay, continuous time)
 (no oscillatory failure). We then lift to the discrete setting with step-size bounds.
local minima
, and (c) with mild curvature conditions those points are 
 of 
converges to critical points
 under damping, (b) the flow 
energy decays
We establish that (a) 
31.2 Convergence — proof sketches
.
onto feasible set to respect policy geometry 
 after each update, project 
Projected step:
region; we use it only for analysis/fallback.
 simple but small 
Explicit Euler:
respects CFL bounds (below).
 stable for stiff springs if 
Symplectic/Velocity-Verlet (recommended):
 (used by DVNS/online re-ranking):
Discrete-time integrators
Continuous-time dynamics (second order with damping):
the viscous damping. Expanded pairwise terms (omitting indicators and barriers for brevity):
with 
Forces (negative gradient):
Softened gravity prevents singular collapse; hard-core repulsion prevents overlap; springs preserve HHNI/SEG geometry.
(e.g., large penalty near disallowed subspaces).
 sets (guardrails), enforced by convex barriers 
forbidden
: set of 
(e.g., hierarchy or typed dependency).
 edges we want to keep near rest-length 
structural
: set of 
Potential energy (pairwise + unary):
to avoid division by zero.
with a small 
, 
, 
Let 
 for dissipation.
viscous damping
 (soft constraints) terms; plus 
holding
 (collision & structure), and 
repulsive/elastic
 (semantic “gravity”), 
attractive
. Pairs interact through 
, and velocity 
, position 
(atom, tag, step, document, etc.) as a particle with mass 
We model each node 
31.1 GODN Potentials & Forces (recap + formalization)
Chapter 31. Dynamics
Part XII — Mathematics & Formal Methods
This addendum gives you the mathematically disciplined backbone you need to run GODN inside DVNS/HHNI confidently—stable, tunable, and auditable.
: hard perimeters for policy zones; minimum separation; softened gravity.
Safety
: “no-increase” policy; rollback on violation.
Events
for online DVNS.
: target 
Params
: energy descent, velocity cap, topology stability; κ-abstain on failure.
Gates
; consider Velocity-Verlet offline.
: start with semi-implicit Euler + adaptive 
Integrator
: implement conservative forces + damping; optional smooth variants.
Forces
Minimal checklist for implementation
), and add pre-step APOE gates to reject crossings.
, small 
 (large 
hard perimeters
 define forbidden sets as 
Policy breach risk:
 in calm regions; switch to Velocity-Verlet offline.
 mild ↑
Slow convergence:
).
 slightly or add/strengthen bonds (
 ↑
You see fragmentation:
modestly.
; if needed, raise 
; ↓
 ↑
You see oscillations:
.
; soften gravity near 
; clamp 
, ↓
, ↑
 ↑
You see collapse (cores):
31.4.5 Tuning playbook (actionable)
Super-index field building
adaptive (Verlet)
0.8–1.2
1–5
–
Offline precompute
Rapid structure discovery; watch oscillations
small–mid
0.6–0.9
0.5–2
–
Exploratory clustering
Safe DVNS refinement on top-k
small, adaptive
~1
1–3
–
Online navigation
Use
Mode
31.4.4 Default parameter packs (online vs. offline)
or softened parameter locally.
 energy policy; if violated, roll back one substep and re-attempt with smaller 
no-increase
 (perimeter/bond transitions) with a 
events
Handle 
) or softened gravity to avoid blow-ups.
(tiny 
 
minimum separation
Enforce 
with multiplicative factors (e.g., ×0.5 on close approach; ×1.1 when calm).
adaptive 
Use 
31.4.3 Numerical stability (time-step and events)
: very safe, may be slow; good for sensitive policy zones.
.
: faster but oscillatory; combine with adaptive 
: monotone settling (recommended online).
:
Damping 
: rigid lattices; risk of suboptimal traps.
: jitter; increase damping or barrier.
: elastic and steerable clusters (recommended).
:
Stiffness ratio 
, hard perimeters, and bond guidance. Use only for “galaxy” super-indexing or precompute, not online navigation.
Strong attraction; requires higher 
):
 (
Collapse-prone
 for forming stable retrieval paths without singular cores.
DVNS sweet spot
Soft clusters and emergent “lanes”. 
):
 (
Balanced clustering
or bonds to “thread” paths).
 and safe navigation (no collapses), but can fragment (add mild 
policy-aware retrieval
Repulsion dominates; nodes maintain spacing; good for 
):
 (
Dispersion region
31.4.2 Qualitative phase map
a typical mass.
from local curvature (barrier/bond) and 
with 
 (local second-order surrogate)
Damping ratio
→ rigid clusters (may trap).
→ fluid clusters (easy re-route), high 
Low 
Bond–barrier stiffness ratio
→ collapse risk.
→ barrier dominates (spread out); large 
Small 
Gravity–barrier ratio
(mass). Define:
(length), 
Choose scales 
31.4.1 Dimensionless groups (for portable tuning)
31.4 Stability regions — maps, regimes, and tuning playbook
With damping, noisy embeddings, or small stochastic kicks, systems typically leave saddles and settle into local minima.
slightly to regularize.
or 
 flat directions; increase 
:
Near-singular 
 saddle; small perturbations or stochasticity help escape.
:
Indefinite 
 strict local minimum (preferred).
:
Positive-definite 
determines local type:
. The Hessian 
At a fixed event pattern (no switching), equilibria satisfy 
31.3.3 Local optimality and saddles
).
, ↑
, ↑
) and re-run with safer parameters (↓
 (
abstain
iterations, 
If not satisfied by 
 Stop when
Stopping gates (deterministic APOE-compatible).
is near a barrier or (ii) a bond event is imminent.
downwards when (i) any 
adapt 
a characteristic mass. In practice, we 
is a characteristic length and 
where 
satisfies
. A stable 
 Let 
Step-size bound (rule-of-thumb).
 is second-order and near-symplectic. With linear damping (handled via splitting or exponential integrators), it exhibits smaller long-term drift. Use it in offline precompute or when energy fidelity matters.
Velocity-Verlet
events are handled by “no-increase” policies.
damping is non-zero,
satisfies a CFL-like bound w.r.t. local stiffness (below),
 holds if:
practical descent
. In our mixed potentials, 
and 
For a quadratic well, this scheme is energy-stable for sufficiently small 
Semi-implicit (symplectic) Euler
be the step.
Let 
31.3.2 Discrete-time integration (semi-implicit Euler / Velocity-Verlet)
and a “no-increase” event policy, the continuous system converges to a closed set of equilibria; generically, to a local minimum (modulo plateaus/saddles).
 With 
Conclusion (sketch).
remains non-increasing.
(e.g., snapping to the nearest feasible manifold), 
 that do not increase 
projections
If bonds/perimeters enforce 
remains non-increasing.
 energy (or under a “no-increase” policy), 
reduces
If bonds are activated only when it 
 depending on how the event function is implemented:
down
 or 
up
 (switched) dynamical system with discrete “events” (enter/exit perimeter, bond on/off). Between events, the Lyapunov argument holds. At an event, energy may jump 
hybrid
 The system is a 
With piecewise barriers/bonds.
(soft variants above), the same Lyapunov argument holds globally.
 If the potentials are 
With smooth barriers/bonds.
.
, i.e., a (possibly local) equilibrium of 
and 
is non-increasing, bounded below (by construction), and thus converges. By LaSalle’s invariance principle, the trajectories approach the largest invariant set where 
Hence 
. Then
 Consider 
Lyapunov descent.
), the dynamics are
(
. With damping 
Define the conservative force 
31.3.1 Continuous-time gradient–damped system
31.3 Convergence proof sketches (continuous & discrete; with events)
. In practice, we often adopt the Euclidean proxy for speed and simplicity, reserving angular corrections for offline precomputation.
with 
, the force in the tangent space is:
as “distance”. For a potential 
 Use 
Angular metric.
defined in the ambient space.
. Forces as above with 
normalized, distance 
with 
 Work in 
Euclidean proxy.
. Two pragmatic constructions:
In DVNS retrieval, positions come from normalized embeddings 
31.2.4 Embedding-space forces for DVNS/HHNI
These smoothings preserve intent (attraction/repulsion/holding) while improving gradient stability.
to avoid stiff snaps when bonds appear/disappear.
Multiply the bond term by a smooth gate 
Bond windowing:
.
), limiting forces at very small 
(small 
with 
Replace 
Softened gravity (Plummer-like):
.
with 
Then 
.
. Define 
Let 
Soft barrier (softplus-squared):
or embedding–force co-training), prefer a smooth approximation:
. For differentiable pipelines (e.g., learning 
The piecewise barrier can introduce kinks at 
31.2.3 Smooth, differentiable alternatives (for robust autodiff)
Equations of motion (continuous time).
.
Net force: 
.
Damping: 
):
(equal and opposite on 
Conservative pair forces are 
with components
Total energy
31.2.2 Potentials and canonical forces (piecewise)
: linear (Rayleigh) damping.
: bond equilibrium distance.
: perimeter distance (minimum comfortable separation).
(the “holding set”).
: bond stiffness for pairs in 
: barrier/perimeter stiffness (short-range repulsion).
: gravity strength.
:
Parameter set 
).
(for 
, 
Pair geometry: 
.
, mass 
, velocity 
with position 
Nodes 
31.2.1 State and notation
31.2 Forces — full specification & implementation notes
. It refines and extends the earlier high-level write-up with tighter definitions, optional smoothings, and explicit conditions you can implement and test.
31.4 Stability Regions
, and 
31.3 Convergence Proof Sketches
, 
31.2 Forces
Below is a deep, self-contained expansion of the three items you asked for: 
Chapter 31. Dynamics (Focused Addendum)
Part XII — Mathematics & Formal Methods
Graviton Organic Dynamic Network
, adaptive time/mass, and policy-aware perimeters, AIMOS/APOE can run DVNS at scale while remaining verifiable and safe. 
 GODN’s simple potential—gravity + elastic perimeter + holding—combined with damping and careful integration yields a robust, tunable engine for emergent organization. With the stability map 
Takeaway.
 inside SEG.
replayable
 and 
witnessable
, gate outcomes, κ events, and the mapping from nodes to artifacts (snapshot ids). This makes each emergent configuration 
, integrator, neighbor/cutoff scheme, seeds, energy trace 
Per run: 
31.12 What to log (for VIF/SEG)
Graviton Organic Dynamic Network
 super-dense knowledge regions act as high-mass attractors; arms form along semantic manifolds; dynamic focus zooms dense cores. 
Galaxy-like super-indexing:
Graviton Organic Dynamic Network
springs; adaptive mass highlights catalytic residues. 
 hydrophobic cores via gravity, steric clash avoided by perimeters, secondary-structure bonds as 
Protein-like folding:
Graviton Organic Dynamic Network
 gravity pulls semantically close cities into clusters; barrier keeps tour from self-intersecting; bonds stitch cluster frontiers; damping yields a clean loop. (Doc’s TSP example.) 
TSP-like retrieval:
31.11 Worked intuitions (three canonical tasks)
until gates pass or κ-abstain
  // check convergence gates (ΔE, max|v|, topology stable)
  if (close-approach or bond event) reduce Δt; else maybe increase
  // adaptive dt & event handling
  x_i += v_i * Δt
  v_i += (F_i / m_i) * Δt
  // integrate (symplectic Euler)
  for far clusters: add Barnes–Hut gravity contributions
      F_j -= (same)
      F_i += F_grav(i,j) + F_rep(i,j) + F_hold(i,j)
  for pairs (i,j) in near-list:
  for i: F_i = -c_d * v_i
  // neighbor discovery (short-range) and far-field approx (gravity)
repeat
given nodes {x_i, v_i, m_i}, parameters (G, k_b, k_h, d_p, d_c, c_d), bonds B
31.10 Algorithm sketch (discrete iteration)
 and that APOE gates check crossings before commit.
hard perimeters
 ensure forbidden regions have 
Policy breach risk:
, neighbor cutoffs, reorder force eval.
 poor step control near contacts → adaptive 
Stall (no convergence):
.
/
or raise 
too weak → lower 
 barriers too strong or 
Fragmentation (no paths):
, switch to symplectic Euler.
, reduce 
→ increase 
with large 
 
Oscillation/limit cycles:
.
, clamp min 
, increase 
too small → raise 
too large or 
 
Collapse (core singularity):
31.9 Failure modes & mitigations
when running with strong gravity or noisy embeddings.
and 
Tighten 
Use Velocity-Verlet, adaptive dt
adaptive
mid-high
medium
small
mid
high
mid
Precompute
Faster clustering, may oscillate
small-mid
mid
large
small
low
mid
mid-high
Exploration
Stable, monotone; policy-safe
small
high
medium
small
mid
high
mid
Online refine
Notes
Mode
31.8 Default parameter packs (online vs. offline)
Graviton Organic Dynamic Network
for stale nodes (the doc’s “mass adjustment”). 
(from CMC/HHNI). Use decay 
 Let 
Adaptive masses.
buffer around restricted sets; DVNS will not cross them (forces push trajectories away).
and small 
: set a high 
hard perimeters
 Mark forbidden regions (privacy, license) as 
Policy-aware geometry.
, normalize, treat distances as Euclidean locally.
(the geodesic gradient direction). Practical simplification: embed to 
). Forces then act along 
(or 
be normalized embedding vectors. Use angular distance 
 Let 
Positions from embeddings.
31.7 Mapping to DVNS/HHNI retrieval
Graviton Organic Dynamic Network
These preserve the emergent behavior while scaling to large HHNI/DVNS corpora. (The GODN doc emphasizes scalability via localized computations.) 
 in 2D/3D TSP-like tasks for near-field search.
Uniform grids
).
 for gravity (approximate far-field, 
Barnes–Hut / FMM
 for repulsion/holding (short-range).
Cutoffs & neighbor lists
. Use:
Naïve pairwise forces are 
31.6 Fast force evaluation (scaling)
Graviton Organic Dynamic Network
Pick tighter step if close approaches are frequent (TSP cluster stitching, protein contacts). These prescriptions follow the reference’s “stability and scalability” and “dynamic parameter” guidance. 
Discrete-time CFL-like bound (rule of thumb).
: slow but safest near constraints.
: robust, monotone settling; recommended for online.
: faster convergence but overshoot/oscillation risk.
.
Local second-order modes exhibit under/critical/over-damped behavior governed by 
Damping ratio (oscillation control).
: rigid lattices; can trap in suboptimal shapes.
High 
(0.5–5): elastic but stable clusters; recommended.
Mid 
: fluid clusters, easier path re-routing, risk of jitter.
Low 
.
Rigidity vs. fluidity (bond vs. barrier).
bonds.
and nonzero 
→ dense cores; only safe with strong 
 
Collapse-prone:
 → soft clusters, emergent paths without singular collapse (DVNS sweet spot).
–
 
Balanced clustering:
 (no cluster collapse).
policy-aware retrieval
→ repulsion dominates, nodes maintain spacing; good for 
 
Dispersion region:
.
Define 
Collapse vs. dispersion (gravity vs. barrier).
We characterize qualitative regimes by three axes:
31.5 Stability regions & parameter regimes
).
, or raise 
, increase 
and route to a safer parameter regime (reduce 
iterations, emit 
 if energy fails to descend or oscillates beyond 
Abstention trigger (κ):
steps).
topology stable (no bond/perimeter events over 
and
, 
max speed 
and
consecutive steps, 
for 
Stopping conditions (APOE gate compatible).
Graviton Organic Dynamic Network
jitter). (Consistent with the doc’s energy-minimization loop.) 
except for 
is small enough (CFL-like bound below), the numerical scheme preserves practical descent (non-increasing 
is a Lyapunov function and decreases monotonically to a (possibly local) minimum. In discrete time, if 
Thus 
, continuous-time dynamics satisfy
and 
 For fixed 
Energy descent with damping.
31.4 Convergence sketches (with damping and gates)
by local Lipschitz estimate of forces; switch to Velocity-Verlet in offline precompute of super-index fields.
 begin with symplectic Euler, clamp 
Guideline:
Graviton Organic Dynamic Network
small (near equilibrium), increase step (fast-forward); near high-curvature events (close approaches, bond snaps), decrease step. (Matches GODN’s time scaling guidance.) 
If 
Adaptive time-step.
Pros: second-order, near-symplectic; use when energy fidelity matters (e.g., precomputation/offline).
Velocity-Verlet.
Pros: simple, stable for stiff contact-like terms, modest energy drift. Good default for online DVNS refinement.
Symplectic Euler (semi-implicit).
31.3 Integrators (energy behavior & recommendations)
Graviton Organic Dynamic Network
. (As summarized in the GODN framework.) 
. Dynamics: 
Net force: 
:
For each pair 
31.2 Forces and equations of motion
(effective local second-order behavior).
 
Damping ratio
(cluster rigidity).
 
Bond–barrier stiffness ratio
(collapse tendency).
 
Gravity–elastic ratio
. Natural dimensionless groups:
, 
, 
. Define 
, mass scale 
, time scale 
 choose a length scale 
Non-dimensionalization (for tuning):
.
 Linear velocity damping with coefficient 
Damping (Rayleigh).
Graviton Organic Dynamic Network
. (Matches the reference’s gravity, elastic perimeter, holding terms.) 
, bond set 
, bond equilibrium 
, perimeter distance 
, bond stiffness 
, barrier stiffness 
Parameters: gravitational constant 
with
Total energy.
.
, unit vector 
. Distances 
, mass 
, velocity 
 position 
):
i
State variables (per node 
31.1 State, potentials, and units
Graviton Organic Dynamic Network
 This chapter specifies the continuous and discrete-time dynamics used by the Graviton Organic Dynamics Network (GODN): the potential energy model, force laws, integrators, convergence conditions, stability regions, and practical parameter regimes. These definitions are aligned with the GODN reference you provided and are specialized here for AIMOS/APOE (DVNS/HHNI) retrieval and orchestration. 
Scope.
Chapter 31. Dynamics — GODN potentials & forces, convergence sketches, stability regions
Part XII — Mathematics & Formal Methods
 with auditable UQ for κ-gating—foundational for APOE routing and for satisfying the Witness/Audit invariants.
probabilistic, calibrated interface
 This chapter fixes the retrieval scoring semantics (RS), ties them to HHNI structure (IDS) and safety (DD), and delivers a 
Outcome.
per hit; SEG/VIF embeds the parameters.
: /query/vector returns 
Read path
 used at read time.
calibration model id
components and the 
 (Ch.28): /atoms must store 
Write path
30.8 Interface contracts (summary)
, accept; else abstain/seek more context.
If 
.
bits; ensemble var 
Entropy 
.
Calibrator (Platt): 
.
(minor drift, no conflict).
.
 
⇒
with 
.
 
⇒
Time decay 
.
.
: 
Suppose for candidate 
30.7 Worked micro-example
variance when available.
: 3 seeds or 2 model families for 
Ensembles
 labels/slice), else Platt; re-fit weekly or on ECE breach.
: isotonic where enough data (
Calibration
: start 0.65; tune to keep abstention rate 5–15% with high utility.
κ
.
; hard contradictions set 
: 
DD
.
to 
; clip 
: 
IDS
(adjust by domain).
: 
Weights
30.6 Implementation notes (defaults)
Reliability curves per slice; κ threshold overlays; drift alerts.
with model/calibrator ids, data slice, and snapshot id.
Log 
Observability (to SEG/VIF)
Top-k rerank with cross-encoder ≤ 60 ms @ p95 (optional).
RS+calibration overhead ≤ 5 ms @ p95 (pre-computed features).
Latency/Cost
≤ 2%.
Conflict usage: fraction of selected items with 
κ-abstentions: ≥ 70% precision when abstaining (i.e., abstentions correlate with true ambiguity).
Safety
Brier ≤ baseline-5%.
Global ECE ≤ 0.04; worst-slice ECE ≤ 0.06.
Calibration
RS-lift in offline recall@k ≥ +8% on HHNI-deep queries.
AUC/PR on relevance ≥ baseline +3–5%.
Correctness
30.5 Acceptance criteria & dashboards
by bandit on downstream success (A/B across traffic shards).
Update 
 refit calibrators.
⇒
windows 
Track slice ECE; if > threshold for 
30.4.4 Online adaptation (drift)
.
subject to diversity & policy filters; penalize high 
 by 
Else select top-
 abstain/seek clarification.
⇒
If 
30.4.3 κ-gating & selection
.
and UQ vector 
Emit 
Periodically refit on labeled interactions (click/accept, HITL outcomes).
(Platt or isotonic).
Maintain per-slice calibrators 
30.4.2 Calibrate to 
per candidate (features precomputed in ingestion).
: 
Complexity
.
 to 
Clip
.
 
Product
via §30.1.
 
Compose
.
 features to 
Normalize
.
: 
Features
for a candidate
30.4.1 Compute 
30.4 Algorithms (reference)
.
or 
Gate if 
 for safety gates:
Min-confidence heuristic
 aggregation (approximate):
Law of total variance
with pairwise dependence small:
For a chain using items 
30.3.3 Chain-level UQ (APOE)
 control of false accepts under exchangeability.
finite-sample
This yields 
.
 marginal coverage 
⇒
At inference, accept if 
.
of 
, pick quantile 
On calibration set 
.
Define nonconformity 
Split-conformal for retrieval thresholds:
30.3.2 Conformal coverage (optional guarantees)
and a scalar risk index:
 
UQ vector
Combine into a 
.
: stddev across 
Temperature sweep stability
.
,
: multiple models or seeds 
Ensemble variance
.
: 
Predictive entropy
30.3.1 Pointwise uncertainty
 (model ignorance).
epistemic
 (inherent ambiguity) and 
aleatoric
We quantify 
30.3 Uncertainty theory (UQ) for retrieval & chains
: ECE ≤ 0.04 on primary slices; Brier ≤ baseline-5%.
Acceptance
 Expected Calibration Error (ECE), Brier score, reliability curves.
Calibration metrics:
, fitted on a dev set.
: 
For cross-encoder logits 
d) Temperature scaling (for classifier logits):
 models (per modality/domain) to avoid leakage and improve fairness.
slice-aware
Use 
c) Multi-feature calibration:
. Better when score–probability relation is non-linear.
s.t. 
Monotone stepwise function 
b) Isotonic regression (non-parametric):
on validation data minimizing log-loss; optionally L2-penalize.
Fit 
a) Platt / Logistic calibration (binary):
.
with held-out labels 
(or a feature vector) to 
Map 
30.2.2 Probability calibration
.
before composing 
into 
We normalize 
.
 for stability: 
Affine clip
.
: 
 to 
Quantile map
.
 (modality/tenant/time):
Z-score within slice
Bring heterogenous components to a comparable scale before product:
30.2.1 Score normalization
 usable for κ-gating and budgets.
well-calibrated probabilities
We must convert raw scores to 
30.2 Normalization & calibration
 the dependency risk is high.
unless
: high quality + deep index 
Interpretation
.
;
;
: 
Sensitivity
.
 
⇒
terms 
: product of three 
Bounds
:
bounded
 and 
Compositional
30.1.4 Retrieval score 
increases with conflicts and drift.
: 
Monotonicity
is unusable without quarantine/HITL.
is perfectly safe; 
sharply (binary bump).
Hard contradictions raise 
: change in key tag vectors vs. last accepted snapshot.
: neighboring edges/nodes (dependencies) in SEG/HHNI.
 existing commitments:
breaks or contradicts
Risk that using 
30.1.3 Dependency-delta 
: Deep, well-connected, and consistent items score higher.
Intuition
.
via 
. Output is in 
: inconsistency penalty (dangling hashes, orphan edges).
: share of the relevant section hierarchy with valid links.
: local connection density quality (weighted by tag precision, not raw degree).
.
: number of resolvable sub-indices (system→…→sub-word) beneath/around 
 the content is positioned in HHNI:
how deeply and cleanly
Measures 
30.1.2 Indexing-depth score 
.
; non-increasing in 
, 
, 
increases with 
: 
Monotonicity
.
to 
. Clip 
, 
: normalized similarity (e.g., cosine of query/atom embeddings, reranked by cross-encoder if available).
).
: inverse breadth (e.g., 
(from intent graph).
: fraction of query intents covered by 
, with temporal hygiene:
semantic alignment
, and 
specificity
, 
completeness
Decomposed into 
30.1.1 Quality score 
30.1 RS/QS/IDS/DD — definitions & bounds
: min/max clamp.
: logistic; 
are positive weights.
: time constant for decay; 
.
: abstention threshold; abstain when 
.
: calibrated probability 
.
: retrieval score for 
.
: dependency-delta risk incurred by using 
in HHNI.
: indexing-depth score for 
.
relative to 
: quality score for 
is the query/task context.
indexes a candidate memory atom/molecule; 
30.0 Notation (recap)
Aim. Specify the retrieval scoring family used by AIMOS/APOE; prove its monotonicity/bounds; define normalization and calibration to map scores to probabilities; and formalize uncertainty quantification (UQ) for gating (κ) and orchestration budgets.
Chapter 30. Retrieval Math — RS/QS/IDS/DD definitions, normalization, calibration, and UQ theory
Part XII — Mathematics & Formal Methods
Log correlation_id on errors.
Capture X-Budget-* headers.
Observability
Token rotation hooks present.
PII pre-redaction before ingest.
No secrets in logs.
Security
If-Match on PATCH (when used), handle 412.
Idempotency keys on POST.
Retries on 429/503/504 + retryable=true.
Reliability
User agent string identifies your app.
Per-service timeouts set (connect/read).
AIMOS_BASE_URL, AIMOS_TENANT, AIMOS_TOKEN configured.
Initialization
29.9 Client checklists
 Expose booleans for optional endpoints (e.g., SSE witness) with graceful degradation.
Feature flags.
 SDKs carry generated types from the published OpenAPI (see Ch.28.10). Minor server changes are additive; breaking changes bump v2 base URL and @aimos/sdk@2.x.
API drift management.
 (@aimos/sdk, aimos-sdk).
Semver packages
29.8 Versioning & compatibility
                     _from='2025-10-10T00:00:00Z', to='2025-10-17T00:00:00Z')
bundle, _ = http.get('/audit/seg/lineage', claim_id='seg:claim:release_rc_0_3',
Lineage export for a claim (Py):
await memory.closeSnapshot('batch 17');
await Promise.all(payloads.map(p => memory.createAtom(p)));
Idempotent batch ingest (TS):
latest = http.get('/atoms', as_of='2025-10-17T00:00:00Z')[0]
Time-slice read (Py):
});
  vector: myVec, filters: { modality: 'code:ts', 'tag.repo': 'checkout' }
  model_id: 'embed-004', k: 25,
await memory.vectorQuery({
Vector search within a modality (TS):
29.7 Cookbook (common tasks)
 For large content_ref.uri artifacts, prefer object storage + content_ref.uri rather than inlining.
Chunked uploads.
 Default pattern uses polling (see 29.1.5/29.2.4). If SSE/WebSocket is enabled by the server, expose runs.subscribe(runId, onEvent) helper that falls back to polling.
Witness “tail”.
29.6 Streaming & large artifacts
 Surface returned vif on all write responses; provide helpers to attach VIF to downstream artifacts.
Provenance.
 Optional constructor override for HTTP layer with client certs.
mTLS.
 Pre-flight local redaction before POST /atoms; respect server FAILED_PRECONDITION policy_violation=true.
PII redaction.
 Allow injection (rotating tokens, STS). Never log tokens; scrub on exceptions.
Token providers.
29.5 Security & compliance hooks
: capture and expose X-Budget-Tokens-Used, etc., for observability tests.
Budget headers
: seed any randomness (e.g., UUID strategy for e2e tests use fixed keys) when validating idempotency caching.
Determinism
: use responses or pytest-httpserver; simulate 503→503→200 sequences; assert backoff timing within tolerance.
Python
: use nock to mock endpoints; assert retry behavior on 429 bursts; verify Idempotency-Key present for POSTs.
JS/TS
29.4 Testing, mocks, and resilience
program.parse();
  });
    for await (const f of orch.tail(runId)) console.log(JSON.stringify(f, null, 2));
    const orch = new OrchestrationClient(new AimosHTTP());
  .action(async (runId) => {
  .argument('<runId>')
program.command('runs:tail')
  });
    console.log(JSON.stringify(run, null, 2));
    const run = await orch.startRun({ pipeline_id: o.pipeline, inputs, snapshot_id: o.snapshot });
    const inputs = Object.fromEntries(String(o.inputs || '').split(',').filter(Boolean).map(pair => pair.split('=')));
    const http = new AimosHTTP(); const orch = new OrchestrationClient(http);
  .action(async (o) => {
  .option('--inputs <k=v...>')
  .requiredOption('--snapshot <sid>')
  .requiredOption('--pipeline <id>')
program.command('runs:start')
  });
    console.log(JSON.stringify(res, null, 2));
    const res = await mem.closeSnapshot(o.notes);
    const http = new AimosHTTP(); const mem = new MemoryClient(http);
  .action(async (o) => {
  .option('--notes <n>')
program.command('snapshots:close')
  });
    console.log(JSON.stringify({ id: atom.id, snapshotId }, null, 2));
    } as any);
      tags
      content_ref: { inline: opts.text, media_type: 'text/plain' },
      modality: opts.modality,
    const { atom, snapshotId } = await mem.createAtom({
    const tags = opts.tag ? [{ key: opts.tag.split(':')[0], value: opts.tag.split(':')[1], weight: 0.9 }] : [];
    const http = new AimosHTTP(); const mem = new MemoryClient(http);
  .action(async (opts) => {
  .option('--tag <k:v>')
  .option('--text <t>')
  .requiredOption('--modality <m>')
program.command('atoms:create')
program.name('aimos').description('AIMOS/APOE CLI').version('1.0.0');
const program = new Command();
import { OrchestrationClient } from '@aimos/sdk/orch';
import { MemoryClient } from '@aimos/sdk/memory';
import { AimosHTTP } from '@aimos/sdk/http';
import { Command } from 'commander';
#!/usr/bin/env node
29.3.3 Implementation sketch
aimos audit:lineage --claim seg:claim:release_rc_0_3 --from 2025-10-10 --to 2025-10-17
aimos runs:tail RUN_ID
aimos runs:start --pipeline pipe:payments_weekly_report --inputs lookback_days=7 --snapshot S_ABC123
aimos snapshots:close --notes "ingest batch 42"
aimos atoms:create --modality prompt:user --text "..." --tag topic:payments
29.3.2 Commands
aimos --help
npm i -g @aimos/cli
29.3.1 Install & entrypoint
29.3 CLI (Node/TS example)
print('steps', len(trace.get('steps', [])))
trace = orch.get_trace(run_id)
# 5) Trace
    print('status', frame['status'], 'budget', frame.get('budget'))
for frame in orch.tail(run_id):
# 4) Tail
run_id = run['run_id']
})
  "snapshot_id": snap
  "inputs":{"lookback_days":7},
  "pipeline_id":"pipe:payments_weekly_report",
run = orch.start_run({
# 3) Start pipeline run
mem.close_snapshot('ingest batch 42')
# 2) Close snapshot
print('atom', atom.id, 'snap', snap)
atom, snap, _ = mem.create_atom(payload)
}
  "tpv": { "priority":0.8, "relevance":0.87, "decay_tau":604800 }
  "hhni": { "path":["system:aiops","section:queries","sentence:12"] },
  "tags":[{"key":"topic","value":"payments","weight":0.9}],
  "embedding": { "model_id":"embed-004", "dim":768, "vector":[0.0]*768 },
  "content_ref": { "inline":"Summarize failed transfers by tip type last week.", "media_type":"text/plain" },
  "modality":"prompt:user",
payload = {
# 1) Create atom
orch = OrchestrationClient(http)
mem = MemoryClient(http)
http = AimosHTTP()
from aimos_sdk.orch import OrchestrationClient
from aimos_sdk.memory import MemoryClient
from aimos_sdk.http import AimosHTTP
29.2.4 End-to-end example (Python)
            time.sleep(interval_sec)
                break
            if frame['status'] in ['succeeded','failed','abstained','quarantined','rolled_back','cancelled']:
            yield frame
            frame = self.get_run(run_id)
        while True:
        import time
    def tail(self, run_id: str, interval_sec=1.2):
        return self.http.get(f'/acl/runs/{run_id}/trace')[0]
    def get_trace(self, run_id: str):
        return self.http.get(f'/acl/runs/{run_id}')[0]
    def get_run(self, run_id: str):
        return self.http.post('/acl/runs', body, idempotency=True)[0]
    def start_run(self, body: dict):
    def __init__(self, http: AimosHTTP): self.http = http
class OrchestrationClient:
# aimos_sdk/orch.py
        return self.http.post('/snapshots', { 'action':'close', 'notes': notes }, idempotency=True)[0]
    def close_snapshot(self, notes: str = None):
            if not cursor: break
            cursor = data.get('next_cursor')
                yield Atom(**item)
            for item in data.get('items', []):
            data, _ = self.http.get('/atoms', **params)
            params = { 'tag':tag, 'modality':modality, 'limit':limit, 'cursor':cursor, 'as_of':as_of }
        while True:
        cursor = None
    def list_atoms(self, *, tag=None, modality=None, limit=200, as_of=None) -> Iterator[Atom]:
        return Atom(**data), headers.get('X-Snapshot-Id'), headers.get('ETag')
        data, headers = self.http.post('/atoms', payload, idempotency=True)
    def create_atom(self, payload: dict):
    def __init__(self, http: AimosHTTP): self.http = http
class MemoryClient:
from typing import Iterator
from .types import Atom
from .http import AimosHTTP
# aimos_sdk/memory.py
    vif: VIF
    created_at: str
    snapshot_id: str
    tpv: Optional[Dict] = None
    hhni: Optional[Dict] = None
    tags: Optional[List[Dict]] = None
    embedding: Optional[Dict] = None
    content_ref: Dict[str, str]
    modality: str
    id: str
class Atom(BaseModel):
    writer: str
    tool_ids: Optional[List[str]] = None
    prompt_template_id: Optional[str] = None
    weights_hash: str
    model_id: str
class VIF(BaseModel):
from typing import List, Optional, Dict
from pydantic import BaseModel
# aimos_sdk/types.py
29.2.3 Models & iterators
            self.session.headers = h
        finally:
            return self.request('PATCH', p, json_body=body)
        try:
        if etag: self.session.headers['If-Match'] = etag
        h = self.session.headers.copy()
    def patch(self, p, body=None, etag=None):
    def post(self, p, body=None, idempotency=False): return self.request('POST', p, json_body=body, idempotency=idempotency)
    def get(self, p, **q):   return self.request('GET', p, params={k:v for k,v in q.items() if v is not None})
            )
                err.get('details')
                err.get('correlation_id', headers['X-Request-Id']),
                res.status_code,
                err.get('code', 'HTTP_ERROR'),
                err.get('message', f'HTTP {res.status_code}'),
            raise AimosError(
            err = body.get('error', {})
                time.sleep(backoff); continue
                backoff = min(1.0 * 2**attempt, 8.0) + random.uniform(0,0.25)
                attempt += 1
            if retryable and attempt < 5:
            retryable = res.status_code in (429, 503, 504) or (body.get('error',{}).get('retryable'))
                return body, res.headers
            if res.ok:
            body = res.json() if 'json' in content_type and res.text else {'raw': res.text}
            content_type = res.headers.get('Content-Type','')
            res = self.session.request(method, url, params=params, json=json_body, headers=headers, timeout=self.timeout)
        while True:
        attempt = 0
            headers['Idempotency-Key'] = str(uuid.uuid4())
        if idempotency:
        headers = {'X-Request-Id': str(uuid.uuid4())}
        url = f'{self.base}{path}'
    def request(self, method: str, path: str, *, params=None, json_body=None, idempotency=False):
        })
            'Content-Type': 'application/json'
            'User-Agent': user_agent,
            'X-Tenant': self.tenant,
            'Authorization': f'Bearer {self.token}',
        self.session.headers.update({
        self.session = requests.Session()
        self.timeout = timeout
        self.tenant = tenant or os.environ['AIMOS_TENANT']
        self.token = token or os.environ['AIMOS_TOKEN']
        self.base = base or os.environ['AIMOS_BASE_URL']
    def __init__(self, base=None, token=None, tenant=None, user_agent='aimos-py/1.0.0', timeout=30):
class AimosHTTP:
    details: t.Optional[dict] = None
    correlation_id: str
    status: int
    code: str
    message: str
class AimosError(Exception):
@dataclass
from dataclasses import dataclass
import requests
import os, time, uuid, json, random, typing as t
# aimos_sdk/http.py
29.2.2 Core HTTP with backoff & rich errors
  paginators.py
  audit.py
  orch.py
  memory.py
  types.py       # pydantic models
  http.py        # session, retries, auth, idempotency
aimos_sdk/
pip install aimos-sdk
29.2.1 Install & layout
29.2 Python SDK
})();
  console.log('trace steps:', trace.data.steps.length);
  const trace = await orch.getTrace(runId);
  // 5) Fetch witness trace
  }
    console.log('status:', frame.status, 'budget:', frame.budget);
  for await (const frame of orch.tail(runId)) {
  // 4) Tail status
  const runId = run.data.run_id;
  });
    snapshot_id: snapshotId!
    inputs: { lookback_days: 7 },
    pipeline_id: 'pipe:payments_weekly_report',
  const run = await orch.startRun({
  // 3) Start a run
  await memory.closeSnapshot('ingest batch 42');
  // 2) Close snapshot
  console.log('Atom', atom.id, 'snapshot', snapshotId);
  });
    tpv: { priority: 0.8, relevance: 0.87, decay_tau: 604800 }
    hhni: { path: ['system:aiops','section:queries','sentence:12'] },
    tags: [{ key:'topic', value:'payments', weight:0.9 }],
    embedding: { model_id: 'embed-004', dim: 768, vector: new Array(768).fill(0) },
    content_ref: { inline: 'Summarize failed transfers by tip type last week.', media_type: 'text/plain' },
    modality: 'prompt:user',
  const { atom, snapshotId } = await memory.createAtom({
  // 1) Create an atom (semantic prompt), idempotent
(async () => {
const orch = new OrchestrationClient(http);
const memory = new MemoryClient(http);
const http = new AimosHTTP();
import { OrchestrationClient } from './orch';
import { MemoryClient } from './memory';
import { AimosHTTP } from './http';
29.1.6 End-to-end example (TS)
}
  }
    } while (true);
      await new Promise(r => setTimeout(r, intervalMs));
      if (['succeeded','failed','abstained','quarantined','rolled_back','cancelled'].includes(status)) break;
      yield data;
      status = data.status;
      const { data } = await this.getRun(runId);
    do {
    let status: string | undefined;
  async *tail(runId: string, intervalMs = 1200) {
  /* polling helper */
  }
    return this.http.get<{ steps: unknown[]; gates: unknown[]; artifacts: unknown[] }>(`/acl/runs/${runId}/trace`);
  getTrace(runId: string) {
  }
    return this.http.get<{ run_id: string; status: string; budget: Record<string,number> }>(`/acl/runs/${runId}`);
  getRun(runId: string) {
  }
    return this.http.post<{ run_id: string; status: string; started_at: string }>('/acl/runs', input, true);
  }) {
    snapshot_id: string; budgets_override?: Record<string,number>; policies?: { hitl_required?: boolean }
    pipeline_id: string; inputs: Record<string,unknown>;
  startRun(input: {
  constructor(private http: AimosHTTP) {}
export class OrchestrationClient {
// src/orch.ts
29.1.5 Orchestration & witness trace
}
  }
    return data;
    const { data } = await this.http.post('/snapshots', { action: 'close', notes }, true);
  async closeSnapshot(notes?: string) {
  }
    return data.results;
    const { data } = await this.http.post<VectorQueryRes>('/query/vector', req);
  async vectorQuery(req: VectorQueryReq) {
  }
    } while (cursor);
      cursor = data.next_cursor;
      for (const a of data.items) yield a;
      const { data } = await this.http.get<{ items: Atom[]; next_cursor?: string }>('/atoms', { ...params, cursor });
    do {
    let cursor: string | undefined;
  async *listAtoms(params: { tag?: string; modality?: string; limit?: number; as_of?: string } = {}) {
  }
    return { atom: data, snapshotId: headers.get('X-Snapshot-Id')!, etag: headers.get('ETag') };
    const { data, headers } = await this.http.post<Atom>('/atoms', input, true);
  async createAtom(input: Omit<Atom, 'id'|'snapshot_id'|'created_at'|'vif'>) {
  constructor(private http: AimosHTTP) {}
export class MemoryClient {
import { Atom, VectorQueryReq, VectorQueryRes } from './types';
import { AimosHTTP } from './http';
// src/memory.ts
29.1.4 Memory client, paginators, and budgets
export type VectorQueryRes = { results: { id: string; score: number }[] };
};
  filters?: Record<string,string>;
  model_id: string; k: number; vector: number[];
export type VectorQueryReq = {
};
  tool_ids?: string[]; writer: string;
  prompt_template_id?: string;
  model_id: string; weights_hash: string;
export type VIF = {
};
  snapshot_id: string; created_at: string; vif: VIF;
  tpv?: { priority: number; relevance: number; decay_tau?: number };
  hhni?: { path: string[]; dependency_hash?: string };
  tags?: { key: string; value: string; weight?: number }[];
  embedding?: { model_id: string; dim: number; vector: number[] };
  content_ref: { inline?: string; uri?: string; media_type: string };
  id: string; modality: string;
export type Atom = {
// src/types.ts
(Types generated from OpenAPI/Ch.28; excerpt)
29.1.3 Typed models & helpers
}
  ) { super(message); }
    public correlationId: string
    public status: number,
    public code: string,
    message: string,
  constructor(
export class AimosError extends Error {
}
  }
    return this.request<T>(p, { method: 'PATCH', body: b ? JSON.stringify(b) : undefined, headers });
    const headers = etag ? { 'If-Match': etag } : undefined;
  patch<T>(p: string, b?: unknown, etag?: string) {
  }
    return this.request<T>(p, { method: 'POST', body: b ? JSON.stringify(b) : undefined, idempotency });
  post<T>(p: string, b?: unknown, idempotency = false) {
  }
    return this.request<T>(`${p}${qs}`, { method: 'GET' });
    const qs = q ? '?' + new URLSearchParams(Object.entries(q).filter(([,v]) => v!==undefined).map(([k,v]) => [k,String(v)])).toString() : '';
  get<T>(p: string, q?: Record<string,string|number|boolean|undefined>) {
  }
    }
      throw err;
      (err as any).details = body?.error?.details;
      );
        body?.error?.correlation_id || headers.get('X-Request-Id') || ''
        res.status,
        body?.error?.code || 'HTTP_ERROR',
        body?.error?.message || `HTTP ${res.status}`,
      const err = new AimosError(
      }
        continue;
        await sleep(base + jitter);
        const jitter = Math.floor(Math.random() * 250);             // jitter
        const base = Math.min(1000 * 2 ** attempt, 8000);          // exp backoff
        attempt++;
      if (retryable && attempt < 5) {
      const retryable = [429, 503, 504].includes(res.status) || body?.error?.retryable;
      if (res.ok) return { data: body as T, headers: res.headers };
      const body = contentType.includes('json') && text ? JSON.parse(text) : text;
      const contentType = res.headers.get('Content-Type') || '';
      const text = await res.text();
      const res = await fetch(url, { ...init, headers });
    while (true) {
    /* retry: 5 attempts, exp backoff + jitter */
    let attempt = 0;
    if (init.idempotency) headers.set('Idempotency-Key', randomUUID());
    headers.set('User-Agent', this.userAgent);
    headers.set('Content-Type', headers.get('Content-Type') || 'application/json');
    headers.set('X-Request-Id', crypto.randomUUID());
    headers.set('X-Tenant', this.tenant);
    headers.set('Authorization', `Bearer ${this.token}`);
    const headers = new Headers(init.headers ?? {});
    const url = `${this.base}${path}`;
  private async request<T>(path: string, init: RequestInit & { idempotency?: boolean } = {}): Promise<{ data: T; headers: Headers }> {
  ) {}
    private userAgent = 'aimos-ts/1.0.0'
    private tenant = process.env.AIMOS_TENANT!,
    private token = process.env.AIMOS_TOKEN!,
    private base = process.env.AIMOS_BASE_URL!,
  constructor(
export class AimosHTTP {
import { randomUUID } from 'node:crypto';
import { setTimeout as sleep } from 'node:timers/promises';
// src/http.ts
29.1.2 Core HTTP with retries & idempotency
index.ts
  paginators.ts     // async iterators
  audit.ts          // SEG/VIF/replay
  orch.ts           // pipelines/runs
  memory.ts         // atoms/edges/snapshots
  types.ts          // Atom/Edge/SEG/ACL types (generated from OpenAPI)
  http.ts           // fetch wrapper, retries, auth, headers
src/
Recommended package layout:
# or: pnpm add @aimos/sdk
npm i @aimos/sdk
29.1.1 Installation & structure
29.1 JavaScript / TypeScript SDK
AIMOS_TOKEN=eyJhbGciOi...
AIMOS_TENANT=acme-co
AIMOS_BASE_URL=https://api.aimos.dev/v1
Environment variables used across examples:
 OAuth2 bearer (or mTLS) injection, zero secret logging.
Security.
 Uniform mapping to rich exceptions: code, status, correlation_id, details.
Error model.
 Always send X-Tenant.
Tenant-scoped.
 Surface X-Budget-* response headers.
Budgets & observability.
 as_of / from / to helpers.
Time-slicing.
 Cursor pattern with transparent iterators.
Pagination.
 Idempotency-Key for all mutating POSTs; safe to retry.
Idempotency.
 Exponential backoff with jitter on 429/503/504 and error.retryable=true.
Deterministic retries.
 Request/response models map 1:1 to the schemas in Ch.27/28.
Typed by default.
29.0 Design goals (all SDKs)
 artifacts. All examples conform to the API contracts defined in Ch.28.
VIF/SEG
 for AIMOS/APOE: strict typing, auth, retries with jitter, pagination cursors, idempotency keys, budget headers, and first-class handling of 
production-ready client patterns
Aim. Give builders 
Chapter 29. SDKs & Clients — JS/TS, Python, and CLI
Part XI — Reference Implementations
Uniform error body across services.
Enforce scopes per route; block write verbs on /audit/*.
Bind writes to a snapshot; closing snapshot computes Merkle root and signature.
Emit VIF tuples for all writes and runs.
Server readiness
Send If-Match for updates; handle 412.
Respect retryable and Backoff-Jitter on 429/503/504.
Handle next_cursor; stop on absence.
Set X-Tenant, X-Request-Id, Idempotency-Key on POST.
Client integration
28.12 Checklists
: any generated artifact includes machine-readable label fields in SEG (meets synthetic-content labeling duties).
Synthetic labeling
: orchestration calls to tools are proxied; tokens are least-privilege and time-boxed; all tool calls are SEG-logged.
Tool sandboxes & capability tokens
 (server-side policy pack); violations → FAILED_PRECONDITION with policy_violation=true.
PII redaction at ingest
28.11 Security & policy notes
        snapshot_id: { type: string }
        budgets_override: { type: object }
        inputs: { type: object, additionalProperties: true }
        pipeline_id: { type: string }
      properties:
      required: [ pipeline_id, inputs, snapshot_id ]
      type: object
    StartRun:
    Atom: { $ref: 'https://aimos.dev/schema/atom.json' }
  schemas:
                  correlation_id: { type: string }
                  retryable: { type: boolean }
                  status: { type: integer }
                  message: { type: string }
                  code: { type: string }
                properties:
                type: object
              error:
            properties:
            type: object
          schema:
        application/json:
      content:
      description: Error
    Error:
  responses:
components:
        '200': { description: SEG subgraph, content: { application/ld+json: {} } }
      responses:
        - { name: to, in: query, schema: { type: string, format: date-time } }
        - { name: from, in: query, schema: { type: string, format: date-time } }
        - { name: artifact_sha256, in: query, schema: { type: string } }
        - { name: claim_id, in: query, schema: { type: string } }
      parameters:
      security: [ { oauth2: [ aimos.audit.read ] } ]
    get:
  /audit/seg/lineage:
        '201': { description: Run started }
      responses:
      requestBody: { content: { application/json: { schema: { $ref: '#/components/schemas/StartRun' } } } }
      security: [ { oauth2: [ aimos.orch.write ] } ]
    post:
  /acl/runs:
        '400': { $ref: '#/components/responses/Error' }
        '201': { description: Created, headers: { X-Snapshot-Id: { schema: { type: string } }, ETag: { schema: { type: string } } } }
      responses:
      requestBody: { content: { application/json: { schema: { $ref: '#/components/schemas/Atom' } } } }
      security: [ { oauth2: [ aimos.memory.write ] } ]
    post:
  /atoms:
paths:
  - oauth2: [ aimos.memory.read ]
security:
            aimos.audit.read: Read audit
            aimos.orch.write: Write orchestration
            aimos.orch.read: Read orchestration
            aimos.memory.write: Write memory
            aimos.memory.read: Read memory
          scopes:
          tokenUrl: https://auth.aimos.dev/oauth/token
        clientCredentials:
      flows:
      type: oauth2
    oauth2:
  securitySchemes:
components:
servers: [ { url: https://api.aimos.dev/v1 } ]
info: { title: AIMOS/APOE API, version: v1 }
openapi: 3.1.0
28.10 OpenAPI (excerpt, abridged)
GET /v1/audit/replay/{run_id}
Read-only audit:
If HITL required, POST /hitl/approve twice with distinct human actors
Poll or subscribe (SSE/WebSocket optional) to /v1/acl/runs/{id} and /trace
{ "pipeline_id":"pipe:remediate_cost_runaway", "inputs":{…}, "snapshot_id":"S_BF_09D" }
POST /v1/acl/runs
Start:
B) Start an APOE run and stream witness
GET /v1/audit/seg/bundles/claim:release_rc_0_3?format=compact
Emit claim via pipeline run; fetch audit bundle:
Vector search → collect related atoms
{ "action":"close", "notes":"ingest batch 42" }
POST /v1/snapshots
Close snapshot:
Create atom → 201 (VIF emitted, snapshot bound S_BF_09D)
A) Write → Snapshot → Query → Lineage
28.9 Example flows
X-Budget-Tokens-Used, X-Budget-Latency-Ms, X-Budget-Tools-Calls, X-Budget-Cost-Usd.
 snapshot:
budget usage
Responses include 
X-Risk-Class: low|medium|high|critical
X-Intent: retrieval|orchestration|export
 headers to aid routing/quotas:
intent
Requests MAY provide 
28.8 Budget & policy headers
 in error model; clients backoff with jitter when receiving 429/503/504.
retryable
: servers mark 
Safe retries
: If-Match required for PATCH /atoms/{id} (if enabled); 412 Precondition Failed on ETag mismatch.
Optimistic updates
 require PATCH with If-Match.
updates
: identical POST /atoms within 24h returns same 201 body; later 
Idempotency-Key
28.7 Idempotency, concurrency, and retries
}
  "filters":{ "modality":"code:ts", "tag":"repo:checkout" }
  "vector":[…],
  "k":25,
  "model_id":"embed-004",
{
POST /v1/query/vector
Vector query within code only
GET /v1/audit/seg/lineage?claim_id=seg:claim:release_rc_0_3&from=2025-10-10T00:00:00Z&to=2025-10-17T00:00:00Z
Lineage for claim (time-slice to last week)
{ "items":[{…},{…}], "next_cursor":"eyJwYWdlIjoyfQ==" }
Response:
GET /v1/atoms?tag=topic:payments&limit=200
List atoms (latest), payments topic, 200/page
28.6 Filtering, sorting, and pagination (examples)
 — read-only witness channel export (events, UQ, gate outcomes).
GET /audit/runs/{run_id}/witness
 — snapshot metadata + root hash, signer, parent link.
GET /audit/snapshots/{id}
 of outputs, calibration deltas, and a replay SEG.
diff
 — dry replay plan (no external side-effects); returns 
GET /audit/replay/{run_id}
 — VIF tuple for any stored artifact.
GET /audit/vif/{artifact_id}
Query: claim_id=… or artifact_sha256=… or decision_id=…; server returns subgraph.
 — parametric lineage query.
GET /audit/seg/lineage
Query: format=compact|expanded, as_of, includeArtifacts=true|false.
 — retrieve a JSON-LD SEG bundle (Ch.27.2) for a run/claim.
GET /audit/seg/bundles/{id}
 Any POST/PUT/PATCH/DELETE to /audit/* returns 405 Method Not Allowed.
Immutable & replayable.
28.5 Audit API (read-only)
 — rejection with rationale (SEG decision emitted).
POST /acl/runs/{run_id}/hitl/reject
 — two-key approval (requires second human approval; enforced role).
POST /acl/runs/{run_id}/hitl/approve
28.4.3 HITL actions (if enabled by risk)
 — live budget ledger (tokens/latency/tools/cost).
GET /acl/runs/{run_id}/budget
: steps, gates, UQ, artifacts (redacted by policy).
witness trace
 — 
GET /acl/runs/{run_id}/trace
 — best-effort cancel.
POST /acl/runs/{run_id}:cancel
 — filter by pipeline_id, status, from/to, actor.
GET /acl/runs
 — status (pending|running|abstained|failed|succeeded|quarantined|rolled_back).
GET /acl/runs/{run_id}
.
witness channel
Returns run_id, initial state, and 
}
  "policies": { "hitl_required": false }
  "snapshot_id": "S_BF_09D",
  "budgets_override": { "tokens_max": 14000 },
  "inputs": { "window": { "from": "2025-10-10", "to": "2025-10-17" } },
  "pipeline_id": "pipe:remediate_cost_runaway",
{
Body (shape):
 — start a run from pipeline.
POST /acl/runs
28.4.2 Runs
 — list; filters: risk_class, updated_from, owner.
GET /acl/pipelines
 — fetch one (versioned).
GET /acl/pipelines/{id}
Validates AST against schema (Ch.27.3) and static gates.
Scopes: aimos.orch.write (ETag required for updates).
 — create/update pipeline definition.
POST /acl/pipelines
28.4.1 Pipelines (ACL AST)
28.4 Orchestration API (APOE/ACL)
 — list, filter by time window, stats.
GET /snapshots
, 
GET /snapshots/{id}
Returns closed snapshot metadata (Ch.27.1.3).
Body: { "action":"close" | "open", "notes":"…" }
 — close/open snapshot (Merkle root computed).
POST /snapshots
28.3.3 Snapshots
 — filter by rel, source_id, target_id, as_of.
GET /edges
, 
GET /edges/{id}
Validates relation lawfulness, time-slice, and existence in snapshot.
 — create edge (Ch.27.1.2).
POST /edges
28.3.2 Edges
{ "id": "a_7c9c…", "snapshot_id": "S_BF_09D", "etag": "W/\"e1f-7c3\"", "created_at": "2025-10-17T12:30:01Z", "vif": { "model_id":"apoe-gptx-2025-09", "weights_hash":"9f2e…", "prompt_template_id":"atomize_v3", "tool_ids":["embedder-004"], "writer":"agent:archivist" } }
200/201 response (abridged)
}
  "tpv": { "priority": 0.8, "relevance": 0.87, "decay_tau": 604800 }
  "hhni": { "path": ["system:aiops","section:queries","sentence:12"], "dependency_hash": "5fe1…" },
  "tags": [ { "key": "topic", "value": "payments", "weight": 0.9 } ],
  "embedding": { "model_id": "embed-004", "vector": [0.12, -0.03, …], "dim": 768 },
  "content_ref": { "inline": "Summarize failed transfers by tip type last week.", "media_type": "text/plain" },
  "modality": "prompt:user",
  "kind": "atom",
  "schema_version": "1.1.0",
{
Idempotency-Key: 9f7d6c8e-…
Content-Type: application/json
Authorization: Bearer …
POST /v1/atoms
Create atom — example
Body: { "model_id":"embed-004", "k":10, "vector":[…], "filters":{ "modality":"text/plain" } }
 — kNN over embeddings (returns atom ids + scores).
POST /query/vector
Query: modality=code:ts, tag=topic:payments, path=system:…, as_of=…, limit, cursor
 — list/filter.
GET /atoms
Scopes: aimos.memory.read
 — fetch one (time-slice via as_of).
GET /atoms/{id}
On success: 201 Created + body; headers: X-Snapshot-Id, ETag
(optional; if absent, server opens one)
Headers: Idempotency-Key, X-Snapshot-Id 
Scopes: aimos.memory.write
 — create atom (Ch.27.1.1).
POST /atoms
28.3.1 Atoms
28.3 Memory API
ABORTED, CONFLICT, TOO_MANY_REQUESTS, INTERNAL.
FAILED_PRECONDITION, INVALID_ARGUMENT, RESOURCE_EXHAUSTED,
UNAUTHENTICATED, PERMISSION_DENIED, NOT_FOUND, ALREADY_EXISTS,
Common codes (subset):
}
  }
    "details": { "field": "hhni.path[0]" }
    "correlation_id": "req_9b2f…",
    "retryable": false,
    "status": 400,
    "message": "hhni.path must be non-empty and canonical.",
    "code": "MEMORY_INVALID_HHNI",
  "error": {
{
Error model (uniform):
: X-Request-Id echoed; also in error bodies and SEG ToolCall nodes.
Correlation
: headers X-RateLimit-Limit/Remaining/Reset.
Rate limits
: cursor model — limit (≤ 500), cursor; response includes next_cursor.
Pagination
: ?as_of=2025-10-17T12:34:56Z or ?from=…&to=….
Time-slicing
: If-Match: W/"etag" on mutable resources.
ETags/optimistic control
: Idempotency-Key (UUID v4); server stores 24h hash of request → response.
Idempotency
: application/json; charset=utf-8 (SEG bundles: application/ld+json).
Content-Type
28.2 Cross-cutting conventions
Read SEG bundles, VIF tuples, replays (read-only)
aimos.audit.read
Create/update pipelines, start/cancel runs
aimos.orch.write
Read pipelines, runs, traces
aimos.orch.read
Create/update atoms/edges, open snapshots
aimos.memory.write
Read atoms/edges/snapshots, vector queries
aimos.memory.read
Purpose
Scope
 (minimum set):
Scopes
: X-Tenant: {org_id} (required).
Tenancy
 mTLS.
or
: OAuth2/OIDC bearer JWT 
Auth
: https://api.aimos.dev/v1/ (semantic, additive minor versions; breaking changes => v2).
Base URL
28.1 Base, versions, and auth
 (SDF-CVF): parity gates enforced at API boundaries.
Atomic evolution
 (SEG): lineage is queryable; contradictions are first-class.
Graph substrate
 (VIF): every mutating call emits a VIF tuple.
Provenance by default
 (CMC): snapshot-bound reads/writes; time-sliced queries.
Memory-first
 (APOE): typed I/O, explicit budgets, reproducible runs.
Deterministic contracts
28.0 Design goals
 services. This chapter defines endpoint shapes, auth scopes, pagination, filtering, error models, idempotency, and examples. It aligns with the schemas in Ch.27 (Atom/Edge, SEG JSON-LD, ACL AST) and the invariants CMC/APOE/VIF/SEG/SDF-CVF.
clean, versioned, and provable
Aim. Expose AIMOS/APOE as 
Chapter 28. APIs — Memory, Orchestration, and Audit (read-only)
Part XI — Reference Implementations
Decision nodes annotate and/or support claims.
ValidFrom/ValidTo reflect change window.
All referenced nodes reachable.
Context URL resolves locally or is bundled.
SEG export
Time-slice fields set; VIF present.
Weight/confidence in [0,1].
Relation lawful; self-edge forbidden.
Edge write
VIF tuple filled; snapshot bound.
HHNI path + dependency hash set.
Embedding present (vector or ref).
Inline vs URI chosen; hash computed.
Atom write
27.8 Checklists
 export endpoints include X-Snapshot-Id in headers for replay.
read-only
All 
POST /acl/run → emits Witness/VIF + SEG links
POST /acl/pipelines (AST)
Orchestration API
GET /seg/graph?as_of=… (subgraph extract)
POST /seg/bundle (ingest JSON-LD)
Evidence API
POST /query/vector (kNN over embedding)
GET /atoms/{id}?as_of=… (time-slice)
POST /edges
POST /atoms (validate + snapshot bind)
Memory API
27.7 Minimal APIs (shape only)
: store schema_version; supply mappers vN→vN+1 with SEG-logged Decisions.
Migrations
: RFC 8785 (JSON Canonicalization Scheme) before computing bytes_sha256 or root_hash.
Canonicalization for hashing
Time: valid_from <= valid_to || valid_to==null.
 (source.kind, target.kind) is lawful (molecule↔atom rules).
⇒
Edge: rel in {"contains","is_part_of"} 
 hhni.parent_id==null or points to molecule.
⇒
Atom: kind=atom 
:
Semantic validation
: JSON Schema validators (draft 2020-12).
Static validation
27.6 Validation & Tooling
 for a claim derived from these atoms; export the JSON-LD bundle as part of the run’s VIF.
Emit SEG
}
  "vif": { "model_id":"reranker-02","weights_hash":"1cc…","prompt_template_id":"rerank_v2","tool_ids":["vecIndex"],"writer":"agent:retriever" }
  "valid_to": null,
  "valid_from": "2025-10-17T12:30:05Z",
  "created_at": "2025-10-17T12:30:05Z",
  "snapshot_id": "S-BF-09D",
  "reason": "semantic_cosine>=0.85",
  "policy": "allowed",
  "confidence": 0.9,
  "weight": 0.87,
  "rel": "relates_to",
  "target_id": "a-42bd…",
  "source_id": "a-7c9c…",
  "schema_version": "1.0.0",
  "id": "e-22a1…",
{
 it to a retrieval artifact with an edge:
Relate
}
  "etag": "W/\"e1f-7c3\""
  },
    "writer": "agent:archivist"
    "tool_ids": ["embedder-004"],
    "prompt_template_id": "atomize_v3",
    "weights_hash": "9f2e…",
    "model_id": "apoe-gptx-2025-09",
  "vif": {
  "valid_to": null,
  "valid_from": "2025-10-17T12:30:01Z",
  "updated_at": "2025-10-17T12:30:01Z",
  "created_at": "2025-10-17T12:30:01Z",
  "snapshot_id": "S-BF-09D",
  "metrics": { "qs": 0.82, "ids": 0.76, "dd": 0.03 },
  "hhni": { "path": ["system:aiops","section:queries","sentence:12"], "dependency_hash": "5fe1…" },
  "tpv": { "priority": 0.8, "relevance": 0.87, "decay_tau": 604800 },
  "tags": [{ "key": "topic", "value": "payments", "weight": 0.9 }],
  "embedding": { "model_id": "embed-004", "dim": 768, "vector_ref": "vec:a-7c9c…" },
  "content_ref": { "inline": "Summarize failed transfers by tip type last week.", "media_type": "text/plain" },
  "modality": "prompt:user",
  "kind": "atom",
  "schema_version": "1.1.0",
  "id": "a-7c9c…",
{
 a text atom (user prompt → atomized):
Write
27.5 Worked Example (Atom + Edge + SEG round-trip)
 recomputes rs = f(qs, ids, dd); writers should not set rs unless they also provide a VIF for the scoring step.
reader
: only the 
Calibration
: redact PII at ingest; policy fields propagate to SEG exports.
Security
: store content_ref.inline_gzip for verbose text; keep bytes_sha256 of raw.
Compression
: optimistic writes with etag; server rejects on mismatch.
Concurrency
Vectors: embedding.vector (cosine) or embedding.vector_ref.
Edges: snapshot_id, rel, source_id, target_id, valid_from.
Atoms: snapshot_id, modality, hhni.path[*], metrics.rs, tpv.priority.
 (recommended):
Indices
: (source_id, target_id, rel, valid_from) must be unique.
Uniqueness
: Edges source_id/target_id must exist in the same snapshot_id (or specify cross-snapshot links with explicit from_snapshot/to_snapshot fields).
Referential integrity
27.4 Integrity, Indexing, and Performance Notes
}
  ]
    { "from": "adjust_rag", "to": "canary" }
  "flow": [
  ],
    }
      "witness": { "record_artifacts": true, "vif_emit": true }
      ],
        { "id": "slo_ok", "kind": "test", "expr": "slo.p95_latency <= target && rs_lift >= -0.005", "severity": "block", "on_fail": "rollback" }
      "gates": [
      "budgets": { "latency_ms_max": 60000 },
      "out": { "canary_report": "${result}" },
      "in": { "config": "${steps.adjust_rag.out.new_config}" },
      "tool": { "id": "canary_runner", "args": { "traffic_pct": 5 } },
      "role": "operator",
      "id": "canary",
    {
    },
      "witness": { "record_artifacts": true, "vif_emit": true }
      ],
        { "id": "do_no_harm", "kind": "custom", "expr": "metrics.rs_lift >= -0.01", "severity": "block", "on_fail": "abort" }
      "gates": [
      "budgets": { "tokens_max": 2000, "latency_ms_max": 30000, "tools_max_calls": 2 },
      "out": { "new_config": "${result}" },
      "in": { "window": "${inputs.window}" },
      "tool": { "id": "config_editor", "args": { "param": "rag.top_k", "delta": -3 } },
      "role": "operator",
      "id": "adjust_rag",
    {
  "steps": [
  "policies": { "kappa_abstain_threshold": 0.35, "risk_class": "medium", "hitl_required": false },
  "budgets": { "tokens_max": 12000, "latency_ms_max": 180000, "tools_max_calls": 20, "cost_usd_max": 5.0 },
  "outputs": { "decision": { "type": "evidence" } },
  "inputs": { "window": { "type": "object", "required": true } },
  "description": "Lower RAG cost without harming retrieval quality.",
  "name": "Remediate Cost Runaway",
  "schema_version": "1.0.0",
  "id": "pipe:remediate_cost_runaway",
{
 (from Ch.26) — AST instance
remediate_cost_runaway
27.3.2 Example: 
}
  }
    }
      }
        }
          }
            "abstain_threshold": { "type": "number", "minimum": 0, "maximum": 1 }
          "properties": {
          "type": "object",
        "kappa_overrides": {
        },
          }
            "backoff_ms":  { "type": "integer", "minimum": 0 }
            "max_attempts": { "type": "integer", "minimum": 0 },
          "properties": {
          "type": "object",
        "retries": {
        },
          }
            "vif_emit": { "type": "boolean" }
            "record_outputs": { "type": "boolean" },
            "record_inputs": { "type": "boolean" },
            "record_artifacts": { "type": "boolean" },
          "properties": {
          "type": "object",
        "witness": {
        "gates": { "type": "array", "items": { "$ref": "#/$defs/gate" } },
        "budgets": { "$ref": "#/$defs/budget" },
        "out": { "type": "object", "additionalProperties": true },
        "in": { "type": "object", "additionalProperties": true },
        },
          }
            "prompt_template_id": { "type": "string" }
            "args": { "type": "object", "additionalProperties": true },
            "id": { "type": "string" },
          "properties": {
          "required": ["id"],
          "type": "object",
        "tool": {
        },
          "enum": ["planner","retriever","reasoner","verifier","builder","critic","operator","witness"]
        "role": {
        "id": { "type": "string" },
      "properties": {
      "required": ["id","role","tool","in","out","budgets","gates","witness"],
      "type": "object",
    "step": {
    },
      }
        "on_fail": { "enum": ["abort","repair","quarantine","escalate"] }
        "severity": { "enum": ["warn","error","block"] },
        "expr": { "type": "string", "description": "CEL-like or JSONLogic expression" },
        "kind": { "enum": ["spec","test","safety","provenance","uq","cost","custom"] },
        "id": { "type": "string" },
      "properties": {
      "required": ["id","kind","expr"],
      "type": "object",
    "gate": {
    },
      }
        "hitl_required": { "type": "boolean" }
        "risk_class": { "enum": ["low","medium","high","critical"] },
        "kappa_abstain_threshold": { "type": "number", "minimum": 0, "maximum": 1 },
      "properties": {
      "type": "object",
    "policies": {
    },
      }
        "gpu_class": { "type": "string" }
        "cost_usd_max": { "type": "number", "minimum": 0 },
        "tools_max_calls": { "type": "integer", "minimum": 0 },
        "latency_ms_max": { "type": "integer", "minimum": 0 },
        "tokens_max": { "type": "integer", "minimum": 0 },
      "properties": {
      "type": "object",
    "budget": {
    },
      }
        }
          "description": { "type": "string" }
          "required": { "type": "boolean" },
          "type": { "enum": ["string","number","boolean","object","array","artifact","evidence","any"] },
        "properties": {
        "required": ["type"],
        "type": "object",
      "additionalProperties": {
      "type": "object",
    "ioSchema": {
  "$defs": {
  },
    }
      }
        "properties": { "from": { "type": "string" }, "to": { "type": "string" } }
        "required": ["from","to"],
        "type": "object",
      "items": {
      "description": "DAG edges: from → to",
      "type": "array",
    "flow": {
    },
      "minItems": 1
      "items": { "$ref": "#/$defs/step" },
      "type": "array",
    "steps": {
    "policies": { "$ref": "#/$defs/policies" },
    "budgets": { "$ref": "#/$defs/budget" },
    "outputs": { "$ref": "#/$defs/ioSchema" },
    "inputs": { "$ref": "#/$defs/ioSchema" },
    "description": { "type": "string" },
    "name": { "type": "string" },
    "schema_version": { "type": "string" },
    "id": { "type": "string" },
  "properties": {
  "required": ["id","schema_version","name","inputs","outputs","budgets","steps","flow","policies"],
  "type": "object",
  "title": "ACL Pipeline AST",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://aimos.dev/schema/acl-pipeline.json",
{
27.3.1 Top-level schema
.
diff-able, testable, and auditable
 A typed, versioned JSON AST for pipelines/steps/gates/budgets so plans are 
Purpose.
27.3 ACL — APOE Chain Language AST
 on claims and tool calls guarantees replayability.
VIF tuple
The 
 by validFrom/validTo on any node/edge.
Time-slice
; contradictions are explicit contradicts links (never destructive deletes).
additive
All edges are 
Design notes.
}
  ]
    }
      "generatedAt": "2025-10-17T12:29:55Z"
      "rootHash": "aa77…",
      "type": "seg:Snapshot",
      "id": "seg:snapshot:S-BF-09D",
    {
    },
      "supports": ["seg:claim:release_rc_0_3"]
      "annotates": ["seg:claim:release_rc_0_3"],
      "validFrom": "2025-10-17T12:38:00Z",
      "text": "Approved by two-key HITL; promote canary.",
      "type": "seg:Decision",
      "id": "seg:decision:DR-778",
    {
    },
      "used": "seg:snapshot:S-BF-09D"
      "wasAssociatedWith": "agent:operator",
      "resultHash": "c3d4…",
      "argsHash": "a1b2…",
      "toolId": "canaryRunner",
      "type": "seg:ToolCall",
      "id": "seg:tool:canary_result",
    {
    },
      "supports": ["seg:claim:release_rc_0_3"]
      "validTo": null,
      "validFrom": "2025-10-17T12:30:00Z",
      "sha256": "2ab3…",
      "mediaType": "application/json",
      "type": "seg:Artifact",
      "id": "seg:artifact:rs_report",
    {
    },
      "derivesFrom": ["seg:artifact:rs_report","seg:tool:canary_result"]
      "generatedAt": "2025-10-17T12:37:00Z",
      },
        "snapshot_id": "S-BF-09D"
        "tool_ids": ["canaryRunner","segQuery"],
        "prompt_template_id": "promote_canary_v2",
        "weights_hash": "9f2e…",
        "model_id": "apoe-gptx-2025-09",
      "vif": {
      "uq": { "ece": 0.018, "entropy": 0.23 },
      "confidence": 0.92,
      "text": "Promote canary of RAG top_k=8 to 100%.",
      "type": "seg:Claim",
      "id": "seg:claim:release_rc_0_3",
    {
  "@graph": [
  "@context": "https://aimos.dev/seg/context.json",
{
27.2.3 Example (compact JSON-LD)
 — operational evidence.
seg:Span/Log/Metric
 — memory state reference that scoped the run.
seg:Snapshot
 — adjudicated outcome linked to claims/evidence.
seg:Decision
 — invocation record (tool id, args hash, result hash).
seg:ToolCall
 — external reference (doc, URL, dataset).
seg:Source
 — any intermediate (snippet, summary, code block).
seg:Artifact
 — a statement the system asserts.
seg:Claim
27.2.2 Core types
}
  }
    "vif":        { "@id": "seg:provenanceTuple" }
    "uq":         { "@id": "seg:uncertaintyVector" },
    "confidence": { "@id": "seg:confidence", "@type": "xsd:double" },
    "wasAssociatedWith": { "@id": "prov:wasAssociatedWith", "@type": "@id" },
    "used":        { "@id": "prov:used", "@type": "@id" },
    "generatedAt": { "@id": "prov:generatedAtTime", "@type": "xsd:dateTime" },
    "annotates":   { "@id": "seg:annotates",   "@type": "@id" },
    "contradicts": { "@id": "seg:contradicts", "@type": "@id" },
    "supports":    { "@id": "seg:supports",    "@type": "@id" },
    "derivesFrom": { "@id": "seg:derivesFrom", "@type": "@id" },
    "validTo":   { "@id": "seg:validTo",   "@type": "xsd:dateTime" },
    "validFrom": { "@id": "seg:validFrom", "@type": "xsd:dateTime" },
    "type":    "@type",
    "id":      "@id",
    "schema":  "http://schema.org/",
    "xsd":     "http://www.w3.org/2001/XMLSchema#",
    "prov":    "http://www.w3.org/ns/prov#",
    "seg":     "https://aimos.dev/seg#",
  "@context": {
{
27.2.1 JSON-LD @context
 Interoperable, machine-readable lineage for claims, sources, tool calls, and decisions. Time-sliced, exportable, and queryable with graph tooling.
Purpose.
27.2 SEG — Shared Evidence Graph (JSON-LD)
}
  }
    "notes": { "type": "string" }
    },
      }
        "sig_hex": { "type": "string" }
        "signed_by": { "type": "string" },
        "algo": { "enum": ["ed25519"] },
      "properties": {
      "required": ["algo","signed_by","sig_hex"],
      "type": "object",
    "signature": {
    },
      }
        "edges": { "type": "integer" }
        "atoms": { "type": "integer" },
      "properties": {
      "type": "object",
    "stats": {
    "root_hash": { "type": "string", "pattern": "^[a-f0-9]{64}$" },
    "parent_id": { "type": ["string","null"] },
    "created_at": { "type": "string" },
    "schema_version": { "type": "string" },
    "id": { "type": "string" },
  "properties": {
  "required": ["id","schema_version","created_at","root_hash","stats","signature"],
  "type": "object",
  "title": "AIMOS Snapshot",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://aimos.dev/schema/snapshot.json",
{
27.1.3 Snapshot (content-addressed, Merkle)
derives/supports/contradicts/annotates mirror SEG semantics for cross-linking memory↔evidence.
depends_on governs build/order constraints.
relates_to (semantic similarity) is pruned by Adaptive Weight Pruning.
contains/is_part_of encode HHNI hierarchy.
Edge semantics.
}
  }
    }
      }
        "writer": { "type": "string" }
        "tool_ids": { "type": "array", "items": { "type": "string" } },
        "prompt_template_id": { "type": "string" },
        "weights_hash": { "type": "string" },
        "model_id": { "type": "string" },
      "properties": {
      "required": ["model_id","weights_hash","prompt_template_id","tool_ids","writer"],
      "type": "object",
    "vif": {
    "valid_to":    { "type": ["string","null"] },
    "valid_from":  { "type": "string" },
    "created_at":  { "type": "string" },
    "snapshot_id": { "type": "string" },
    "reason": { "type": "string" },
    "policy": { "type": "string", "description": "e.g., allowed, restricted, redacted" },
    "confidence": { "type": "number", "minimum": 0, "maximum": 1 },
    "weight": { "type": "number", "minimum": 0, "maximum": 1 },
    },
      ]
        "derives","supports","contradicts","annotates","temporal_next"
        "contains","is_part_of","relates_to","depends_on","is_summary_of",
      "enum": [
      "type": "string",
    "rel": {
    "target_id": { "type": "string" },
    "source_id": { "type": "string" },
    "schema_version": { "type": "string" },
    "id": { "type": "string" },
  "properties": {
  "required": ["id","schema_version","source_id","target_id","rel","weight","snapshot_id","created_at","vif"],
  "type": "object",
  "title": "AIMOS Memory Edge",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://aimos.dev/schema/edge.json",
{
 Typed, weighted links between atoms/molecules; time-sliced; provenance-stamped.
Purpose.
27.1.2 Edge (memory relation)
Either embedding.vector or embedding.vector_ref must exist (store vectors where your stack prefers).
hhni.dependency_hash is computed over (parent_id, path, tags, content_hash) to detect integrity breaks.
inline is capped for small payloads; large content goes via uri + bytes_sha256.
Notes.
asset:image, asset:audio, asset:pdf
prompt:user, prompt:system, prompt:tool
event:log, event:span, event:metric
code:ts, code:py, code:sql, code:dockerfile
text/plain, text/markdown
Modality taxonomy (non-exhaustive).
}
  }
    "etag": { "type": "string" }
    },
      }
        "writer": { "type": "string", "description": "agent id or human id" }
        "tool_ids": { "type": "array", "items": { "type": "string" } },
        "prompt_template_id": { "type": "string" },
        "weights_hash": { "type": "string", "pattern": "^[a-f0-9]{64}$" },
        "model_id": { "type": "string" },
      "properties": {
      "required": ["model_id","weights_hash","prompt_template_id","tool_ids","writer"],
      "type": "object",
    "vif": {
    "valid_to":    { "type": ["string","null"] },
    "valid_from":  { "type": "string" },
    "updated_at":  { "type": "string" },
    "created_at":  { "type": "string" },
    "snapshot_id": { "type": "string" },
    },
      }
        "rs":  { "type": "number", "minimum": 0, "maximum": 1 }
        "dd":  { "type": "number", "minimum": 0, "maximum": 1 },
        "ids": { "type": "number", "minimum": 0, "maximum": 1 },
        "qs": { "type": "number", "minimum": 0, "maximum": 1 },
      "properties": {
      "type": "object",
    "metrics": {
    },
      }
        "dependency_hash": { "type": "string", "pattern": "^[a-f0-9]{64}$" }
        "children_count": { "type": "integer", "minimum": 0 },
        "parent_id": { "type": "string" },
        },
          "items": { "type": "string" }
          "description": "Fractal path: system→section→paragraph→sentence→word→subword",
          "type": "array",
        "path": {
      "properties": {
      "required": ["path","dependency_hash"],
      "type": "object",
    "hhni": {
    },
      }
        "last_access_at": { "type": "string" }
        "decay_tau": { "type": "number", "minimum": 0 },
        "relevance": { "type": "number", "minimum": 0, "maximum": 1 },
        "priority": { "type": "number", "minimum": 0, "maximum": 1 },
      "properties": {
      "description": "Tag Priority Vector dynamics",
      "type": "object",
    "tpv": {
    },
      }
        }
          "weight": { "type": "number", "minimum": 0, "maximum": 1 }
          "value": { "type": "string" },
          "key": { "type": "string" },
        "properties": {
        "required": ["key","weight"],
        "type": "object",
      "items": {
      "type": "array",
    "tags": {
    },
      ]
        { "required": ["vector_ref"] }
        { "required": ["vector"] },
      "oneOf": [
      },
        "vector_ref": { "type": "string", "description": "If vector is stored in external vector index" }
        },
          "minItems": 1
          "items": { "type": "number" },
          "type": "array",
        "vector": {
        "dim": { "type": "integer", "minimum": 1 },
        "model_id": { "type": "string" },
      "properties": {
      "required": ["model_id","dim"],
      "type": "object",
    "embedding": {
    },
      ]
        { "required": ["uri","bytes_sha256"] }
        { "required": ["inline"] },
      "oneOf": [
      },
        "media_type": { "type": "string" }
        "bytes_sha256": { "type": "string", "pattern": "^[a-f0-9]{64}$" },
        "uri": { "type": "string", "description": "Content-addressed or object store URI" },
        "inline": { "type": "string", "description": "Optional small content (≤ 64KB)" },
      "properties": {
      "required": ["media_type"],
      "type": "object",
    "content_ref": {
    },
      "additionalProperties": true
      "description": "Modality-specific fields",
      "type": "object",
    "modality_meta": {
    },
      "description": "Free taxonomy with prefixes; examples below"
      "type": "string",
    "modality": {
    "kind": { "enum": ["atom","molecule"] },
    "schema_version": { "type": "string", "pattern": "^[0-9]+\\.[0-9]+\\.[0-9]+$" },
    "id": { "type": "string", "pattern": "^[a-f0-9-]{36}$" },
  "properties": {
  "required": ["id","schema_version","kind","modality","snapshot_id","created_at","content_ref","embedding","hhni","vif"],
  "type": "object",
  "title": "AIMOS Atom",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://aimos.dev/schema/atom.json",
{
 The smallest addressable unit of memory (or a container “molecule”). Every atom is embeddable, indexed (HHNI path), and snapshotted.
Purpose.
27.1.1 Atom (memory node)
27.1 CMC/HHNI — Atom & Edge Schemas
 (VIF tuple): (model_id, weights_hash, prompt_template_id, tool_ids[], snapshot_id) recorded on any write.
Provenance
: valid_from, valid_to (null = open-ended).
Time-slicing
: sha256_hex of canonical bytes (UTF-8, normalized newlines).
Hashing
: schema_version uses semver; breaking changes bump MAJOR.
Versioning
: RFC 3339/ISO-8601 UTC (2025-10-17T12:34:56Z).
Timestamps
: uuidv7 (string).
ID
27.0 Conventions (applies to all schemas)
 concrete and interoperable. This chapter defines canonical schemas for (1) CMC/HHNI atoms & edges, (2) the Shared Evidence Graph (SEG) in JSON-LD, and (3) the APOE orchestration AST for ACL. All schemas are versioned, time-sliced, and provenance-aware (VIF).
orchestration
, and 
evidence
, 
memory
Aim. Make 
Chapter 27. Data Schemas — Atom/Edge (CMC/HHNI), SEG JSON-LD, and ACL AST
Part XI — Reference Implementations
Error-budget policy reviewed.
Monitors/runbooks updated; drills scheduled.
SDF-CVF atomic patch merged (code/docs/tags/traces).
Postmortem published; export pack archived.
After incident
VIF packets emitted at every boundary.
Canaries before production switches.
κ-gates active on high-risk steps.
SEG edges: symptoms↔changes linked.
Forensic pipeline redaction verified.
Snapshot and time window frozen.
IC named; comms set.
During incident
26.9 Checklists
 Postmortem draft with SEG export pack; SDF-CVF commit adds tests to guard top-k regression.
02:00
 Decision node promote_fix recorded; VIF bundle sealed.
00:35
 Full traffic restored; auto-rollback prepared as shadow.
00:20
 Promote canary to 50%; SLOs hold; RS-lift −0.003 (within guard).
00:15
 Playbook “cost runaway” lowers top_k to 8; canary 5% passes.
00:09
 SEG query links spike to change_set C-142 (RAG top-k=20).
00:05
 IC engaged; κ gates new complex chains.
00:02
 Pager triggers: cost anomaly (p=0.007).
00:00
26.8 End-to-End Example (Condensed Timeline)
 RS-lift post-fix ≥ 0; ECE within band.
Quality:
 without regression ≥ Y%.
auto-remediation success
 token/latency budget adherence; 
Cost:
 p95.
HITL latency
 κ-abstention true-positive rate; 
Safety:
 RCA completeness (graph coverage ≥ X%), replay fidelity=100%.
Correctness:
 MTTR; rollback success rate.
Restore:
 MTTC; % incidents contained by canary.
Contain:
 MTTD p50/p95.
Detect:
26.7 KPIs, SLOs, and Error Budgets (Ops)
CFR, MTTR, deployment frequency, lead time — tied to incident cohort.
DORA-aligned updates.
Retention schedule & labels.
Decisions & ADRs.
Redacted logs/metrics/traces.
VIF packet bundle (model/tool/prompt hashes).
Time-sliced subgraph (JSON-LD).
SEG export pack contents.
 (SDF-CVF), new tests, updated runbooks, monitors.
code/docs/tags/traces
 change set across 
atomic
 
Now what:
 user impact, legal/compliance notes; cost.
So what:
.
technical + organizational
 primary + contributing factors; model: 
Why:
 timeline from SEG; attach spans/logs/decisions.
What/When:
Postmortem (blameless, time-boxed).
26.6 Post-Incident: Evidence, Learning, and SDF-CVF
  step audit(role: witness) -> seg_incident_package
  step blocklist(role: operator) tool: egress_filter
  step isolate(role: operator) tool: sandbox_enforcer
  step revoke(role: operator) tool: token_revoker
pipeline remediate_security_event
Playbook 3 — Security Event (SSRF/Exfil).
    out: new_calibrator
    tool: calibrator_fit
  step retrain_calibrator(role: builder)
    gate: { goldset.f1 >= policy.min_f1 }
    out: { template: "fallback_v2" }
    in: { template: "main" }
    tool: prompt_templates
  step template_fallback(role: builder)
    gate: { ece <= 0.03 }
    out: ece
    tool: temp_sweep
  step calibrate(role: verifier)
pipeline remediate_prompt_rot
Playbook 2 — Prompt-Rot / Drift.
    gate: { slo.p95_latency <= target && rs_lift >= -0.005 }
    out: canary_ok
    tool: canary_runner
  step canary(role: operator)
    gate: { drift.delta <= 0.02 }
    out: { embedder: "v-medium" }
    in: { embedder: "v-large" }
    tool: model_switch
  step swap_embedder(role: operator)
    gate: { rs_lift >= -0.01 }   # do-no-harm guard
    out: { top_k: max(current-3, 3) }
    in: { top_k: current }
    tool: config_editor
  step adjust_rag(role: operator)
pipeline remediate_cost_runaway
Playbook 1 — Cost Runaway (RAG).
 every step emits VIF & SEG edges.
Witnessing:
 all actions bind to a snapshot_id; rollback is deterministic.
Snap-first:
 flows require human approval.
compliance-critical
 SEV-1 or 
Two-key:
 ≤5% traffic; promote only if SLOs green for N intervals.
Canaries:
 token/latency ceilings; auto-stop at 80% of cap.
Budget caps:
 change set.
recent
 only toggle flags / revert 
Scope caps:
Guardrails.
26.5 Safe Autoremediation: Guardrails & Playbooks
 and escalate to HITL.
abstain
 If UQ.calibration deteriorates or RS-lift<0, 
κ-gating.
    out: vif_packet, decision_node
  step witness(role: witness)
    gate: { canary.ok && error_budget.burn_rate < 1.0 }
    out: rollback_done
    in: change_set
    tool: rollback_manager
  step recover(role: builder)
    policy: least_disruption
    out: toggles_off
    in: change_set
    tool: feature_flags
  step contain(role: operator)
    gate: { change_set.nonempty? }
    out: change_set, seg_slice
    in: anomaly_report
    tool: seg_query
  step correlate(role: witness)
    gate: { anomaly.p_value <= 0.01 }
    out: anomaly_report
    tool: cost_anomaly_detector
  step detect(role: operator)
  budget { tokens.max: 8k, latency_ms.max: 120000, tools.max_calls: 10 }
  input { window: time_range, service: id }
pipeline incident_sev2_cost_spike
Detection→Triage→Containment→Recovery plan.
26.4 Incident Pipelines in ACL (APOE)
 Decision & link all artifacts (no deletions—use contradicts edges).
Record
 (promote/revert/patch).
Decide
 in canary; capture VIF.
Experiment
 (explicit Claim).
Hypothesize
 with RS-lift & UQ deltas.
Validate
 to changes/spec diffs.
Correlate
 symptoms (logs/metrics/traces).
Cluster
 time window; snapshot SEG slice.
Freeze
Eight-step RCA loop.
}
  FILTER (?claim = seg:Claim_release_rc_0_3)
  ?artifact seg:supports ?source .
         seg:derivesFrom ?artifact .
  ?claim a seg:Claim ;
SELECT ?claim ?artifact ?source WHERE {
SPARQL (lineage to data source).
RETURN e, t, s, c ORDER BY e.ts ASC LIMIT 50;
WHERE c.at <= e.ts AND c.at >= e.ts - duration('PT2H')
MATCH (t)-[:HAS_SNAPSHOT]->(s:Snapshot)<-[:DEPLOYED]-(c:Change)
WHERE e.ts >= $t0 AND e.ts <= $t1
MATCH (e:Log {level:'ERROR'})-[:IN_TRACE]->(t:Trace)
Cypher (example) — “What changed before the first error?”
 Symptom, Span, Log, Metric, Change, Spec, Claim, Decision, Gate, ToolCall, Snapshot.
Minimal nodes.
 node with remediations.
Decision
 linking symptoms → spans/logs → changes → decisions → sources, then attach a 
time-sliced subgraph
 Produce a 
RCA goal.
26.3 RCA with the Shared Evidence Graph (SEG)
WHERE l.level='ERROR' AND d.deployed_at >= now()-INTERVAL '2h';
  ON l.snapshot_id = d.snapshot_id
JOIN deployment_events d
FROM logs l
SELECT l.trace_id, d.pr_number, d.change_type
Trace join to recent changes:
HAVING COUNT(*) > baseline * 2.5;
GROUP BY TUMBLE(ts, INTERVAL '5 minutes')
  AND ts BETWEEN now()-INTERVAL '30 minutes' AND now()
WHERE msg='prompt_injection_detected'
FROM logs
SELECT window_start, COUNT(*) AS inj_attempts
Time-boxed anomaly burst (SQL-ish):
Query snippets (illustrative).
 redactor blocks > baseline p95.
Data leakage near-miss:
 κ-abstentions ↑ + ECE ↑ + RS distribution shift.
Drift/prompt-rot:
 token spend derivative > threshold, RS-lift ↓.
Cost runaway:
 unusual egress domains, blocked capability tokens.
Exfil/SSRF:
 sudden spike in policy.violations + new referers.
Prompt-injection:
Canonical patterns.
26.2 Log Forensics: Patterns & Queries
 tuples (tool versions, hashes) to guarantee replay.
VIF
All stages emit 
 via snapshot_id, trace_id.
SEG
 to 
Link
 (columnar + vector) → 5) 
Index
 (PII, secrets) → 4) 
Redact
 (JSON) → 3) 
Normalize
 (syslog/OTLP) → 2) 
Ingest
Ingest→Normalize→Redact→Index pipeline
}
  }
    "kappa_abstain": true
    "tool": "web.fetch",
    "uq_ece": 0.052,
    "risk_score": 0.87,
    "gate": "policy.redaction",
    "run_id": "R-00213",
  "kv": {
  "msg": "prompt_injection_detected",
  "actor": "step:retriever",
  "span_id": "a2c…",
  "trace_id": "9b7…",
  "snapshot_id": "S-BF-09D",
  "level": "ERROR",
  "env": "prod",
  "service": "apoe.orchestrator",
  "ts": "2025-10-17T12:34:56.789Z",
{
Forensic log schema (normalized).
 embedded in every span/log, PII-safe redaction at ingress.
snapshot IDs
 time sync (NTP), 
Required invariants:
.
metrics, logs, traces, events
 (OpenTelemetry aligned): 
Four signals
26.1 Signal Surface & Ingestion
 (publish postmortem). Targets are declared per service.
MTTP
 (restore), 
MTTR
 (contain), 
MTTC
 (IC engaged), 
MTTI
 (detect), 
MTTD
Golden clocks.
 near-miss, anomaly only; create watch & experiment.
SEV-4
 limited scope; error budget burn detected.
SEV-3
 partial impact; degraded SLOs → guarded auto-remediation allowed.
SEV-2
 customer-visible outage or legal risk → HITL two-key required.
SEV-1
Severities.
 — stakeholder/customer comms.
Comms
 — maintains immutable timeline; exports post-hoc pack.
Scribe
 — curates VIF packets / SEG links in real time.
Witness
 — service owners, on-call engineers.
Resolver(s)
 — owns timeline & decisions.
Incident Commander (IC)
Roles.
26.0 Operating Model & Severity Taxonomy
 playbooks with κ-gating, canaries, and two-key approval where risk demands it.
ediation
autorem
, and 
Shared Evidence Graph (SEG)
—without violating SDF-CVF parity or compliance guarantees. This chapter defines the operating model, forensic pipeline, RCA methods over the 
decisions into controlled change
, and 
evidence into decisions
, 
telemetry into evidence
Aim. Turn 
Chapter 26. Ops & Incidents — Log Forensics, RCA with VIF/SEG, and Safe Autoremediation
Part X — Case Studies & Patterns
Rollback snapshot validated by replay.
SEG export pack generated and archived.
Acceptance gates green.
Before promote
SDF-CVF gates enabled (parity, tests, trace).
VIF wiring verified; snapshot IDs reserved.
Tool capability tokens scoped; sandboxes configured.
ACL plan compiled with budgets + κ thresholds.
HHNI prior art retrieved (RS≥0.75).
Before kickoff (all programs)
25.5 Checklists
decision:promote with attributes {risk_score, κ_count, gates_passed[], exceptions[ADR#]} pointing to claim:release_candidate and all supporting artifacts.
Decision record (SEG node).
 holds (code/docs/tags/traces in the same commit).
SDF-CVF parity
 shows unbroken lineage from sources to decision, with contradiction edges (not deletions) for changes, and
SEG
 complete at all plan boundaries,
VIF
 for the program type pass (above),
Gates
:
only if
A release can be promoted 
25.4 Release decision rubric (SEG-anchored)
 Audit pass rate 100%, ECE≤0.03, time-to-approve p95≤SLA, retention compliance 100%, incident MTTR≤24h.
KPIs.
 triage by risk; temporary throttling of intake with user messaging.
HITL backlog:
 quarantine batch, open incident, attach review notes to SEG, notify stakeholders.
Policy violation:
 run temperature sweep; re-fit calibrator; κ until ECE≤band.
Calibration drift:
Failure playbooks.
.
export pack built
, 
labels attached
, 
two-key approvals present
, 
violations=0
, 
f1≥min
, 
UQ calibrated
, 
Zero PII leakage
Acceptance gates.
Export pack bundles JSON-LD + logs + label manifests + retention schedule.
Time-sliced chain: source→sanitized→infer→verify→HITL→label→publish.
SEG & export.
Model/tool/prompt hashes; UQ vector summary; HITL approver IDs (pseudonymized); snapshot=S-CC-31B.
VIF.
provenance_labeler applied machine-readable synthetic content tags.
review_console two-key approvals=27; response p95 4m.
gold_eval f1=0.912≥min; violations=0.
pii_redactor leak.rate=0; 3 attempted exfil blocks logged.
Trace highlights.
 κ if ECE>0.03 or f1<policy.min; HITL mandatory for high-risk cases.
Budgets.
    out: vif_packet, seg_edges, export_pack
  step witness(role: witness)
    out: labeled_artifacts
    in: approvals
    tool: provenance_labeler
  step label_outputs(role: builder)
    gate: { two_key.approved }
    out: approvals, overrides
    in: eval_report, high_risk_cases
    tool: review_console
  step hitl(role: critic)
    gate: { f1 >= policy.min_f1 && violations == 0 }
    out: eval_report
    in: draft_labels, goldsets
    tool: gold_eval|rule_checker
  step verify(role: verifier)
    gate: { uq.calibrated && uq.ece <= 0.03 }
    out: draft_labels, uq_vector
    in: sanitized_stream
    tool: domain_model
  step infer(role: reasoner)
    gate: { leak.rate == 0 }
    out: sanitized_stream
    in: data_stream
    tool: pii_redactor
  step redact(role: operator)
  budget { tokens.max: 25k, tools.max_calls: 16, latency_ms.max: 300000 }
  input { policy_pack: compliance, goldsets: labeled, data_stream: source }
pipeline compliance_critical_v1
APOE plan (ACL)
Every artifact bears VIF + machine-readable labels; logs retained; SEG exports pass audit; two-key approvals recorded.
Success criteria.
Gold sets; redaction schemas; HITL roster.
Policy pack: EU AI Act mappings; retention rules; labeling requirements.
Inputs.
.
HITL
, labeling, retention, and 
mandatory logging
 (VIF/SEG), 
native auditability
 domain (e.g., medical coding, financial reporting) with 
high-risk
 Deliver/maintain a workflow in a 
Objectives.
25.3 Compliance-Critical Workflow — “Ship under regulation by design”
 Parity≥0.99, cost-delta≤−X%, p95 delta≤−Y%, CFR<8%, MTTR<1h (canary).
KPIs.
 revert micro-opt path; re-tune cache/window; adjust DB plan.
Perf regression:
 auto-patch with constrained code mods; if safety risk, HITL two-key.
Parity diffs:
Failure playbooks.
Perf/cost gates pass; VIF + snapshot replayable.
Golden trace coverage≥0.9; parity≥0.99 or ADR-backed exceptions.
Acceptance gates.
Edges derives from legacy endpoints → new handlers; contradiction edges retained for known, accepted behavior changes with ADR references.
SEG mapping.
Includes hashes for mined traces package; parity method; perf/cost tools versions; snapshot S-BF-09D.
VIF.
load_tester p95 ↓ 28%; cost_profiler infra cost ↓ 22%.
replay_runner parity 99.2% endpoints; 6 diffs quarantined.
 (RS.p50=0.79 to prior incidents).
golden traces
log_miner synthesized 1.2k 
Trace highlights.
 tokens.max=30k, κ on coverage.traces<0.9 or parity.ok=false.
Budgets.
  step witness(role: witness) -> vif, seg, release_candidate
    gate: { perf.p95 <= target && cost.delta <= -X% }
    out: perf_report, cost_report
    tool: load_tester|cost_profiler
  step perf_budget(role: operator)
    gate: { parity.ok }
    out: parity_report
    in: repo_modern, golden_traces
    tool: replay_runner
  step parity_tests(role: verifier)
    out: repo_modern
    in: repo_legacy, migration_plan
    tool: code_modder|scaffolder
  step refactor(role: builder)
    gate: { risk.total < 0.6 }
    out: migration_plan, risk_matrix
    in: inferred_spec, target_stack
  step propose_design(role: planner)
    gate: { coverage.traces >= 0.9 }
    out: inferred_spec, golden_traces
    tool: log_miner|schema_infer
  step mine_contracts(role: retriever)
  budget { tokens.max: 30k, tools.max_calls: 18, latency_ms.max: 600000 }
  input { repo_legacy: git, traffic_samples: traces, target_stack: template }
pipeline brownfield_refactor_v1
APOE plan (ACL)
; cost ↓ ≥ X%; p95 latency ↓; SEG shows old→new mapping.
trace-based tests
Behavior parity verified by 
Success criteria.
Legacy repo; prod logs; informal spec; error budget policy.
Inputs.
 parity, add tests, reduce cost/latency.
spec↔code
 Refactor legacy service without regressions; achieve 
Objectives.
25.2 Brownfield Refactor — “Stabilize, modernize, and keep parity”
 CFR<10%, MTTR<2h, RS-lift vs. baseline scaffold≥+0.05, preview replay fidelity=100%.
KPIs.
 quarantine branch; open ADR; require two-key.
Spec drift:
 parameterize codegen (smaller model tier), compress RAG k, or split PR.
Budget overrun:
 auto-generate unit/property tests; re-run; κ if still <target.
Coverage shortfall:
Failure playbooks.
 model/tool/prompt hashes + snapshot.
VIF present:
 latency/cost within declared budgets.
SLOs:
 ≥ target, zero critical failures.
Tests:
 blueprint sections tagged and reflected in code modules (SDF-CVF E-1).
Parity:
Acceptance gates.
}
  ]
    {"@id":"decision:promote_rc","type":"Decision","supports":["claim:release:rc-0.3"]}
    {"@id":"artifact:repo:b81c","type":"Artifact","supports":["source:blueprint:sha7e"]},
     "derivesFrom":["artifact:repo:b81c","metric:coverage:0.824","kpi:slo_ok"]},
    {"@id":"claim:release:rc-0.3","type":"Claim",
  "@graph": [
{
SEG slice (JSON-LD, release candidate).
model=apoe-compiler-02, weights.sha=…, prompt.sha=…, tools [scaffolder@1.6, codegen@3.1, test_runner@2.4, deployer@1.2], snapshot=S-GF-12A, uq={ece:0.018, var:0.009}.
VIF (summary).
: token spend 38% of cap.
budget_monitor
preview_deployer URL issued; 
test_runner coverage=82.4%≥target; p95 unit time 410ms.
project_scaffolder emitted repo@sha b81c…; CI seeded.
rag.query(HHNI) seeds prior patterns (RS.p50=0.81).
Trace highlights (OTel).
 tokens.max=45k, tools.max_calls=20, build wall=15 min. κ-abstain if completeness<0.95, coverage<target, or SLO breach.
Budgets.
    out: vif_packet, seg_edges, release_candidate
  step witness(role: witness)
    gate: { kpis.within_slo }
    out: kpis, drift_report
    tool: trace_collector|budget_monitor
  step observe(role: operator)
    out: preview_url, telemetry_sink
    in: pr_branch
    tool: preview_deployer
  step deploy_preview(role: operator)
    gate: { coverage >= target && fail_list.empty? }
    out: coverage_report, fail_list
    in: pr_branch
    tool: test_runner
  step tests(role: verifier)
    policy: spec_tags_required
    out: pr_branch
    in: repo, component_catalog
    tool: code_generator
  step codegen_iter(role: builder)
    gate: { license_compliance.ok }
    out: repo, ci_pipeline
    in: work_breakdown, domain_models
    tool: project_scaffolder
  step scaffold(role: builder)
    gate: { completeness >= 0.95 }
    out: work_breakdown, domain_models
    in: blueprint
  step decompose_spec(role: planner)
  budget { tokens.max: 45k, tools.max_calls: 20, latency_ms.max: 900000 }
  input { blueprint: yaml, policy_packs: [pii, license], env: cloud }
pipeline greenfield_v1
APOE plan (ACL)
All features in blueprint implementable; p95 build ≤ X min; test coverage ≥ Y%; preview URL + SEG lineage; rollback snapshot available.
Success criteria.
Component library constraints; cloud targets; cost/latency SLOs.
blueprint.yaml (features, non-functionals, data contracts, policy packs).
Inputs.
 builds.
replayable
 between spec↔code↔evidence and 
parity
 Take a structured blueprint → scaffold → code → test → deploy → observe, with 
Objectives.
25.1 Greenfield App — “From blueprint to running product”
, budgets, trace highlights, VIF/SEG artifacts, acceptance gates, failure playbooks, and KPIs.
ACL plan
 under memory-native retrieval (CMC/HHNI), compiled orchestration (APOE/ACL), verifiable lineage (VIF/SEG), and safe evolution (SDF-CVF). Each program includes: objectives, inputs, success criteria, 
software that ships
Aim. Show how AIMOS/APOE delivers 
(full APOE plans, budgets, and SEG-anchored release decisions)
Chapter 25. Builder Programs — Greenfield • Brownfield • Compliance-Critical
Part X — Case Studies & Patterns
Device diplomacy: QC passed; secrets contained; ECE within band.
Negotiation: Pareto set produced; risk<0.6 (or two-key).
Protocol translation: validator acceptance≥0.995; PII masked.
Acceptance gates (per case)
SEG export pack enabled for the final artifact.
VIF fields (model/prompt/index hashes) wired at each boundary.
Tool capability tokens scoped; sandbox policies active.
Plan budgets present; κ thresholds defined.
Prior mappings and policies retrieved (RS≥0.75).
Before running a new “machine-communication” integration
Checklists
: specs, code, tags, and traces change together—or not at all.
parity
 enforces 
SDF-CVF
—from a signed PDF back to a masked CSV; from a counteroffer back to API quotes; from a timeseries back to quarantined files.
auditable
 makes every artifact 
VIF/SEG
, not ad-hoc chats.
deterministic, budgeted plans
 compiles interactions into 
APOE/ACL
 history (mappings, quirks, policies).
retrievable
 keeps translation and negotiation grounded in 
CMC/HHNI
24.5 What this demonstrates
 (trace + SEG + VIF).
exemplar links
Case-specific tiles (acceptance, dominance, salvage) + 
Dashboards.
pii.masking.v5, capTok.carrier_ops.v3, airgap.unpack.v2, containment.strict.v1.
Policy packs.
ingest_device_airgap.acl — hostile-input plan with quarantine/contain.
negotiate_bids_v1.acl — multi-round mediator with dominance pruning.
translate_protocol_v2.acl — CSV/JSON/PDF chain with PII gates.
ACL templates (starters).
24.4 Reusable assets
 Salvage ratio≥0.85, QC pass rate≥0.98, zero exfiltration incidents, reproducible rebuild from SEG slice.
KPIs.
.
contain_only
 tool policy blocks; event logged; pipeline switches to 
Secret exfiltration attempt:
 if ECE>0.05, κ abstain from publishing; HITL required to approve provisional decoder with diff view.
Decoder hallucination risk:
Failure modes.
decision:qc.ok supports claim:timeseries.published.
contradicts edge to source:dat:9b17 (quarantine reason: YARA-sig-MQTTkey)
source:zip:4e9a → artifact:records:day=2025-09-28
SEG (time-sliced).
UQ for inferred decoders: ensemble.var=0.11, ECE=0.028 → confidence band displayed.
Tools with policy tags: safe_unzip[airgap], bin_decoder@0.3.
VIF.
seg.write: contradiction edges for quarantined file (recorded, not deleted).
metrics QC: gap rate 1.3% (<2% threshold).
; decoded 62% extra rows.
no outbound I/O
 on rejects with 
pattern mining
partial_parse used 
 applied; file quarantined, not parsed.
containment
fingerprint flagged 1 suspicious .dat (YARA rule hit) → 
Trace.
 unpack; no external calls during partial_parse.
air-gapped
 Constrained tools; 
Budgets.
  step witness(role: witness) -> vif, seg
    gate: { qc.passed }
    out: timeseries, qc_report
    in: records + partial_records
  step metrics(role: verifier)
    policy: no_external_calls
    out: provisional_decoders, partial_records
    in: rejects[], prior_decoders
  step partial_parse(role: reasoner)
    gate: { pii_redacted: true }
    out: records[], rejects[]
    in: file_list
    tool: csv_parser|bin_decoder
  step parse_known(role: builder)
    out: file_list
    tool: safe_unzip[airgap]
  step unpack(role: operator)
    gate: { risk.score < 0.4 || contain_only }
    out: manifest, risk.score
    tool: mime_sniffer|yara_scanner
  step fingerprint(role: operator)
  budget { tokens.max: 10k, tools.max_calls: 8, latency_ms.max: 3000 }
  input { archive: blob }
pipeline ingest_device_archive
APOE plan (hostile-input first)
 Max salvage; zero secret leakage; reproducible metrics; SEG time slicing so analysts can “rewind.”
Success criteria.
 Device blobs + data dictionary (sometimes stale).
Inputs.
.
time-sliced evidence
 and with 
without exfiltrating secrets
 Field sensors upload mixed archives (.zip with .bin, .csv, unknown .dat). Need: sanitize, parse partially, extract metrics, and publish a dashboard—
Scenario.
24.3 Case Study C — Device & File Diplomacy (sensor logs → safe analytics)
 Dominance pruning ratio≥0.5; cost within target±3%; κ true-positive abstention≥95% (only when needed).
KPIs.
 operator routes through cached spec; falls back to email template generator with VIF tag fallback.email.
API instability:
 to select compromise.
HITL two-key
 κ abstain with proposal set + 
Non-convergence:
Failure modes.
 retained to record declined offers (SEG design).
contradiction edges
Edges: supports, dominates, accepts, rejects, with timestamps; 
Nodes: offer:A#102, offer:B#88, counter:C#44, decision:bundle#Q4.
SEG slice (offer lineage).
Tool identities + capTok ids; tariffs snapshot id.
Model/weights/prompt hashes for reconcile step included; risk model version noted.
VIF essentials.
negotiate converged after 2 rounds; p95 roundtrip=620ms.
.
dominance_pruned=true
reconcile produced Pareto set size=4; 
operator made 7 signed calls (capTok ids recorded).
 (RS.p50=0.77).
carrier quirks
rag.query retrieved prior 
Trace highlights.
 tokens.max=18k, latency_ms.max=4500, tools.max_calls=9. κ abstain on risk.score≥0.8.
Budgets.
  step witness(role: witness) -> vif, seg
    gate: { risk.score < 0.6 || two_key_approved }
    policy: cap_tokens, pii_min
    in: counteroffers -> acceptances
    tool: http_client
  step negotiate(role: operator)
    gate: { dominance_pruned: true }
    out: pareto_front, counteroffers
    in: carrier_responses, penalties
  step reconcile(role: reasoner)
    budget { tools.max_calls: 9 }
    in: initial_offers -> carrier_responses
    tool: http_client[signed]
  step solicit_quotes(role: operator)
    gate: { coverage: >= 0.95 shipments }
    out: initial_offers
    in: norm_specs, shipments
  step generate_offers(role: planner)
  step normalize_specs(role: retriever) -> norm_specs
  budget { tokens.max: 18k, latency_ms.max: 4500 }
  input { carriers: [openapi: A,B,C], bundle: shipments }
pipeline negotiate_windows_v1
APOE plan (bidirectional protocol + bargaining)
.
auditable counteroffer tree
, cost ≤ target, and 
dominated-option pruning
 Feasible plan with 
Success criteria.
Shipment bundle (weights, origins, deadlines).
3 OpenAPI specs + policy clauses (penalties, PII rules).
Inputs.
 A logistics broker negotiates pickup windows among three carriers’ APIs with conflicting constraints (weight limits, blackout dates, surge pricing). AIMOS/APOE mediates a Pareto-feasible schedule.
Scenario.
24.2 Case Study B — Negotiation & Mediation (SLA slotting across constrained APIs)
 acceptance≥0.995, RS-lift vs. baseline KNN ≥ +0.06, p95 latency≤2.5s, cost p95 plan≤$0.98.
KPIs.
 increase batch size, reduce k in RAG, or route cheaper model for map_schema.
Cost spike:
 gate fails → auto-redact + re-validate; repeated failure quarantines branch.
PII leakage:
 validator rejects >0.5% → κ abstain + planner regenerates field_map from nearest prior mapping; HITL diff shown.
Schema drift:
Failure modes & playbooks.
}
  ]
      "hash": "sha256:7f21…", "piiMasking": "acct_number: last4" }
    { "@id": "source:csv:7f21", "type": "Source",
      "supports": ["source:csv:7f21"], "tool": "csv_to_json@2.1" },
    { "@id": "artifact:json_batch:7c1e", "type": "Artifact",
      "createdAt": "2025-10-17T12:03:11Z" },
      "derivesFrom": ["artifact:json_batch:7c1e", "metric:acceptance:0.9987"],
    { "@id": "claim:pdf:2025-09", "type": "Claim",
  "@graph": [
{
SEG lineage (JSON-LD slice)
uq: { ece: 0.014, ensemble.var: 0.007 }
snapshot.id: S-83A
inputs: { csv.sha256: 7f21…, openapi.sha256: 9b10… }
tools: [csv_sniffer@1.3, csv_to_json@2.1, openapi_validator@0.9, pdf_renderer@1.0]
prompt.template.hash: sha256:aa74…
weights.hash: sha256:edc1…
model.id: apoe-compiler-02
VIF (provenance packet, summary)
seg.write nodes=7 edges=9 (claim→source links)
tool.exec pdf_renderer pages=3
tool.exec openapi_validator acceptance=0.9987
tool.exec csv_to_json rows=50k egress=9.2MB
apoe.step map_schema tokens.in=1.9k UQ.cal=0.014
tool.exec csv_sniffer OK dialect=excel-semicolon
rag.query HHNI k=12 RS.p50=0.82 (found prior mappings, PII policy)
apoe.plan translate_ledger_v2 [lat=1780ms] attrs: snapshot.id=S-83A, policy.prefix=v5, budget.tokens.max=12000.
Trace (OTel excerpt)
 tokens.max=12k, latency_ms.max=2500, tools.max_calls=6. κ set to abstain if acceptance < 0.995 or UQ ECE>0.03.
Budgets (plan).
    out: vif_packet, seg_edges
  step witness(role: witness)
    out: summary_pdf
    in: json_batch, acceptance_metrics
    tool: pdf_renderer
  step render_pdf(role: builder)
    gate: { tests: acceptance >= 0.995 }
    out: acceptance_metrics
    in: json_batch, spec_ref
    tool: openapi_validator
  step validate(role: verifier)
    budget { tools.max_calls: 2 }
    out: json_batch
    in: field_map, pii_mask_rules
    tool: csv_to_json
  step transform(role: builder)
    gate: { policy: pii_masking, schema: openapi_conformance }
    out: field_map, pii_mask_rules
    in: dialect_report, spec_ref
  step map_schema(role: reasoner)
    budget { latency_ms.max: 150 }
    out: dialect_report
    tool: csv_sniffer
  step detect_dialect(role: retriever)
  budget { tokens.max: 12000, latency_ms.max: 2500, tools.max_calls: 6 }
  input { file: csv_blob, openapi: spec_ref }
pipeline translate_ledger_v2
APOE plan (ACL sketch)
Cost ≤ $0.02 per 1k rows; p95 latency ≤ 2.5s for 50k rows.
PII masked; SEG lineage resolvable from PDF to raw CSV.
Schema fidelity ≥ 99.5% rows accepted by API sandbox.
Success criteria.
Policy: mask acct_number except last 4; round totals to 2dp.
Target: REST /v2/transactions (OpenAPI v3).
User artifact: ledger_2025_09.csv (unknown dialect).
Inputs.
 A finance team uploads a monthly CSV ledger and needs a JSON batch for a RegTech API plus a signed PDF summary. Constraints: PII masking, schema drift handling, and reproducible outputs.
Scenario.
24.1 Case Study A — Protocol Translation (CSV ledger → JSON API → signed PDF)
 atomically (SDF-CVF gates).
Evolve
 SEG evidence →
Write
 the lineage (VIF) →
Witness
 with guarded tools →
Execute
 a typed plan with budgets →
Compile
 the right memories/specs (RS↑) →
Retrieve
All three reuse the same spine:
 hostile inputs, partial parses, capability tokens, and redaction by default.
Device & file diplomacy:
 structured bargaining under constraints; κ-aware abstention; HITL where risk>θ.
Negotiation & mediation:
 “speak both ways” across formats and APIs; preserve semantics and provenance.
Protocol translation:
24.0 Patterns at a glance
 and safe evolution (SDF-CVF). Each case provides: scenario, APOE plan, budgets, OpenTelemetry trace, VIF packet, SEG slice, failure modes, and playbooks.
memory-native retrieval (CMC/HHNI), compiled orchestration (APOE/ACL), verifiable lineage (VIF/SEG),
—bridging humans, documents, tools, and devices—with 
machine-communication system
Aim. Show AIMOS/APOE acting as a 
Chapter 24. Machine Communication — protocol translation, negotiation, device/file diplomacy (with traces, budgets, SEG lineage)
Part X — Case Studies & Patterns
: gate.verdict, abstain.kappa, redaction, quarantine, rollback, hitl.decision.
Logs
: tokens.in.total, tokens.out.total, latency.ms, rs.score, uq.confidence, cost.usd.*, abstain.count, tool.exec.count.
Metrics
: plan.id, step.role, budget.tokens.max, tokens.in/out, latency.ms, rs, uq, kappa, model.id, weights.hash, prompt.template.hash, index.snapshot.id, capTok.id.
Key attrs
: apoe.plan, apoe.step, cmc.write, cmc.read, rag.query, tool.exec, hitl.review, seg.write, governance.change.
Span names
23.8 Minimal reference (names & attributes)
MWMB alerting wired to runbooks; governance events logged.
SLIs defined & computed; SLOs published per plan class.
SLOs
Template/policy hashes pinned; diffs require two-key.
Weekly canary suite; ECE drift alarms.
Embedding & RS distribution monitors on; LIM sentinels active.
Drift & Rot
Cost forecasting vs. actual alerts enabled.
Admission control + graceful degradation configured.
Budgets declared in ACL for every step/plan.
Budgets & Cost
Tools carry capTok.id and sandbox policy labels.
Retrieval emits RS/IDS/DD; memory emits snapshot ids.
All APOE steps emit apoe.step spans with budgets & VIF hashes.
Instrumentation
23.7 Quick checklists
 at source (PII redaction), signed, and stored with retention policy.
privacy-scrubbed
Exports are 
: metrics snapshot, top offending traces, SEG lineage, and the exact VIF (model/prompt/index hashes).
attached export packs
Alerts open tickets with 
23.6 Alerts, tickets, and exports
 (OTel trace + SEG slice + VIF packet).
click-through to exemplars
Each tile supports 
Injection attempts vs. blocks, exfiltration prevented, redaction counts.
Safety
nDCG@10 over time, LIM sentinels, RS-lift vs. baseline (from Ch.22).
Retrieval
RS distribution vs. threshold, IDS trend, DD (dependency delta) histogram.
Steps waterfall (trace), tokens in/out stacked by role, κ boundaries hit.
Agent (Plan)
p95 latency, cost p95, success rate, κ coverage.
SLO tiles with burn-rate sparkline, error-budget remaining.
Top-level (Ops)
23.5 Dashboards & exemplars (what to ship)
Each action emits a governance.change event with SEG export.
 → escalate to containment profile: tool off, only retrieval + summarize, HITL mandatory.
Safety breach
 → pin model to last-known-good, roll back index snapshot, route to verifier-heavy plan.
Quality breach
 → raise κ (more abstentions), gate tool calls, enforce stricter soft budgets.
Cost breach
 → enable aggressive summarization, reduce k in RAG, switch model tier.
Latency breach
23.4.4 Runbooks (automations)
Tie alerts to runbooks with pre-approved mitigations.
Alert if
: 6 or 24 hours.
Slow
: 1 hour; 
Fast window
:
multi-window multi-burn (MWMB)
Use 
23.4.3 Burn-rate alerting (multi-window)
e.g., 0.5% of 30 days = 3h 36m downtime.
 for Availability:
Error budget
.
injection.block.rate ≥ 99.9%
Safety: 
.
median tokens/plan ≤ 9k
Cost: 
 (query class A).
p95 latency ≤ 2.5s
Performance: 
 on tier-A suites.
answer.accept.rate ≥ 80%
Quality: 
 monthly.
≥ 99.5%
Availability: 
23.4.2 SLOs & budgets (examples)
injection.block.rate, exfiltration.prevented.rate.
Safety
tokens.per.plan.median, cost.usd.per.plan.p95.
Cost
latency.ms.p95 per plan class; tool.exec.p95.
Performance
retrieval.ndcg.p95 by domain.
answer.accept.rate = plans passing acceptance tests (from Ch.22 gold sets).
Quality
plan.success.rate = OK plans / total (exclude κ-abstentions with reason=policy if within spec).
Availability
23.4.1 SLIs (service level indicators)
23.4 SLOs & error budgets
: rot.prompt → auto-create ADR stub & require HITL review.
Alert
: injection block rate ↓ while injection attempts ↑ → investigate.
Guardrail efficacy
: semantic distance > θ (embed-compare) → requires two-key approval.
Policy-prefix diff
 mismatch (prompt.template.hash) vs. approved registry → block in staging, warn in prod.
Template hash
23.3.3 Prompt-rot monitors (templates & policies)
: drift.behavior with VIF (model hash change?) and trace exemplars.
Alert
: step distribution (planner vs. retriever vs. verifier) changes (χ² test) → may indicate routing regression.
Action profile shift
: ECE delta > θ; triggers temperature re-fit.
UQ calibration drift
: weekly run of fixed gold sets; compare MAP/nDCG and κ coverage at same thresholds.
Canary suite deltas
23.3.2 Behavior drift (model & agent)
: drift.data with SEG slice listing affected indices/snapshots.
Alert
: p@k for mid-placement canaries (lost-in-the-middle probes).
LIM sentinel
: IDS (indexing depth score) mean/variance; drop indicates ingestion or tagging failure.
Index health
: KL-divergence of RS histograms between windows.
Distribution shift
per corpus; alarm when > θ.
: monitor centroid shift 
Embedding drift
23.3.1 Data drift (retrieval/memory)
 early—with lineage.
template rot
, and 
behavior drift
, 
data drift
: HHNI/DVNS, models, and prompts evolve. We detect 
Why
23.3 Drift & prompt-rot monitors
  route(HITL | cheaper_model)
  emit(abstain.kappa, reason="budget")
if tokens.used' > max:
  rerun(step, context')
  context' = compress(context, policy="dumbbell")
if tokens.used > soft:
Pseudocode
If max exceeded → abstain.kappa(budget) and escalate to hitl.review when configured.
 non-critical attachments (policy-aware).
Truncate
 to a cheaper model with higher κ (more abstention).
Route
 context (dumbbell compression) and retry once.
Summarize
If soft exceeded:
At run time
Static checks ensure budgets exist for every step; reject plan if missing.
At compile time (APOE)
23.2.3 Admission control & graceful degradation
Segment by tenant/domain; alert on 20% deviation.
Capacity planning (monthly)
Aggregate to cost.plan.usd. Emit to gauge cost.usd.current_hour and counter cost.usd.total.
Per step cost:
Let p_in, p_out be USD per 1K tokens for the model.id.
23.2.2 Cost model
Violation raises budget.exceeded event → see §23.2.3.
(default 1.1).
Sum of step budgets with headroom factor 
Per plan
    max_calls: 3
  tools:
    soft: 1800
    max: 2500
  latency_ms:
    backoff: summarize|truncate|route_smaller_model
    soft: 10000
    max: 12000
  tokens:
budget:
Per step
23.2.1 Budget objects (declared in ACL & enforced)
23.2 Token/latency budgets & costing
 at ingestion.
privacy-first redaction
: per compliance policy (see Part VIII): e.g., 6–12 months with 
Retention
: injection triggers, exfiltration blocks (include payload hashes, not raw content).
Security logs
: HITL actions, policy overrides, export pack creation.
Audit logs
 (JSON): inputs/outputs digests, κ decisions, redactions applied, gate verdicts.
Boundary logs
23.1.3 Logs (structured)
Attach trace_id exemplars to latency and cost histograms so outliers hyperlink to traces.
Exemplars
cost.usd.current_hour (derived; see §23.2).
index.size.documents, mem.snapshot.bytes.
budget.tokens.remaining (plan & step).
Gauges
uq.confidence (post-calibration).
rs.score (retrieval score distribution).
latency.ms{role|tool|retrieval} (p50/p90/p95/p99).
Histograms
abstain.count{kappa.reason} (low RS, high UQ, policy).
tool.exec.count{tool.name, outcome}.
tokens.in.total, tokens.out.total (by model.id, role, tenant).
Counters
23.1.2 Metrics (RED/USE + agent-specific)
Include seg.slice.id on any span that asserts/derives a claim.
 (model/prompt/index hashes) to every boundary span.
VIF ids
Use trace_id across spans; attach 
Correlation
Attr: nodes.count, edges.count, contradictions.count.
seg.write — evidence graph updates.
Attr: risk.score, two_key.required, approver.role, decision.
hitl.review — human approval steps.
Attr: tool.name, capTok.id, arguments.hash, egress.bytes, sandbox.policy.id.
tool.exec — sandboxed external call (browser, code runner, DB).
Attr: k, rs.mean, rs.p95, ids.mean, dd.mean, index.snapshot.id.
rag.query — HHNI/DVNS retrieval.
Attr: atoms.count, ids.depth, dd.delta, snapshot.id.
cmc.write / cmc.read — memory atomization/index I/O.
Status: OK|ERROR|ABSTAIN.
Events: gate.enter, gate.exit, abstain.kappa, redaction.applied, quarantine.start, rollback.
budget.tokens.max, budget.latency.ms.max, inputs.hash, prompt.template.hash, model.id, weights.hash.
 {planner|retriever|reasoner|verifier|builder|critic|operator|witness},
∈
Attr: step.id, step.role 
apoe.step — per step (role-typed).
Children (typical)
Attributes: plan.id, plan.version, snapshot.id, policy.prefix.version, kappa.operating_point, budget.tokens.max, budget.latency.ms.max.
apoe.plan — one per compiled plan execution (DAG).
Root
23.1.1 Trace model (span taxonomy)
23.1 OpenTelemetry for agents (traces, metrics, logs)
 → all alerts attach a SEG slice & VIF packet.
Detection without lineage is noise
 → enforced at compile-time (APOE) and run-time (gates).
Budgets are contracts
 → everything is observable.
Everything is a step
Principles
 (definitions, burn-rate alerts, runbooks).
SLOs & error budgets
 for data, behavior, and templates (with alerting).
Drift & prompt-rot monitors
 with admission control, backoff, and graceful degradation.
Token/latency/cost budgets
 spec for agents, memory, retrieval, and tools (spans, metrics, logs, exemplars).
OpenTelemetry (OTel)
A complete 
This chapter delivers
23.0 Scope & outcomes
 that enforces budgets, detects drift, and protects SLOs.
nervous system
. Observability is not a dashboard—it’s the 
traced, measured, and governed
: every plan, step, retrieval, tool call, HITL decision, and cost is 
production-grade sight
Aim. Give AIMOS/APOE 
Chapter 23. Observability & Costing — OpenTelemetry for agents, token/latency budgets, drift & prompt-rot monitors, SLOs and error budgets
Part IX — Evaluation, Benchmarks, & Observability
Attach SEG slice + VIF packet; archive export pack.
Review κ operating point vs. SLOs.
Compute deltas + CI; inspect outlier queries.
After running
Enable full VIF + OpenTelemetry.
Load gold/adversarial sets; confirm no contamination.
Freeze snapshots; warm caches; declare budgets & κ/UQ knobs.
Before running
22.10 Quick checklists
 (Part VIII) includes: metrics JSON, per-query traces, scorecards, and signatures.
Export pack
 with time-slice.
SEG
; graph written to 
VIF
Stored as 
.
κ/UQ settings
, 
seeds
, 
tools & CapTok profiles
, 
policy-prefix version
, 
index snapshot id
, 
prompt template hash
, 
weights hash
, 
Model id
Every run pins:
22.9 Reproducibility & export
VIF/SEG completeness ≥ 99% for all benchmark traces.
: no new leak class; injection block rate ≥ baseline.
Safety equal/better
.
RR ≤ 0.1
; 
BA ≥ 0.95
 on long-horizon suites; 
TS% non-degrading
 selective risk curve within SLO.
and
 (e.g., ≤ 0.03) 
ECE ≤ band
 (org-set, e.g., +0.02 nDCG per 1k tokens) with CI > 0.
Lift_eff ≥ θ
 only if:
may ship
A candidate retrieval/orchestration stack 
22.8 Promotion gates (ship/no-ship criteria)
 for audit.
VIF packet
 + 
SEG slice
Each KPI tile links to 
Safety: 0 leaks, 14 pre-execution blocks, 2 at-execution blocks
Determinism@seed: 0.82 Jaccard; Replay: 0.97
 (↑5.3); BA: 0.96; RR: 0.07 (↓)
78.4
TS%: 
Agent scorecard
Selective risk curve inside SLO band (95% CI)
 (from 0.061); Temperature: 0.74
0.028
ECE: 
0.072
; Error@κ*: 
0.83
Coverage at κ*: 
κ & calibration
Fail buckets reduced: “polysemy” −28%, “LIM-middle” −19%
: −6.5%
latency
: +3.2%; 
tokens/query
; 
0.81
p@3: 0.76 → 
 (CI [+0.026,+0.055]) vs. baseline
+0.041
nDCG@10: 
Retrieval scorecard (weekly)
22.7 Example scorecards (what “good” looks like)
 allowed only with pre-declared α-spending.
Sequential tests
 for multiple comps.
Benjamini–Hochberg
 for deltas; 
Paired bootstrap
Statistics
apoe.step, apoe.role, tokens.in/out, latency.ms, kappa, uconf, rs, gate.result.
 spans with attributes:
OpenTelemetry
 lineage; emits 
SEG
 per step; writes 
VIF
Logs 
.
budgets
 templates; enforces 
ACL plan
Consumes 
Runner
}
  "notes": {"jurisdiction":"EU", "pii":false}
  "acceptance_test": {"type":"regex|program|unit_tests", "spec":"..."},
  "gold": [{"doc_id":"...","grade":0|1|2}],
  "class": "one_hop|multi_hop|long_ctx|adversarial|coding|procedural",
  "query": "text",
  "query_id": "uuid",
{
Dataset schema
22.6 Benchmark harness & telemetry
.
counterfactual variants
; if uncertain, gate with 
train overlap
Hash gold materials; check 
Contamination checks
: numerical edge cases, unit conversions, date arithmetic.
Reasoning traps
: lexical traps, polysemy (“hot dog” vs “dog”).
Ambiguity
: conflicting instructions across time-slices.
Spec drift
: secret-echo canaries, connector abuse.
Exfiltration
: prompt smuggling, casing/encoding, indirect attack through retrieved docs.
Injection
Adversarial suites
: key facts in middle of ~50–200k tokens (LIM stress).
Long-context
: compile/test verdicts, coverage thresholds.
Coding
: “do X with tool Y” judged by outcome log.
Procedural
.
evidence linkage
 evaluated, only 
not
: requires 2–3 evidence items with chain-of-thought 
Multi-hop
: single-hop fact with citations.
Atomic Q&A
Gold sets (by domain)
22.5 Gold sets & adversarial suites
 per run + aggregates.
agent scorecard
Emit SEG graph; produce 
 (inputs, outputs, UQ, κ).
every boundary
Record 
, models, indices (VIF).
policy-prefix
Freeze 
Harness requirements
: browser, code exec, DB, vector search; injection probes embedded.
Tool-rich runs
: retrieval→reason→verify loops.
Multi-hop research/code
: evolving requirements, rolling memory (CMC snapshots).
Streamed tasks
Scenarios
: % traces that re-execute to same verdict.
Replay Rate
: % artifacts with complete VIF; 
Lineage Fidelity
: compare planned vs. executed steps (name+contract).
Step F1
: fraction of boundary gates abstained; false-abstain vs. true-abstain.
κ_chain
Trace-level metrics
: injection/exfiltration incidents caught (pre-execution) vs. blocked (at execution) vs. leaked.
Safety Outcomes
: approvals requested/granted; median time-to-merge.
HITL Utilization
: Jaccard similarity of step sequences under fixed seed/context.
Determinism (Det@seed)
: fraction of runs requiring auto-fix or quarantine.
Repair Rate (RR)
over tokens, time, tool calls.
: 
Budget Adherence (BA)
: pass/fail against verifiable acceptance tests (SEG decision nodes).
Task Success (TS%)
Core outcomes
 (DAGs) over time with tool calls, memory writes, and HITL gates.
APOE plans
Agents execute 
22.4 Long-horizon agent evaluation (streams & plans)
: tokens/latency vs. target at chosen κ.
Budget tile
: which method (ensemble, temp sweep), seed, κ thresholds (all in VIF).
UQ provenance tile
: ECE, diagram, temp parameter.
Calibration tile
: coverage, abstention precision/recall.
Abstention tile
Dashboard spec (tiles)
For binary answerability gates; track per domain/task.
Selective F1 / AUROC (optional)
.
pre/post temperature scaling
; show 
perfect calibration line
10–20 bins; overlay 
Reliability diagram
.
MaxCE
 and 
ECE@domain
Report 
:
and mean confidence 
; with accuracy 
into 
Bucket predicted confidences 
Expected Calibration Error (ECE)
: plot error vs. coverage as thresholds vary; choose operating point that meets SLOs.
Risk-coverage curve
.
 
Coverage
.
or 
The system abstains when 
Selective prediction (κ)
22.3 κ & calibration: abstention and reliability dashboards
 and safety metrics unchanged or better.
Lift_eff ≥ θ
Promote only if 
 (edges added/removed, RS distributions).
SEG diff
Emit 
Run B and C with identical queries, seeds, budgets.
 & model versions (VIF).
index snapshot
Freeze 
Protocol
 is exceeded.
cost headroom
 promote if CI crosses 0 or if 
not
Guardrail: do 
 over queries; report 95% CI.
paired bootstrap
Use 
Significance
from SLOs (ms ↔ token budget).
Choose 
:
Cost-normalized lift
; same for nDCG/MAP.
Δp@k = p@k(C) − p@k(B)
Lift metrics
(e.g., HHNI weights, DVNS forces).
 
candidate
and 
 
baseline
Define 
22.2 RS-lift: tying HHNI/DVNS to outcome & cost
 in SEG.
claim→evidence edges
: model id, index snapshot, RS parameters, and per-query ranked list with 
Retrieval VIF
Each run emits a 
Traceability
 (one-hop, multi-hop, long-context, adversarial).
query class
Always segment by 
 for multi-facet or graded relevance (legal, biomedical).
MAP/nDCG
 when “first hit fast” matters (tool routing).
MRR
 for answerable Q&A where 1–3 chunks suffice.
p@k
When to use what
,
With graded relevance 
nDCG@k (normalized Discounted Cumulative Gain)
Average Precision (AP) & MAP
be rank of first relevant item (∞ if none).
Let 
MRR (Mean Reciprocal Rank)
Recall@k (r@k)
Precision@k (p@k)
with per-item RS/score.
 
ranked list
, system returns 
have gold relevant set 
Let each query 
22.1 Retrieval metrics (definitions & usage)
 entries for replay.
VIF/SEG
: every metric point links to 
Show your work
: it’s better to say “I don’t know (κ)” than to be confidently wrong.
Calibrate or abstain
: judge retrieval first; judge wording second.
Relevance before eloquence
Principles
 for shipping.
promotion gates
Gold-set curation, adversarial suites, contamination checks, and 
 eval harness: success, budget adherence, repair rate, determinism, and safety outcomes.
long-horizon agent
A 
 dashboard spec (coverage vs. risk, reliability diagrams, selective prediction).
κ (kappa) & calibration
A 
.
token/latency cost
 protocol that ties HHNI/DVNS improvements to outcome deltas per unit 
RS-lift
 (p@k, recall@k, MRR, MAP, nDCG, ECE).
exact formulas
Metric definitions and 
What this chapter delivers
22.0 Scope & outcomes
 success under budgets—grounded in VIF/SEG so every score has a witness and a replay.
long-horizon agent
 measurements for (a) retrieval quality, (b) reasoning calibration and abstention, and (c) 
provable, repeatable
Aim. Establish 
Chapter 22. Retrieval & Reasoning Benchmarks — p@k, nDCG, RS-lift, κ/ECE dashboards, long-horizon agent evaluation
Part IX — Evaluation, Benchmarks, & Observability
Thought for 10s
ChatGPT said:
proceed Next (Part IX, Ch.22): Retrieval & Reasoning Benchmarks — p@k, nDCG, RS-lift, κ/ECE dashboards, long-horizon agent evaluation.
You said:
, who approved exceptions, and how it recovered.
show why
 When the system abstains, contains, or quarantines, it can 
Resilience with accountability.
.
executable controls
 Redaction, purpose tags, DP budgets, and retention policies are not documents; they’re 
Privacy by architecture.
.
time-sliced evidence graph
 and a 
replayable traces
 Auditors don’t just get PDFs—they get 
Pre-baked proof.
21.10 What this unlocks
Training & comms: transparency and user notices templated
License/SBOM policies set; SLSA/Sigstore in pipeline
Role catalogs & two-key approvers defined
Risk register owners assigned; review cadence in SEG
Org/process
Incident runbooks rehearsed (tabletop & live canaries)
Export pack CLI enabled; signatures verified in CI
DSAR/DSE flow exercised end-to-end; witness emitted
Retention policy engine with legal hold + erasure propagation
Purpose/consent tags mandatory; κ refuses incompatible reuse
Redaction at ingest; embeddings on redacted text; DP ledger active
VIF/SEG enabled on every APOE boundary; time-sliced graph API live
; sandbox profiles applied
CapTok
All tool calls require valid 
Policy-prefix signing enforced; template hashes in VIF
Platform wiring
21.9 Checklists (implementation quick start)
 service levels (e.g., compile ≤ X days, erase ≤ Y days) tracked as SLOs.
DSAR/DSE
 ≤ target band (e.g., 0.03) on evaluation sets.
ECE
 ≥ 99% for high-risk flows (no orphaned outputs).
Lineage completeness
Pass/Fail samples.
: SLIs for lineage completeness, κ-abstention precision, RS-lift stability, DP budget headroom, CapTok violation rate, DSAR/DSE latency.
In prod
: policy-pack lint; segregation tests; DP budget simulators; calibration (ECE) checks; adversarial corpora for jailbreak/SSRF/secret-echo.
Pre-deployment
21.8 Control verification — tests & monitoring
apoe export --scope high_risk --timeslice "2025-01-01..2025-03-31" --tenant acme --signed
Generation.
  signatures/            # package signing, key metadata
  incident_report/       # if applicable
  test_results/          # red-team suites, accuracy/calibration
  hitl_approvals.csv     # two-key records for high-risk actions
  consent_ledger.csv     # consents by subject/purpose
  dp_ledger.csv          # epsilon/delta consumption
  sbom/                  # supply chain attestations (SLSA, sigstore)
  risk_register.json     # risks, owners, reviews
  seg_graph.jsonld       # time-sliced evidence graph
  vif_traces.ndjson      # step-by-step plan witnesses
  data_sheets/           # sources, redaction/DP config
  model_card.json        # model/weights/prompt template hashes
  policy_prefix.txt      # signed templates in force
  manifest.json          # hash tree, versions, scope
/export_pack_YYYYMMDDTHHMMZ/
Structure.
21.7 Export packs (one-click audit bundles)
Respect jurisdictional windows (e.g., privacy laws often require notification without undue delay; coordinate with counsel).
 (below) with incident timeline, affected data categories, mitigation, and contact.
regulatory pack
Generate 
Notification.
; retest with red-team suites; gradually unquarantine.
SDF-CVF
Patch/rollback via 
Eradication & recovery.
 on relevant SEG nodes; snapshot state.
legal hold
Place 
 (read-only, no tool writes).
quarantine mode
Freeze affected connectors/models (feature flag); force 
Containment.
Classify severity (S1–S4), scope (tenants, data classes), and regulatory touchpoints (privacy breach vs. robustness issue).
Triage.
“secret echo” traps in RAG corpora.
;
egress anomalies
, 
UQ drifts
, 
κ spikes
anomaly detectors on 
 exercise tools periodically;
Canary agents
Detection.
 (harmful/biased/unsafe outputs or decision flows).
Model incidents
 (confidentiality/integrity/availability) and 
Security incidents
Two classes: 
21.6 Incident response & notifications
: queries, objects affected, timestamps, operator identity.
DSAR/DSE VIF
: Produce 
Prove
: Apply cryptographic deletion to vaulted PII + cascade; retain minimal non-identifying audit lineage.
Erase
: sources, uses, recipients, retention, decisions affecting the subject.
subject bundle
: Export 
Compile
: Query SEG across time-slices for subject identifiers and their pseudonymous joins.
Locate
Data Subject Access Request (DSAR) & Erasure (DSE).
: issuance, scope, expiry, withdrawal.
SEG
Consent ledger in 
 ("support", "analytics", "training", etc.). κ-gating refuses incompatible reuse.
purpose tag
Every plan step carries a 
Consent & purpose.
21.5 Privacy UX & data subject operations
 events.
“hold-placed/released”
 or 
SEG “erasure”
 runs daily; emits 
Retention executor
; pointers to vaulted originals under strict scopes.
redacted embeddings
 stores 
HHNI
 tags PII, purpose, consent, and jurisdiction.
CMC ingest
Lifecycle hooks.
  propagate: "graph"                    # cascade to derived artifacts unless purpose-limited
  strategy:  "cryptographic tombstone"  # delete keys, preserve non-identifying lineage
erasure:
    override:  { ttl_days: 30, dp: { epsilon: 1.0, delta: 1e-6 } }
  - condition: { contains_pii: true, purpose: "analytics" }
    override:  { ttl_days: null }       # no expiry until cleared
  - condition: { legal_hold: true }     # incident or litigation
exceptions:
  storage_class: WORM    # immutability for audit logs
  ttl_days: 190          # configurable by tenant/jurisdiction
defaults:
  seg_types: [ "vif:event", "tool:egress", "decision", "claim", "snapshot" ]
scope:
policy_id: rp-default-highrisk-v3
Policy model.
 bound to SEG types.
Retention Policies (RP)
 Satisfy “keep only what you must; prove what you kept; delete when you can.” We encode this in 
Goals.
21.4 Retention vs. minimization — policies as code
.
telemetry → SEG → ADRs
Monitoring & improvement → 
 linked to systems.
SEG dossiers
Impact assessments (AIA/RAI) → store as 
 with owners and review cadence.
SEG risk nodes
Risk registers → 
 (AI management): governance across lifecycle:
ISO/IEC 42001
 (21.5).
subject-access/erasure flows
Data subject rights → 
; redaction at ingest.
DP
 + 
retention policies
Minimization & retention → 
 enforcement.
κ
 + 
purpose tags
Lawful basis & purpose limitation → 
 (PIMS): link privacy principles to mechanisms:
ISO/IEC 27701
.
SBOM
 gates, 
test coverage
 gates, 
SDF-CVF
A.14 SDLC → 
, egress allowlists, backups of snapshots.
tool sandboxes
A.12 ops security → 
 (models, data sets, connectors).
SEG inventories
A.8 asset mgmt → 
, role catalogs, segregation of duties (HITL).
policy-prefix signing
A.5 organizational controls → 
 (ISMS): map Annex A controls to guardrails and ops:
ISO/IEC 27001
21.3 ISO mappings (27001/27701/42001)
 (21.5)
data subject flows
 on queries; 
purpose tags
 nodes; 
Consent ledger
Collection/use/disclosure aligned to purpose
Privacy
, encryption at rest/in transit; RAG store separation
DP
, 
Redaction
Protect sensitive info end-to-end
Confidentiality
 reproducible traces
VIF
 on policy/UQ failures; 
κ abstention
 plans + budgets; 
APOE
Accurate, timely, authorized processing
Processing integrity
 service health nodes
SEG
; 
incident runbooks
 + error budgets; 
SLOs
Uptime, capacity, incident response
Availability
 access events
SEG
; 
SBOM/SLSA
 gated changes; 
SDF-CVF
 capability tokens; 
ACL
Access control, change mgmt, secure SDLC
Security
Evidence in AIMOS/APOE
Control focus
SOC 2 TSC
21.2 SOC 2 — Trust Services Criteria mapping
 (21.4) to set per-tenant, per-artifact TTLs and legal holds. (When in doubt, keep logs only as long as necessary for the declared purpose and regulatory duty.)
SEG retention policies
 Where law or sector rules prescribe log retention, use 
Retention note.
 incident graph; exportable notifications
SEG
 (21.6); 
Incident flows
Detect/triage/report harmful events
Post-market monitoring & incident reporting
 evals
Stream/long-horizon
 dashboards; 
RS/QS
 metrics; 
UQ/ECE
Measure, calibrate, and watch drift
Accuracy & performance monitoring
 + sandboxes
CapTok
; 
canary agents
 (Ch.20), red-team suites; 
Guardrails
Resist injection/SSRF/exfiltration; test for failures
Robustness & cybersecurity
quarantine mode
 two-key approvals; 
HITL
: κ-gating → abstain/contain; 
ACL
Enable intervention, overrides, and fail-safes
Human oversight
 signed
policy-prefix
 embeds generator metadata; 
VIF
: “AI-generated” affordance; 
Render layer
Notify users of AI use; label synthetic content
Transparency
 time-slicing; signed snapshots; capability-token logs
SEG
 events for every step; 
VIF
Maintain traceable logs of decisions and model/tool usage
Record-keeping / logging
Export packs
: model id, weights hash, prompt template hash; 
VIF
: atomic commits across code/docs/tests; 
SDF-CVF
Keep up-to-date specs, model cards, data sheets, test evidence
Technical documentation
 for high-risk plans
HITL
: data lineage (sources, redactions, DP ε/δ); 
CMC
: risk register nodes; 
SEG
Identify use-case risk, validate data quality, track shifts
Risk management & data governance
AIMOS/APOE mechanism
What it means in practice
EU AI Act obligation (concept)
 to concrete system levers. Use export packs (21.7) to assemble regulator-ready bundles.
recurring obligations
We avoid article-by-article replication and instead bind 
21.1 EU AI Act — control objectives → platform mappings
 that the platform satisfies with built-in mechanisms: VIF provenance, SEG lineage, κ-gating/abstention, HITL, DP/redaction, and guardrails-as-code.
design constraints
 families (27001/27701/42001). We treat them as 
ISO
 (Trust Services Criteria), and 
SOC 2
 (risk-based duties), 
EU AI Act
This chapter operationalizes common obligations from the 
21.0 Scope & stance (not legal advice)
 for export, replay, and audit.
Shared Evidence Graph (SEG)
, and every artifact and handshake lands in the 
witness (VIF)
, every decision is a 
plan step (APOE)
. Every control is a 
provable-by-construction
Aim. Make compliance 
Chapter 21. Compliance Engineering — mapping EU AI Act/SOC2/ISO to VIF/SEG artifacts, retention vs. minimization, and incident response
Part VIII — Security, Safety, & Compliance
, not an afterthought.
first-class capability
 (SEG) and security as a 
evidence as a graph
 without drift (SDF-CVF)—because the substrate treats 
evolves
 every decision (VIF), and 
witnesses
 within declared limits (APOE), 
orchestrates
 safely (CMC), 
remembers
Agentic power without fear: a system that 
What this chapter unlocks.
SEG wiring for all guardrail events; export hooks for audits
Canary agents and red-team suites in CI/CD
κ-gating wired to UQ, detectors, and cost/latency budgets
DP budgets configured; SEG logging for ε/δ consumption
 render paths
and
PII/secret classifiers on write 
Per-tool sandbox profiles (fs, syscalls, CPU/mem/time)
Capability tokens with short TTL and minimal scopes
URL normalizer + egress allowlist proxy for all outbound tools
Quoted boxing of all untrusted content; taint propagated in ACL
Signed policy prelude in every chain (template hash + signer)
20.11 Implementation quick checklist
Raise τ or widen cohort; route to aggregated-only mode
Mis-scoped aggregation
DP budget exhaustion
Re-issue runtimes, revoke keys, replay traces, HITL review
Tool wrapper drift or compromised agent
Repeated CapTok violations
Shadow-mode compare, adjust thresholds, add test to allowlist corpus
Over-eager detector
Legit request blocked (FP)
Freeze high-risk tools, rotate templates, audit SEG for unsigned runs
Missing policy-prefix or signature not verified
Silent policy bypass
Runbook
Likely Cause
Failure
20.10 Failure modes & runbooks
: 0 per month.
DP budget breaches
: ≥ 0.9 (true-positive abstains / total abstains).
Abstention precision
: 0 in prod; canary only.
Secret echo rate
: ≤ 0.1% per 10k tool calls; MTTR < 15m.
CapTok violations
: 100% of private/IMDS probes blocked in canary.
SSRF prevented
 ≤ 2%.
false-positive
 ≥ 99% on test corpora; 
Injection block rate
20.9 KPIs & SLOs for security posture
 with time windows. Compliance packs (Ch.21) export them into audit bundles.
SEG edges
These are 
 (κ, reason, suggested next).
abstain/contain
 (ε, δ, scope),
dp_consume
 (strategy, fields),
redaction_event
 (dest, bytes, allow/deny),
egress_request
 (claims, TTL),
cap_tok_granted/denied
 (template hash, signer),
policy_prefix_signed
:
witnesses
Every guardrail emits 
20.8 Observability & evidence (VIF/SEG)
HITL escalation on high-risk plans
UQ + ECE bands + κ
Overconfidence
Dependency pinning; provenance checks
SBOM + license allowlist + SLSA
Supply-chain poison
Sandbox syscall/network filters
CapTok (scope/TTL/rate)
Tool overreach
DP budgets; vector co-location w/ redacted content
PII/secret classifiers + redaction
Secret exfiltration
DNS/SNI checks, SEG logging
URL normalizer + egress allowlist proxy
SSRF via URL tool
Content disinfect + provenance
Data-only treatment of retrieved text
RAG-borne instruction
Detector ensemble + κ
Quoted boxing + policy-prefix signing
Prompt injection (direct/indirect)
Secondary
Primary Control
Threat
20.7 Threat → Control crosswalk
 look for odd patterns: tool burst w/o CapTok, egress to new host, steady κ evasion.
SEG queries
 for new guardrails (score only) before flip to block.
Shadow mode
 exercise tools hourly with harmless probes; anomalies → page.
Canary agents
In prod.
 CSP, OPA/Rego unit tests, license/SBOM checks.
Policy pack lint:
 surface.
never
 known canaries planted in RAG sources must 
Secret echos:
 private IPs, IMDS probes, DNS rebinding tests.
SSRF suite:
 curated jailbreaks + content smuggling corpora.
Injection suite:
Pre-merge gates.
20.6 Tests, red teams, and continuous verification
.
HITL incident runbook
Repeated breaker trips escalate to 
 variant.
safe plan
Token/latency/cost outliers → trip breakers; APOE rolls back to 
Circuit breakers.
 run on frozen snapshot with synthetic data.
Air-gapped chain:
 disable write tools; restrict connectors.
Read-only RAG:
 simulate plan without side effects; produce diffs only.
Quarantine execution:
Containment modes.
: violated gates, minimal viable suggestions, request for narrower scope.
refusal diagnostic
 A structured 
What to return.
UQ high (ECE band breach), RS low, policy conflict, or privacy budget exhausted.
When to abstain.
20.5 Abstention & containment patterns
 store (ε, δ, mech, scope). Exceeding budget → κ-abstain.
SEG nodes
 for metrics dashboards; Laplace/Gaussian noise; ECE calibration unaffected.
Report DP
 for telemetry; ε budgets per tenant/user/feature; decay (τ) resets.
Event DP
20.4.2 Differential Privacy (DP)
Deterministic hashes for joinability (hash(email, pepper)), reversible tokens in secure contexts, or DP-protected aggregates for analytics.
Mask formats.
: re-apply redaction by audience/purpose; attach VIF explaining masks.
Render
 content; SEG retains reversible link under policy.
redacted
: embeddings computed on 
Index (HHNI)
 secrets/PII; store pointer to vaulted original (KMS-wrapped).
mask
: classify and 
Ingest (CMC)
20.4.1 Multi-stage redaction
20.4 Redaction, DP, and output hygiene
; DNS pinned; TLS cert pinning optional.
egress allowlist
Explicit 
No shell, no child process, no write, no outbound by default.
Least power defaults.
Tool outputs are labeled with cap_id for downstream audit.
 with packet metadata (no payloads with PII).
SEG “violation” edges
Violations raise 
Sidecar intercepts all syscalls/network; matches against CapTok.
Runtime enforcement.
exp (TTL ≤ minutes), aud (tool runtime), jti (replay).
sub (plan_id/step_id), act (Verb), res (Resource pattern), lim (rate/size),
 with claims:
signed JWT/JWP
 A CapTok is a 
Design.
20.3 Tool sandboxes & capability tokens (CapTok)
 (Ch.17) for two-key approval.
routes to HITL
 by downgrading capabilities (read-only tools, masked output), or
contains
 with rationale + remediation link, or
abstains
At each boundary, compute risk = f(injection_score, PII_score, UQ, budget_drift). If risk ≥ κ, the system:
20.2.2 κ-gating & abstention
  checks { scheme in ["https"], host not_in private_ranges, port in [443] }
gate g_url_safe
SSRF defense for URL tools
  gate { g_injection_scan, g_policy_prefix_signed, g_kappa_band }
  policy { taint: ["retrieved"], quote_untrusted:true, policy_prefix: "seg://policy/answering@v3" }
  in  { query, retrieved[] }
step synthesize_answer
Prompt hygiene & tainting
  gate { g_path_allow, g_span_vif }
  sandbox { fs:"ro", chroot:"/workspace", syscalls_deny:["execve","mount"] }
  caps { action:"READ", paths:["/workspace/specs/*.md"], max_bytes:1e6 }
tool file_read
  gate { g_url_safe, g_egress_allowed, g_span_vif }
  sandbox { net_egress:["docs.example.com:443"], fs:"ro", cpu_ms:2000, mem_mb:256, timeout_ms:3000 }
  caps { action:"GET", hosts:["docs.example.com"], rate:"60/m", max_bytes:5e6 }
tool http_fetch
Capability tokens & sandboxes
20.2.1 ACL snippets
 events (Ch.14).
witness
 levels. All checks emit 
tool
, and 
step
, 
plan
We encode guardrails at 
20.2 Guardrails-as-code (enforced by APOE/ACL)
 short-lived OIDC tokens from KMS; zero plaintext secrets in env/logs.
CI secrets broker:
 enforce banned APIs, dangerous patterns (eval, spawn) in codegen.
Policy packs
/SLSA provenance on artifacts.
sigstore
 gates; 
SBOM + license allowlist
Controls.
 Malicious packages, typosquatting, poisoned snippets, license traps; CI secret exposure.
Vectors.
20.1.5 Supply chain & codegen
 watermark/model tags for generated content (VIF).
Synthetic labeling:
 variants; linkage via SEG only.
redacted/hashed
 PII on RLS-protected tables; vector store contains 
Segregated stores:
 with decay τ.
ε/δ budgets
 for analytics/telemetry; per-tenant 
Differential Privacy (DP)
 (regex+ML) in write paths (CMC ingest) and read paths (render).
PII/secret classifiers
Controls.
 Model answers echo secrets; embeddings store PII; logs leak tokens; oversharing to third parties.
Vectors.
20.1.4 Data exfiltration & privacy
 single trusted resolver; cache poisoning mitigations; SNI/ALPN checks.
DNS hardening:
 per-tool egress via proxy with hostname pinning, TLS enforcement, and request recording into SEG.
Egress policy:
 reject non-HTTP(S), IP literals, link-local, or private RFC1918 addresses unless explicitly allowed.
URL normalizer:
Controls.
 URL fetch tools pointed at metadata endpoints, internal services, cloud IMDS; DNS rebinding; IPv6 literals; file://, gopher://.
Vectors.
20.1.3 Network & SSRF threats
 only.
inputs
; they cannot alter policy. APOE treats RAG outputs as 
data
 retrieved snippets are 
Result boxing:
 (strip scripts/links) before inclusion.
content disinfect
 per-connector hostname/tenant allowlists; MIME/type guards; 
RAG allow+deny lists:
, read-only FS, CPU/mem/time quotas, and syscall filters.
network egress allowlists
 per-tool containers with 
Tool sandboxes:
 signed, short-lived, scoped (action, resource, rate, region).
Capability tokens (CapTok):
Controls.
 Calls to arbitrary hosts, filesystem traversal, credentials in responses, “phantom” tool execs.
Symptoms.
 Over-permissive tools, TOCTOU races, SSRF via URL tools, unlimited file I/O, secret leakage from vector stores, prompt injection through retrieved docs.
Vectors.
20.1.2 Tooling & RAG threats
 pattern + LM-based detectors score “instructionality,” HTML/script payloads, and known jailbreaks; raise κ or strip.
Detector ensemble:
 a signed policy prelude (template hash + SEG id) precedes all chains.
Policy-prefix pinning:
 executed as instruction.
never
 and 
verbatim fences + provenance tags
 untrusted text is wrapped with 
Quoted-content boxing:
 and stored; only system prompt may set policy.
separately hashed
 system vs. user vs. tool prompts are 
Role isolation:
Controls.
citations.
 Role leakage; tool misuse; non-deterministic replies; policy bypass in 
Symptoms.
 Classic prompt injection (direct/indirect), instruction smuggling in HTML/Markdown/CSV/ALT text, jailbreak patterns, overlong-context poisoning, retrieval booby-traps (“ignore previous; exfiltrate X”).
Vectors.
20.1.1 Prompt- & context-level threats
 controls.
➜
 symptoms 
➜
. Each entry lists typical attacks 
goal
 and 
surface
We profile threats by 
20.1 Threat model for agentic systems
 (least-privilege sandbox), not “best-guess.”
contain
 (κ-gating) or 
abstain
 When in doubt, 
Degrade safely.
 ACL/APOE plans are statically checked; high-risk steps require HITL (Ch.17).
Plan before power.
 All user/content/context is tainted until proven otherwise.
Untrusted by construction.
 with scope, duration, and rate.
granted
 and 
requested
 Capabilities are 
Deny by default.
20.0 Security doctrine (tl;dr)
 so we can prove what the system did, why, and under which risk posture.
Shared Evidence Graph (SEG)
 and connects to the 
witnesses (VIF)
 that hold under real workloads: RAG, agents, tools, IDE-in-the-loop. Every control emits 
guardrails-as-code
 threat model for AIMOS/APOE and install 
practical, enforceable
 Define a 
Aim.
Chapter 20. Threat Model & Guardrails — injection/exfiltration/SSRF patterns, tool sandboxes, capability tokens, DP/redaction, abstention/containment
Part VIII — Security, Safety, & Compliance
.
Shared Evidence Graph
 whose cost, energy, and risk are explicitly budgeted and continuously proven in the 
installs a governed system
 already wired. APOE no longer “generates code”; it 
guardrails, gates, and evidence
—UI, API, Auth, Data—arrives with 
every component
 path from blueprint to production where 
disciplined, repeatable
A 
19.12 What this unlocks
VIF minimums pack; CI fails on missing provenance
Audit gaps
Unlogged actions
Residency pack with RLS + region-pinned buckets; policy tests
Data in wrong region
Residency breach
HHNI compaction; top-k truncation; budget gates
Cost overrun
Token bloat
Secrets pack scanners block; KMS-only access; redaction filters
CI logs with tokens
Secret leakage
ORM tracing + query plans; generated DataLoader; perf refactor gate
Slow endpoints under load
N+1 queries
Contract tests block; codemods on spec change; parity gate
4xx/5xx spikes post-merge
API drift
SSR parity tests; strict ESLint rules; g_perf_web blocks
Blank/flash on route
UI hydration mismatch
Countermeasure
Symptom
Failure
19.11 Failure Modes & Countermeasures
All KPIs are exported as metrics + SEG nodes with time windows (for audit packs).
: ≥ 99% spans tagged with plan_id & snapshot_id.
Evidence
: kWh within budget.
Energy
: variance to projection ≤ 10%; 
Cost
: migration success 100% in preview; rollback P50 < 2 min.
Data
: login p95 ≤ 400ms; token issuance failure < 0.1%.
Auth
: p95 latency ≤ blueprint target; error rate ≤ 0.5%.
API
: LCP P75 ≤ 2.5s, CLS P75 ≤ 0.1, INP P75 ≤ 200ms.
UI
19.10 KPIs & SLOs
 budget gates.
energy/cost
Add GPU inference workers under 
 interface.
RAG Adapter
Plug alternative vector stores behind 
 gate.
contract equivalence
Swap REST↔GraphQL behind 
Extension points (guarded).
: OpenTelemetry → SEG links everywhere.
Observability
: Postgres + dbt + Warehouse; CDC → event bus.
Data
: OIDC (PKCE) + OPA policies.
Auth
: NestJS + OpenAPI + Prisma + Postgres (pgvector optional).
API
: Next.js + Tailwind + shadcn → Playwright + Lighthouse.
Web
Golden paths (opinionated defaults).
19.9 Golden Paths & Extension Points
Lower-rate regions for CI; canary duration caps; adaptive sampling for telemetry.
 (pgvector).
vector co-location
Cache hits (retrieval/page cache) and 
Prompt compaction (HHNI dumbbell compression).
Optimization levers.
 step.
optimize-or-abstain
g_energy: kWh & CO₂e under thresholds; if not, trigger 
g_cost_actual: actual cost within ×(1+ε) of projection (ε default 10%).
g_cost_plan: projected plan cost ≤ budget (fail fast pre-run).
Gates.
: kWh = Σ (power_W / 1000 * hours), CO₂e = kWh * grid_intensity_kg_per_kWh / 1000
Energy
: C_storage = Σ (rate_tier_gb * GB_month)
Storage
: C_compute = Σ (rate_cpu*h_cpu + rate_gpu*h_gpu)
Compute
: C_tokens = Σ (rate_model_i * tokens_i)
Token cost
Estimation formulas.
    co2e_tonnes_max: 0.02
    kwh_month: 45
  energy:
  network_gb: 100
    cold: 200
    hot: 50
  storage_gb_month:
    gpu_hours: 0
    ci_minutes: 60
  compute:
    per_plan: 1.2e6
    per_call: 16000
  tokens:
budgets:
Budget DSL (embedded in blueprint).
: kWh and CO₂e per stage.
Energy/Carbon
: egress GB, third-party API calls.
Network
: GB-months for DB/object/SEG/vector.
Storage
: CPU/GPU minutes for CI, inference, training.
Compute
 (LLM/RAG): input/output tokens per step/plan.
Tokens
Budget classes.
19.8 Cost & Energy Budgets (governed spend)
  gate { g_webhook_sig, g_idempotency, g_observe_spans }
  policy { signatures:"ed25519", idempotency:true, retry: "expo<5x" }
  tool "adapter.scaffold"
  out { webhook_handler }
  in  { provider_adapter }
step secure_webhooks
  gate { g_openapi_valid, g_license_allow }
  tool "contract.codegen"
  out { sdk_pkg, provider_adapter, contract_tests }
  in  { openapi_spec:"providers/stripe.yaml" }
step integrate_payments
ACL example — adding a payment provider.
: Server-Sent Events or WebSockets gated by policy pack; redact on the fly if PII.
Streaming
 (source URI, digest, access policy).
VIF capture
: retrieval adapters (files, DBs, wikis) with 
RAG connectors
: outbox pattern with transactional writes; retries with DLQ and observability tags.
Events & Sagas
: signature verification (HMAC/Ed25519), idempotency, replay protection.
Inbound webhooks
 (scoped, expiring).
Capability Tokens
 (HTTP/gRPC SDKs): generated from contracts; all calls go through 
Outbound adapters
Patterns.
19.7 Integration Patterns (Ports & Adapters)
 (rules + scanners + CI jobs). APOE attaches packs from the blueprint, then scaffolds their enforcement points.
declarative bundles
Packs are 
g_retention, g_rtbf_hooks
Time-boxed logs; SEG export redaction hooks
Retention & Right-to-Forget
g_vif_min
VIF minimums (model ID, weights hash, prompt template)
LLMOps Logging
g_prompt_guard, g_synth_label
Injection filters, tool-capability tokens, output watermarking
Prompt Safety
g_secret_leak, g_key_rotation
No plaintext secrets; KMS usage; rotation schedule
Secrets & Keys
g_license_allow
Allowlist (MIT/Apache/BSD), deny GPL-copyleft by default
Open-Source Licenses
g_pii_map, g_residency, g_rls_required
PII taxonomy, field-level redaction, region-pinned storage
PII & Residency
g_csp, g_slsa, g_vuln_budget
TLS, HSTS, CSP, dependency vulns (SLSA/SBOM)
Security-Basics
Gates
What it enforces
Pack
19.6 Policy Packs (snap-in compliance)
. Any deviation → g_template_integrity fails.
snapshot_id
template.lock.json records: template IDs, commit hashes, toolchain versions, blueprint hash, and 
Template witnesses.
└─ docs/              # ADRs, blueprints, runbooks
 .github/workflows/ # CI/CD
─
├
 policies/          # OPA/Cedar, license allowlist, PII redaction maps
─
├
 infra/             # IaC (Terraform/Pulumi), pipelines
─
├
│  └─ schema/         # zod/openapi/graph types
 ui/             # shared components
─
├
│  
 packages/
─
├
│  └─ api/            # FastAPI or NestJS
 services/
─
├
│  └─ worker/         # background tasks
 web/            # Next.js
─
├
│  
 apps/
─
├
.
Repository skeleton (monorepo).
19.5 Template Catalog (Golden Paths)
g_data_retention: retention policies match blueprint jurisdiction; verify in CI.
g_migrations_reversible: up/down integrity; destructive ops gated by HITL.
g_rls_required: tables with PII must have RLS ON; tests verify denial by default.
Gates.
 with time-slicing.
Neo4j
 or 
Neptune/Neptune-like
: RDF/JSON-LD in 
SEG store
 (co-located embeddings) for small/mid; external vector store optional.
pgvector
Vector & Evidence.
 models; lineage exported to SEG (model ↔ query ↔ decision).
dbt
ETL: 
 (program-choice).
Snowflake
/
BigQuery
Warehouse: 
Analytical.
 → event bus (for analytics/ELT or sagas).
Debezium
CDC: 
 migrations; content-addressed migration files.
Liquibase
/
Prisma
Schema: 
.
RLS
 + 
pgcrypto
 with 
PostgreSQL 15+
Transactional.
19.4 Canonical Data Stack
g_secret_leak: zero findings from secret scanners; SBOM free of banned licenses.
g_policy_eval: policy pack validation on all protected routes (OPA unit tests).
g_auth_lat: p95 login < 400ms in target regions.
Gates (blocking).
Secrets: sealed by KMS; no plaintext in env; CI retrieves via short-lived tokens.
API: JTI replay cache, aud/iss validation, per-scope rate limits.
Web: SameSite=strict cookies, CSP with nonce, Origin checks for POST.
Security primitives (enforced).
 policies; resource-scoped claims; deny-by-default.
Cedar
 or 
OPA/Rego
Authorization: 
Sessions: short-lived access tokens, rotating refresh, token binding on device.
 (self-host) or managed (Auth0/Cognito) — template pins one.
Keycloak
Provider: 
 for service-to-service.
mTLS + JWT
 for users; 
OIDC/OAuth2 (PKCE)
Protocol: 
Model.
19.3 Canonical Auth & Identity
g_contract_tests: consumer/provider pact tests pass.
g_perf_api: p95 latency ≤ blueprint SLO per route in preview canary.
g_idempotency: endpoints labeled idempotent prove behavior in tests.
g_openapi_valid: spec validates; diff against previous snapshot reviewed.
Gates (blocking).
Policies: depth/complexity limits, field-level auth resolvers, DataLoader for N+1 control.
 with persisted ops and automatic persisted queries (APQ).
Helix
/
Apollo
Server: 
GraphQL (optional).
.
plan_id
, 
subject
, 
caller
Telemetry: OpenTelemetry auto-instrumented; request spans carry 
 if embeddings needed.
pgvector
 (Py); 
SQLModel
 (TS) or 
Prisma
 via 
PostgreSQL
Storage: 
 for POST, structured errors (problem-json).
idempotency keys
 (token bucket), 
Rate-limit
Cross-cutting: 
 single source of truth; code generated clients/servers.
OpenAPI v3
Contracts: 
 (TypeScript) — one chosen per program.
NestJS
 
or
 (Python) 
FastAPI
Framework: 
REST (default).
19.2 Canonical API Stack (Service)
 Page-level SEG spans include: route, hydration time, data source IDs, blueprint flow ID.
Evidence.
g_i18n: Missing translation keys = 0 for required locales.
g_contract_ui: Type-safe API clients (OpenAPI/GraphQL codegen) present for each declared endpoint.
g_perf_web: Lighthouse budgets (LCP ≤ 2.5s P75, CLS ≤ 0.1).
g_a11y: Axe violations = 0 (severity ≥ serious).
Gates (blocking).
  .lighthouseci/ (budgets.json)
  tests/ (unit, e2e)
  public/
  lib/ (fetchers, schema zod)
  components/ (a11y wrapped UI)
  app/ (routes, server components)
apps/web/
Scaffold layout.
 → OpenTelemetry bridge (LCP, CLS, INP tagged with plan_id, snapshot_id).
web-vitals
Telemetry: 
 (budgets).
Lighthouse CI
 (E2E), 
Playwright
 (unit), 
Vitest
Testing: 
i18n & a11y: next-intl, Axe checks in CI.
 (server data).
TanStack Query
 (local) + 
Zustand
State: 
 (accessibility first).
shadcn/ui
 + 
Radix Primitives
 + 
TailwindCSS
Styling: 
; SSR/ISR enabled.
React
 + 
Next.js (App Router)
Runtime: 
Stack (pinned).
19.1 Canonical UI Stack (Web)
 Code, docs, tags, and traces co-evolve under the same commit gate.
SDF-CVF parity.
 Few curated stacks, deeply instrumented. Extensions ride plug-in seams, not forks.
Parsimony.
 Security, compliance, and provenance are baked in, not added later.
Policy-first scaffolds.
 Pin frameworks, toolchains, and template hashes; all outputs are replayable from the same snapshot.
Determinism over fashion.
19.0 Scope & Principles
 evidence on every step.
VIF/SEG
, and emits 
policy-pinned
, 
content-addressed
 that APOE can compile deterministically from a blueprint into living repositories, with built-in safety, parity, and observability. Each template is 
golden paths
 Provide 
Aim.
Chapter 19. Templates & Components — Canonical stacks, policy packs, integrations, and cost/energy budgets
Part VII — IDE-in-the-Loop: From Prompt to Running App
.
on demand
. Every file, test, deploy, and metric is explainable, replayable, and reversible—
governed software
, AIMOS/APOE turns prompts into 
inside the IDE loop
 (memorable context) 
CMC/HHNI
 (lineage), and 
VIF/SEG
 (atomic evolution), 
SDF-CVF
 (compiled reasoning), 
APOE
By binding 
18.10 What’s unlocked
 → isolate dependencies; seed data snapshots; determinize seeds.
Preview flakiness
; promotion requires healthy evidence in SEG.
blocking guards
 → blueprint SLOs are 
Canary blindness
 → ICS constraints; UQ κ-bands; reviewer prompts on low agreement.
Hallucinated code
 → content-addressed templates; signature checks; periodic re-bakes.
Template rot
 → parity gates + codemods; block on severe drift.
Spec/code drift
18.9 Failure modes & design countermeasures
All emitted as OpenTelemetry spans with SEG links.
: traces with valid plan_id ≥ 99%.
Telemetry completeness
: unit ≥ 80%, contract 100% of public surfaces, mutation ≥ 70%.
Coverage
 P ≥ 0.93 at merge; P ≥ 0.97 within 24 h.
Parity score
 with rollback: P50 < 10 min.
Mean-time-to-restore (MTTR)
 after promotion: < 10%.
Change-failure rate (CFR)
: P95 < 15 min.
time-to-first-preview
: P95 < 90 s; 
Time-to-scaffold
: identical plan hash under same blueprint/toolchain (target 100%).
Plan determinism
18.8 KPIs & SLOs (engineering truth)
end
  gate { g_canary_slo, g_parity_min, hitl(two_key_if R>=τ1) }
  tool "deploy.canary"
  out { release_id }
  in  { release_candidate }
step canary_and_promote
  gate { g_ops_preview }
  tool "deploy.preview"
  out { preview_url, telemetry_pack }
  in  { pr_branch }
step deploy_preview
  gate { g_cov(>=0.80), g_mutation(>=0.70), g_security }
  tool "ci.runner"
  out { test_report }
  in  { pr_branch }
step run_tests
    gate { g_compile, g_unit, g_contract }
    budget { tokens: 4096, walltime: "8m" }
    tool "builder.agent"
    out { pr_branch, code_artifacts[] }
    in  { repo_path, module, spec_refs }
  foreach module in plan_json.modules
step synthesize_modules
  gate { g_template_integrity, g_policy_boot }
  tool "scaffold.engine"
  out { repo_path, scaffold_witness }
  in  { plan_json }
step scaffold_monorepo
  gate { g_spec_refs }
  tool "apoe.planner"
  out { plan_json, spec_refs[] }
  in  { blueprint_yaml }
step plan_from_blueprint
  using budgets { tokens: 16000, walltime: "45m" }
pipeline web_shop_build
18.7 APOE plan skeleton (ACL example)
 snapshot that produced the verdict.
exact
the 
inputs (spec excerpts), outputs (diffs), κ/UQ,
tool versions, model IDs/hashes, prompt template IDs,
 For each parity check, VIF attaches:
Lineage.
; below threshold → auto-generate patches or open ADR with risk score.
blocking
 g_parity_min (e.g., P ≥ 0.93) is 
Gates.
Runtime probes compare emitted traces to blueprint route table.
Docstring enforcement & spec anchors (IDs from blueprint).
DB schema diff vs. schema.prisma/DDL; migrations generated or blocked.
AST-level conformance checks (code ↔ OpenAPI/GraphQL).
Mechanisms.
: live spans missing blueprint labels.
Trace gap
: exported types without docs.
Doc gap
: DB vs. declared schema delta.
Schema drift
: % of surfaces where code != contract.
API drift
 [0,1] per module:
∈
 P 
Parity score
18.6 Parity enforcement (spec ↔ code)
 to last good snapshot_id. SEG adds contradiction edges for the reverted decision.
one-click reversion
 Content-addressed release; 
Rollback.
 Significant incidents create atoms in CMC, tagged to modules and causes; future APOE plans retrieve these.
Anomaly → Memory.
Metrics bundles: latency histograms, error rates, resource use; dashboards are generated from blueprint SLOs.
OpenTelemetry auto-injected in services; trace attributes include plan_id, snapshot_id, module, version.
Observability wiring (deterministic).
Two-key approval if risk band high (Ch.17); attach decision node to SEG.
 (progressive delivery).
Promotion
 for promotion.
Decision supports
SEG records canary stats as 
SLO guards from blueprint: if api_p95_ms > 250 or error_rate > 0.5% for N minutes → auto-rollback.
 (e.g., 5–10% traffic).
Canary
 defined in blueprint.
real user flows
Capture RUM + API traces for 
Attach human playback to proposal (HITL can run flows).
 per PR (isolated DB + secrets broker).
Preview env
Pipeline.
18.5 Deploy — previews, canaries, promotion, and telemetry
 Test runs write structured results into SEG: inputs, env hash, artifacts, seeds → full replayability.
Evidence.
 and proposed autofix or ADR for defer.
quarantine branch
Any failure → 
g_tests (pass), g_cov (thresholds), g_mutation, g_contract, g_security.
Gates (SDF-CVF).
: taint flows (PII), authz matrices, prompt-injection scenarios.
Security tests
 for parsers/APIs.
fuzz
 (invariants), 
Property-based
 (change-failure detector): score ≥ 70% to merge.
Mutation testing
Advanced checks.
: user flows from blueprint; run on preview env; flake budget < 2%.
E2E
: DB, queues, third-party fakes; P95 suite < 5 min.
Integration
.
blocking
: provider/consumer checks from OpenAPI/GraphQL; 
Contract
 (fast, many): functions/components; target P50 < 200 ms/test; coverage ≥ 80%.
Unit
Layers & targets.
18.4 Test — the pyramid and its gates
 Emit κ-band over synthesis confidence (n-best programs agreement, static checker entropy). Low κ → require reviewer attention (HITL).
UQ for code steps.
: must pass policy pack scanners; link to threat model item.
Security refactor
: CI-guarded; requires baseline & regression gates.
Performance refactor
: change contract → run codemods → re-generate adapters → rerun tests.
Spec-led refactor
Refactors (safe by construction).
Every public surface is documented; docstrings reference blueprint acceptance.
 code; failing tests abort synthesis.
with
Generate tests 
Prefer composition over global state; enforce dependency boundaries.
Never bypass contracts; treat OpenAPI/GraphQL schemas as types.
Intent-Constrained Synthesis (ICS) rulebook.
: compile, unit tests, mutation score, coverage.
Gate
: code + docstrings + SEG snippets + tags (HHNI).
Emit artifacts
: static analysis (types, lints), security scan, small refactors.
Refine
 contracts, types, budget.
constrained by
 (ICS): generate minimal viable implementation 
Synthesize
 (APOE step): outline files, functions, interfaces; set budgets.
Plan
 (CMC/HHNI): similar patterns, past ADRs, contract snippets.
Retrieve
Loop (per module).
 (tests/docs/traces).
review-ready
 constraints, not from scratch; codegen is 
within
 The builder agent writes 
Principle.
18.3 Code — intent-constrained synthesis and safe refactors
 → signatures on templates; SEG records hashes.
Template entropy
 → block merge if required pack missing (licenses, PII).
Policy pack gaps
 → pin & cache; reproduce via tooling.lock.
Toolchain drift
Failure modes & mitigations.
Gates: g_drift_report (lists divergences spec↔code), g_delta_conflicts.
 only for missing contracts/tests/policies.
Delta Scaffold
AST inventory + dependency graph → 
Brownfield (delta-aware).
Gates: g_template_integrity, g_policy_boot.
scaffold_witness.json = { template_ids, commit_hashes, toolchain, blueprint_hash, snapshot_id }
:
Scaffold Witness
Generate from commit-pinned templates; write 
Template catalog selection bound to blueprint.domains.
Greenfield (deterministic).
Scaffolding modes.
: initial evidence graph nodes (Spec, Contracts, SLOs).
SEG seed
CI templates: build → test → preview → canary → promote.
Policy packs pre-wired: PII redaction, license allowlist, secret scanners.
Locked toolchain: tooling.lock (node/go/python versions, formatters, linters).
Monorepo (e.g., /apps/web, /services/api, /packages/ui, /infra).
Outputs.
 Deterministic structure, policy-first wiring, fast feedback.
Goals.
18.2 Scaffolding strategies — from empty repo to governed workspace
 scaffolds; rebuilds are byte-for-byte under same snapshot & toolchain.
content-addressed
 Blueprint → plan hash → 
Determinism.
g_provenance
Export schema bindings (SEG)
compliance.export_packs
g_ops
Alert policies, canary thresholds
observability.slos
g_budget
Step budgets (tokens/time/tools)
constraints.budgets
g_tests
E2E test generation targets
acceptance.scenarios
g_spec, g_contract
Retrieval inputs + static checkers
modules[*].contracts
Gate
APOE object
Blueprint field
Compilation map (Blueprint → APOE plan).
        steps: ["cart","address","pay","confirm"]
      - name: "guest-checkout"
    flows:
  ui:
    export_packs: ["eu-ai-act-low", "soc2-lite"]
  compliance:
    threat_model: ["SSRF","prompt-injection"]
  security:
        error_rate_pct: 0.5
        api_p95_ms: 250
      slos:
    metrics:
    traces: true
  observability:
    migrations: true
    schema: "schema.prisma"
  data:
      cloud_cost_monthly_usd: 500
      build_minutes: 30
      token_per_call: 16_000
    budgets:
      licenses: ["MIT","Apache-2.0"]
      pii: "redact-at-rest"
    policies:
  constraints:
            then: "auth capture succeeds; email receipt"
          - name: "card-payment"
        scenarios:
      acceptance:
        api: "openapi/checkout.yaml"
      contracts:
    - name: "checkout"
            then:  "p95 page load < 1.2s"
            when:  "user searches 'hat'"
            given: "10k products"
          - name: "search-by-name"
        scenarios:
      acceptance:
          - "product.created@v1"
        events:
        api: "openapi/catalog.yaml"
      contracts:
    - name: "catalog"
  modules:
    - auth/oidc
    - data/postgres
    - api/rest
    - ui/web
  domains:
      - "p95 API < 250ms in NA/EU"
      - "Checkout < 3 steps"
    outcomes:
    problem: "Sell digital goods globally"
  intent:
  version: "0.1.0"
  id: "shop-web-v1"
blueprint:
Schema (v0).
 that binds scope, constraints, budgets, and acceptance. Minimal yet complete.
machine-readable spec
A 
18.1 Blueprint YAML — the contract APOE compiles
 Every transition emits: (snapshot_id, plan_id, gate results, UQ vector, provenance) into SEG; code/docs/tags/traces co-evolve in one atomic commit (SDF-CVF).
Traceability rule.
 (telemetry → SEG → feedback into memory)
Observe
 (ephemeral → canary → prod) →
Deploy
 (pyramid + mutation + property) →
Test
 (intent-constrained synthesis + refactors) →
Code
 (deterministic repo, env, policies) →
Scaffold
 (spec as data) →
Blueprint
Lifecycle (governed loop).
18.0 System overview
 with auditability. APOE compiles the blueprint into a governed plan; SDF-CVF enforces parity; VIF/SEG preserve lineage; CMC/HHNI ensures the system remembers what it built and why.
software
 into 
intent
 Turn 
Aim.
Chapter 18. Blueprint → Scaffold → Code → Test → Deploy → Observe
Part VII — IDE-in-the-Loop: From Prompt to Running App
. Two-key approval prevents single-point failure; the review UX compresses complex parity checks into a legible decision; the evidence graph guarantees the story of “who decided what, based on which facts” is never lost.
measured risk → minimal human intervention → maximal accountability
: 
surgical, not theatrical
HITL in AIMOS/APOE is 
17.11 Outcome
 all review objects and merges are content-addressed; SEG stores hashes.
Tamper-evidence:
 network egress deny by default; capability tokens for tools.
Replay sandboxes:
, not raw payloads; deep-link to redacted diffs.
projections
 review UI shows 
PII minimization:
 hardware-backed keys; rotation and revocation; approval key use is least-privilege and auditable.
Signer hygiene:
17.10 Security & privacy
}
  "cooling_minutes": 10
  "weights": { "confidence": 0.2, "impact": 0.25, "novelty": 0.2, "privacy": 0.2, "data": 0.1, "safety": 0.05 },
  "thresholds": { "auto": 0.35, "single": 0.65, "two_key": 0.65, "block": 0.92 },
  "policy_id": "hitl-default-v3",
{
HITL policy.
}
  "statement": "Approved with post-deploy canary at 10% traffic."
  ],
    { "reviewer": "role:risk",   "sig": "0x…", "ts": "…" }
    { "reviewer": "role:domain", "sig": "0x…", "ts": "…" },
  "approvals": [
  "gates": [{ "gate": "parity", "verdict": "PASS" }, { "gate": "safety", "verdict": "PASS" }],
  "risk": { "R": 0.81, "factors": { "novelty": 0.7, "privacy": 0.9 } },
  "about": "snap-2025-10-17T15:21:03Z",
  "id": "dec-2025-10-17-0012",
  "@type": "Decision",
{
Review (SEG JSON-LD fragment).
17.9 Minimal data schemas
 → escalation ladders; never collapse 2KA to single key.
Reviewer unavailability
 → composite review with per-repo owners; composite threshold signature.
Cross-repo changes
 → require impact preview acknowledgment + 2KA.
Memory high-impact (DD ≥ θ_DD)
 → always 2KA + dataset snapshot witness.
Training data touch
 → force full redaction view; require 2KA regardless of R.
Prompt-injection suspected
17.8 Edge cases & safeguards
All metrics emitted as OpenTelemetry spans, linked to SEG.
: delta in reviewer decisions vs. model κ-band; recalibrate UQ monthly.
Drift
: % of merges at each band (auto/single/2KA).
Coverage
: low-value interventions (optimize thresholds/weights).
False-positive HITL
: fraction of high-R that prevented a later rollback/incident.
True-positive HITL
: reviews per reviewer/day; auto-balance routing.
Human load
: t(decision) − t(open). Targets: P50 < 60m, P95 < 24h.
Review lead time
17.7 Metrics & SLOs
; merges executed by release bot only with valid token.
decisions
All endpoints read-only except 
GET /hitl/audit/{snapshot_id} → full lineage trail (read-only)
POST /hitl/replay → run under snapshot; attach artifacts to SEG
POST /hitl/merge-token → threshold-sign → token (bound to snapshot_id, risk_hash)
POST /hitl/review/{id}/decision → stores signed decision
POST /hitl/review/open → returns review_id, snapshot_id
POST /hitl/risk/score → {R, factors, thresholds}
17.6 APIs (sketch)
 → auto-close or escalate per SLA; optionally re-risk with stricter thresholds.
Timeout
 → Δ quarantined (Ch.16.3).
Reject
 → Proposer updates Δ → gates re-run → new S* invalidates old token.
Request changes
Deviations.
SEG gains Decision node; VIF witness bundle archived.
Release bot verifies token → merges & publishes S*.
Reviewers approve; threshold sig creates merge token.
 bound to S*.
frozen preview
Reviewers receive a 
Risk engine computes R, emits policy target (auto/single/2KA).
Proposer opens Δ with ADR; SDF-CVF gates run.
Happy path.
17.5 HITL workflow (happy path & deviations)
 Reviews are immutable; corrections append contradiction edges + addenda. No destructive edits.
Access.
 proposal → gates → reviews → merge/rollback is a single, queryable lineage chain (Ch.15).
Chain-of-custody.
 time-slice correct.
as-of
 All review artifacts carry [t_from, t_to); replays are 
Temporality.
linkage to Snapshot S*, gate results, and risk factors.
approval object hash + signatures,
reviewer ids (pseudonymous ids allowed in export), role, timestamp,
 node into SEG with:
Decision
 Every decision writes a 
Non-repudiation.
17.4 Accountability trails
 Threaded comments are first-class SEG annotations (time-sliced), not ephemeral chat.
Commenting.
: predicted blast radius across HHNI/SEG.
dependency impact
Show 
Group related hunks by API/feature.
Collapse trivial churn (format, comments).
Diff semantics.
: Approve/Reject/Request changes; add constraints; assign follow-ups.
Actions
: PII/secret taint paths, license diffs, guardrail triggers.
Policy hits
 in a sandbox; preview env for web apps.
replay under snapshot
: one-click 
Playback
: κ-band, ECE, variance; links to calibration run.
UQ panel
 (VIF): model id & weights hash, prompt template, tool calls, seeds, snapshot id.
Witness panel
Traces (SEG): claim/evidence/decision changes, contradiction edges.
Tags (HHNI): node/edge delta, DD, impact cone preview.
Docs/specs: schema-aware diffs, OpenAPI/JSON-Schema checks.
Code: AST/API surface, mutation-score delta.
 (noise-free):
Quartet diffs
: R, source breakdown, thresholds, suggested path.
Risk card
Reviewer view (single pane).
17.3 Review UX & diff semantics
Auto-opens post-mortem ADR and sets amber label in SEG; time-boxed.
Requires three distinct keys (incl. Operator) + incident ticket.
Emergency break-glass.
: merge token TTL (e.g., 24h); any material change invalidates token (content-addressed diffs).
Expiry
 (t=2 of n) yields a single merge token bound to snapshot_id and risk hash.
Threshold signature
}
  statement, signatures: [sig(reviewer_key)]
  decision: {APPROVE|REJECT|REQUEST_CHANGES},
  id, snapshot_id, risk: R, gate_results, diffs, reviewer_id, role,
Approval {
 signed with FIDO2 or org PKI:
Detached approval objects
Mechanics.
Conflict checks: reviewers cannot approve their own proposals; no reciprocal approvals within a rolling window.
Cooling period: approvals must be non-simultaneous (e.g., ≥ 10 min apart) unless incident emergency label is set.
 (Key-B).
Risk/Compliance Owner
 (Key-A), 
Domain Owner
Distinct org roles: 
Policy.
.
non-delegable
 and 
role-separated
 No single human can push a high-risk decision. Keys are 
Principle.
17.2 Two-key approval (2KA)
 Weekly backtests correlate R to downstream incidents/rollbacks; optimize {w_*}, τ for target CFR and MTTR (Ch.16.4).
Calibration.
 (Ch.16).
block + quarantine
R ≥ τ_block → 
 (Reviewer-A + Reviewer-B).
two-key approval
R ≥ τ₁ → 
 (Reviewer-A).
single-review
τ₀ ≤ R < τ₁ → 
 (no human).
auto
R < τ₀ → 
Thresholds.
Weights {w_*} are program-specific; all components normalized to [0,1].
: prompt-injection exposure, tool capability delta, sandbox escape potential.
safety
S — 
: weak/unknown source provenance in SEG, contradiction edges involved.
data-lineage risk
D — 
: PII flows, license changes, policy pack hits.
privacy/policy exposure
P — 
: distance from prior patterns (embedding drift, unseen API surface, unseen spec pattern).
novelty
N — 
: blast radius (users, data domains), monetary/latency deltas, dependency cone size.
impact
I — 
κ_band — abstention/uncertainty band from UQ (Ch.14): entropy, variance, ECE-adjusted.
 For a candidate change/answer x:
Signal model.
A single bounded risk score drives HITL policy.
17.1 Risk scoring (R)
 (release).
Operator
 (risk/compliance), 
Reviewer-B
 (domain), 
Reviewer-A
 (author), 
Proposer
 role-separated 
Who:
 SDF-CVF gate line (Ch.16), APOE plan boundaries (Ch.11), SEG decision issuance (Ch.15).
Where:
 pre-merge, pre-deploy, post-incident, post-training-data change, high-impact memory edits (high DD), policy-touching changes (PII/licensing).
When:
17.0 Control surfaces
 at precisely the points where automation is most likely to err or cause harm—without turning HITL into a bottleneck. Every intervention is measurable, reproducible, minimally-intrusive, and leaves a cryptographically verifiable trail.
governed human judgment
 Insert 
Aim.
Chapter 17. Human-in-the-Loop (HITL) — risk scoring, two-key approval, review UX, accountability
Part VI — Atomic Evolution: SDF-CVF
 operation—not a scramble.
first-class, witnessed
: the same commit updates code, specifies what changed, tags the memory, and records witnessable traces. Gates keep the quartet glued; quarantine contains risk; rollback is a 
governed evolution
SDF-CVF turns “updates” into 
16.6 Outcome
Post-incident ADR addendum with root cause and follow-ups
SEG contradiction edges emitted; user-facing label set (amber/red)
Routing flipped to S_prev atomically
If rollback
Exit: merge or rollback executed & witnessed
Autofixers attempted; re-gate result posted
Capability tokens restricted; secrets rotated if needed
QI opened with SLA & owner
If quarantine
Snapshot S* prepared & signed; exportable pack green (SEG/JSON-LD)
ADR linked; risk R computed; two-key approvals if R≥τ
Witness bundle attached (model hash, prompt template, tools)
All gates PASS (or SOFT_FIX applied + re-gate PASS)
Before merge (bot-enforced)
16.5 Checklists
Every gate emits: {gate, verdict, reason, patch?, duration, owner, risk, κ_band} → OpenTelemetry spans with snapshot id → SEG Decision nodes for audit.
Emissions
 — token/latency deltas vs. budgets.
Budget adherence
 on touched code.
Mutation score
 — Δ line/branch coverage; 
Coverage deltas
 >90%.
Target:
 — % commits where quartet diffs are mutually consistent (no autofix needed). 
Parity score
 P50 < 4h, P95 < 24h.
Target:
 — mean time from quarantine/incident open → green re-gate or rollback. 
MTTR
 <10%.
Target:
 — fraction of merges that trigger rollback/quarantine within T hours. 
Change failure rate (CFR)
 — ADR→merge.
Lead time for changes
 — merges to trunk with PASS.
Deployment frequency
Track per repo/program:
16.4 DORA-aligned metrics & SLOs
}
  "two_key": ["ownerA","ownerB"]
  "requester": "release-bot",
  "reason": "gate-regression-coverage",
  "to_snapshot": "snap-2025-10-12T11:02:22Z",
{
POST /evolution/rollback
Rollback API (sketch)
 For side-effects across stores, maintain compensators (e.g., reverse data migrations, retract tool outputs).
Saga/compensation.
 rollback(to=S_prev) atomically resets routing pointers; append contradiction edges in SEG (do not delete); rehydrate HHNI from S_prev.
Revert.
Flip routing to S* for live reads/writes.
Prepare S* (code/docs/tags/traces) and publish to the snapshot log.
 Two-phase merge with snapshot publication:
Design.
Rollback
 if SLA exceeded.
auto-revert
 On green re-gating → return to normal merge; else 
Exit.
 with SLA.
Quarantine Incident (QI)
 Attach gate failure reasons, impact cone, suggested fixes; open a tracked 
Diagnostics.
 with read-only memory; run in sandboxed containers; redact secrets.
quarantine branch
 Move Δ to a 
Isolation.
Quarantine
 apply prompt compression (dumbbell layout), cache hot sub-plans, lower temperature for stability.
Perf/Cost:
 replay tool calls under frozen snapshot; regenerate witness with pinned seeds.
Provenance:
 reindex HHNI; regenerate dependency hashes; prune low-weight edges.
Memory:
 synthesize unit tests for uncovered public methods; strengthen weak assertions.
Tests:
 generate or update missing sections; fix OpenAPI/JSON-Schema drift.
Docs/spec parity:
Auto-fixers (non-interactive)
16.3 Auto-fix, quarantine, rollback
Links (SEG ids, issues)
Consequences (tech/risk)
Alternatives
Decision
Context
ADR-####: Title
ADR minimal template:
 All gates green + (if R≥τ) dual reviewer sign-off (two-key) + signed snapshot.
Merge protocol.
 (restricted tools/data).
capability tokens
 Trunk-based; short-lived feature branches. High-risk branches run with 
Branching.
 Each Δ starts with an ADR (motivation, options, decision, consequences) → stored in SEG and linked to the commit.
ADR on change intent.
ADR & branching strategy
 New concepts introduce HHNI atoms with priority vectors; cross-links hashed; high-impact edits require preview.
Memory tags:
 Added behaviors must bind to observable metrics/logs.
Code↔Telemetry:
 Public surface changes must update docs (autofill allowed but flagged).
Code→Docs:
 Any public contract change must have corresponding code diffs and tests (create stubs if missing).
Spec→Code:
Parity rules
 graph deltas (nodes/edges) with bi-temporal fields.
Traces (SEG):
 node/edge deltas + DD (dependency delta) + impact cone.
Tags (HHNI):
 schema-aware diffs (headings, tables, OpenAPI).
Docs/Specs:
 AST-level semantic diffs (noise-free), API surface map.
Code:
Diff semantics
16.2 Parity across the quartet
  return HARD_FAIL
  if verdict == DEFER: return HITL
  if verdict == SOFT_FAIL and patch: Δ' ← apply(patch, Δ); return RETRY(Δ')
  if verdict == PASS: return PASS
  verdict, patch ← g.check(inputs)
  inputs ← materialize(g.requires, Δ)
result gate(g, Δ):
Gate function (sketch)
DEFER→HITL
(i) If R ≥ τ, require 2-key approval; (ii) reviewer roles distinct
risk score R
Human oversight
HITL-Risk
SOFT_FIX (recalibrate)
(i) κ-banding consistent; (ii) ECE ≤ ε on eval slice
κ, ECE
Honest confidence
UQ/Calibration
SOFT_FIX (compress) or DEFER
(i) p95 latency Δ ≤ θ; (ii) token budget within class
token/latency deltas
Budget adherence
Perf/Cost
HARD_FAIL
(i) Claim has witness; (ii) contradiction edges instead of delete; (iii) time fields valid
SEG delta, SHACL
Evidence continuity
Traces/SEG
DEFER→HITL if high impact
hashes updated; (iii) impact preview acknowledged
(i) DD ≤ θ_DD; (ii) dependency 
HHNI diff, DD
Memory integrity
Tags/HHNI
SOFT_FIX (replay to regenerate)
(i) Model id + weights hash pinned; (ii) tool versions pinned; (iii) replay seed stored
witness bundle
Reproducibility
Provenance (VIF)
HARD_FAIL→QUARANTINE
(i) No PII exfil paths; (ii) license ok; (iii) prompt-injection vectors neutralized
policy pack, taint map
Security & data policy
Safety/Policy
SOFT_FIX (auto-tests) or QUARANTINE
(i) All suites green; (ii) Δ-coverage ≥ θΔ; (iii) Mutation score ≥ μ
test graph, coverage map
Functional confidence
Tests
SOFT_FIX (gen doc stubs) else QUARANTINE
Public API changes mirrored in docs; (iii) Coverage of new spec scenarios ≥ θ
(i) Function/class add/remove reflected in spec; (ii) 
diff(AST), spec YAML, SEG claims
Align spec/docs↔code↔telemetry
Parity
On failure
Check (examples)
Inputs
Purpose
Gate
16.1 Gate catalog (parity, tests, safety, provenance, HITL)
) = PASS and a Witness W (VIF) is attached.
Δ
 G: g(
∈
 g 
∀
 A commit K = (Δ, S*, W) is valid iff 
Formal.
 used for replay/rollback.
Snapshot S*
S_code, S_docs, S_tags (HHNI delta), S_traces (SEG delta) → rolled up into 
 — every PASS produces:
Snapshots
 — PASS → merge; SOFT_FAIL → auto-fix then re-gate; HARD_FAIL → quarantine; DEFER → HITL.
Outcomes
 the quartet.
bind
 — deterministic checks that 
Gates G
 — the atomic proposal spanning all artifacts.
ChangeSet Δ
16.0 Core model
 change travel as one sealed unit across the quartet {code, docs, tags, traces}—gated, witnessed, reversible.
every
 Make 
Aim.
Chapter 16. Atomic Commits Across Code/Docs/Tags/Traces
Part VI — Atomic Evolution: SDF-CVF
 that can be replayed, defended, and improved.
durable, inspectable facts
. With JSON-LD/SHACL for structure, bi-temporal slicing for truth-over-time, lineage scoring for audits, and signed export packs for regulators, AIMOS/APOE upgrades outputs into 
because the evidence shows so
The SEG turns “because the model said so” into 
15.8 Outcome
Inline highlights for cited snippets with CAS previews.
.
Export bundle
, 
Compare times
, 
Show lineage
One-click: 
Always show “as-of” clock for views.
UX
Monitor lineage LC drift and band distributions over time.
Provide signed export; keep public keys rotated & pinned.
Maintain time-slice resolver and cache for hot asOf queries.
Enforce SHACL shapes on ingest; reject malformed witnesses.
Platform
Append contradiction edges rather than deleting outdated claims.
Use content-addressed blobs for sources/snippets & store license tags.
Fill both tx* and valid* (if domain time known).
Emit JSON-LD nodes/edges for Claim/Artifact/Witness/ToolCall/Snapshot.
Producer (pipelines)
15.7 Checklists
 Mutations happen only through the memory/orchestration pipelines that already emit witnesses and graph deltas.
All endpoints are read-only.
Text/metadata search over Claim/Artifact/Source with filters on bands, policies, time.
GET /seg/search
Returns: signed bundle URL + sha256.
Body: { "roots":[…], "depth":3, "asOf":"…", "format":"bundle/v1" }
POST /seg/export
Returns the VIF JSON (Chapter 14 schema) with integrity hashes.
GET /seg/witness/:id
Response: DAG slice (nodes+edges) + lineage confidence (LC) + summary counts.
Query parameters: root, depth, asOf, include=decisions,snippets,witnesses
GET /seg/lineage
15.6 SEG API (read-only)
 (VIF) by (model_id, prompt_template_id, seed).
witness packs
Cache 
 (transitive closure summaries) for hot claims.
lineage cones
Pre-compute 
 batches; end records by setting txTo (no deletes).
append-only
Write 
Throughput tips
Sharding: by snapshot_id or by (project, chain_id) domains.
Secondary: (confidenceBand), (uncertaintyScore), (policyId).
Edge: (src, rel, dst), plus tx* and valid*.
Node: (type), (txFrom, txTo), (validFrom, validTo), (contentAddress).
Indexes
 store JSON-LD canonically in object store; mirror into PG for fast lineage UI.
Hybrid:
 easier path queries & ops dashboards; use custom time-slice middleware.
Property graphs (Neo4j, Neptune-PG):
 strong JSON-LD/SHACL alignment; native SPARQL/time filters.
RDF (e.g., Jena, Neptune-RDF):
Backends
15.5 Storage, indexing, and scale
 include UQ calibration packs & policy configs in bundle.
Risk management:
 manifest.retention.min_months and store policy id.
Retention (≥ 6 months):
 Artifact nodes carry seg:modality and synthetic marker; export includes labeling policy.
Art. 52 (synthetic labeling):
 graph.ndjson + witnesses/*.json with tx & valid times.
Art. 12 (logging):
EU AI Act mapping (high-risk systems)
 (what was removed & why) for auditors.
redaction map
Export bundles include 
; SEG holds selectors (e.g., salted hashes) and data class tags.
at ingest
Redact PII 
Privacy & redaction
Store public key fingerprint; publish key in your compliance registry.
Generate manifest.sig as a detached Ed25519 signature over the canonicalized manifest.json and graph.ndjson hashes.
Signing
}
  }
    "min_months": 6
    "policy_id": "ret_high_risk_v2",
  "retention": {
  },
    "public_key_fingerprint": "ed25519:6c9a…"
    "algorithm": "ed25519",
  "signing": {
  },
    "witnesses": ["sha256:01…aa","sha256:b3…1f"]
    "graph": "sha256:af…20",
  "hashes": {
  },
    "depth": 3
    "include_decisions": true,
    "root_claims": ["seg:claim/7f820"],
  "scope": {
  "as_of": "2025-10-12T11:05:00Z",
  "exported_at": "2025-10-12T11:10:00Z",
  "seg_version": "1.0",
{
manifest.json
    manifest.sig               # detached signature
  signatures/
    pii_guard_v3.json          # active policy configs
  policies/
    calib-pack-ids.json        # mapping & hashes
  calibrations/
    witness-9a12b.json
  witnesses/                   # VIF witnesses (json)
    sha256-...                 # source snippets, tool outputs
  blobs/                       # CAS payloads (stubs for external)
  graph.ndjson                 # nodes & edges (time-sliced)
  manifest.json
seg-export/
15.4.1 Bundle structure (zip)
 replay of external calls.
stubbed
Deterministic replay or 
One-click, machine-readable bundles for auditors/regulators.
Objectives
15.4 Export & regulatory packages
: show the exact graph slice that justified a Decision (deploy/merge), including UQ band at the time.
Decision ladders
: pick any two asOf times to see added/ended edges and changed witnesses.
Delta view
: left rail is the claim; right rail shows sources/snippets with aligned highlights.
Rail view
UI patterns
    by(out('SUPPORTS').valueMap())
    by(out('HAS_WITNESS').valueMap()).
    by(id()).
  project('claim','witness','snippet').
                              has('txTo', gt(asOf))).
                         or().has('txTo', null).
  where(out('HAS_WITNESS').has('txFrom', lte(asOf)).
g.V().hasLabel('Claim').
Gremlin (TinkerPop)
RETURN c, w, sn
WHERE w.txFrom <= $asOf AND (w.txTo IS NULL OR w.txTo > $asOf)
      (c)-[:SUPPORTS]->(sn:Snippet)
MATCH (c:Claim)-[:HAS_WITNESS]->(w:Witness),
Cypher (property graphs like Neo4j)
}
  FILTER (?asOf >= ?w_txFrom && (bound(?w_txTo) = false || ?asOf < ?w_txTo))
  OPTIONAL { ?snippet seg:partOf ?source . }
           seg:contentAddress ?cas .
  ?snippet a seg:Snippet ;
         seg:supports ?snippet .
         seg:hasWitness ?witness ;
  ?claim a seg:Claim ;
SELECT ?claim ?witness ?snippet ?source WHERE {
SPARQL-ish (RDF stores)
Queries
.
a logistic squash to 
is the claim’s uncertainty score and 
where 
Aggregate lineage confidence for a claim:
.
default to 1.0; contradiction edges carry negative influence 
Edge weights 
Path scoring (for audit UX)
 Claim -derivesFrom-> Artifact|ToolCall.
or
Claim -supports-> Snippet -partOf-> Source 
and either
Claim <-hasWitness- Witness -ranUnderSnapshot-> Snapshot
:
supported path
 claim must have at least one 
valid
A 
Path semantics
15.3 Lineage: Claim → Evidence → Decision
?”), filter by both validFrom/validTo and txFrom/txTo.
then
For domain questions (e.g., “what did we believe 
Validity join (domain time)
  return nodes E where E.txFrom <= asOf and (E.txTo is null or E.txTo > asOf)
function slice(graph, asOf):
Time-slice resolver (pseudo)
 anchor “as-of” state: a query with asOf=2025-10-12T11:05Z includes nodes with txFrom ≤ asOf < txTo|∞.
Snapshots
 (seg:contradicts) plus optional validTo.
contradiction edges
Deprecations use 
 by setting txTo.
ended
; they are 
never hard-deleted
Records are 
Rules
 (txFrom/txTo): when the record existed in the SEG store.
Transaction time
 (validFrom/validTo): when the statement is intended to hold in the domain.
Valid time
 semantics:
bi-temporal
We use 
15.2 Temporal graphs & time-slicing
  sh:property [ sh:path seg:txFrom ; sh:datatype xsd:dateTime ] .
  sh:property [ sh:path seg:ranUnderSnapshot ; sh:minCount 1 ] ;
  sh:property [ sh:path seg:usesModel ; sh:minCount 1 ] ;
  sh:targetClass seg:Witness ;
seg:WitnessShape a sh:NodeShape ;
Witness must pin model & snapshot
  ] .
    sh:in ("green" "amber" "red") ;
    sh:path seg:confidenceBand ;
  sh:property [
  ] ;
    sh:minCount 1 ;
    sh:path seg:supports ;
  sh:property [
  ] ;
    sh:minCount 1 ;
    sh:path seg:hasWitness ;
  sh:property [
  sh:targetClass seg:Claim ;
seg:ClaimShape a sh:NodeShape ;
@prefix seg: <https://aimos.dev/seg#> .
@prefix sh: <http://www.w3.org/ns/shacl#> .
Claim must have a witness and at least one lineage edge
15.1.4 SHACL shapes (conformance)
}
  "txFrom": "2025-10-01T08:00:00Z"
  "validFrom": "2025-09-30T00:00:00Z",
  "license": "CC-BY-4.0",
  "contentAddress": "cas:sha256-b9…ef",
  "type": "seg:Snippet",
  "id": "seg:source/snippet/arxiv-2502.14255#p3",
{
}
  "txTo": "2025-10-12T11:02:22Z"
  "txFrom": "2025-10-12T11:02:14Z",
  "produced": "seg:artifact/3de77",
  "calibratedECE": 0.04,
  "appliesPolicy": ["seg:policy/pii_guard_v3"],
  "usesTool": ["seg:tool/web.search@1.9.3"],
  "ranUnderSnapshot": "seg:snapshot/snap-2025-10-01",
  "usesModel": "seg:model/gpt-4o@sha256-3f...c9",
  "type": "seg:Witness",
  "id": "seg:witness/9a12b",
{
}
  "uncertaintyScore": 0.47
  "confidenceBand": "amber",
  "contradicts": [],
  "supports": ["seg:source/snippet/arxiv-2502.14255#p3"],
  "hasWitness": "seg:witness/9a12b",
  "txTo": null,
  "txFrom": "2025-10-12T11:02:22Z",
  "validTo": null,
  "validFrom": "2025-10-12T11:02:22Z",
  "modality": "text/plain",
  "type": "seg:Claim",
  "id": "seg:claim/7f820",
  "@context": "https://aimos.dev/seg/context.json",
{
15.1.3 Minimal example (one claim, witnessed, with sources)
}
  }
    "license": "seg:license"
    "modality": "seg:modality",
    "contentAddress": "seg:contentAddress",
    "hash": "seg:hash",
    "calibratedECE": {"@id": "seg:calibratedECE", "@type": "xsd:double"},
    "uncertaintyScore": {"@id": "seg:uncertaintyScore", "@type": "xsd:double"},
    "confidenceBand": "seg:confidenceBand",
    "citesChunk": {"@id": "seg:citesChunk", "@type": "@id"},
    "appliesPolicy": {"@id": "seg:appliesPolicy", "@type": "@id"},
    "usesModel": {"@id": "seg:usesModel", "@type": "@id"},
    "ranUnderSnapshot": {"@id": "seg:ranUnderSnapshot", "@type": "@id"},
    "usesTool": {"@id": "seg:usesTool", "@type": "@id"},
    "produced": {"@id": "seg:produced", "@type": "@id"},
    "hasWitness": {"@id": "seg:hasWitness", "@type": "@id"},
    "contradicts": {"@id": "seg:contradicts", "@type": "@id"},
    "derivesFrom": {"@id": "seg:derivesFrom", "@type": "@id"},
    "supports": {"@id": "seg:supports", "@type": "@id"},
    "txTo": {"@id": "seg:txTo", "@type": "xsd:dateTime"},
    "txFrom": {"@id": "seg:txFrom", "@type": "xsd:dateTime"},
    "validTo": {"@id": "seg:validTo", "@type": "xsd:dateTime"},
    "validFrom": {"@id": "seg:validFrom", "@type": "xsd:dateTime"},
    "type": "@type",
    "id": "@id",
    "prov": "http://www.w3.org/ns/prov#",
    "schema": "https://schema.org/",
    "@vocab": "https://aimos.dev/seg#",
  "@context": {
{
15.1.2 JSON-LD @context
UQ/Confidence: seg:confidenceBand, seg:uncertaintyScore, seg:calibratedECE
Integrity: seg:hash, seg:contentAddress, seg:license, seg:modality
Temporal: seg:validFrom, seg:validTo, seg:txFrom, seg:txTo
Lineage: seg:supports, seg:derivesFrom, seg:contradicts, seg:annotates, seg:citesChunk
Structural: seg:hasWitness, seg:produced, seg:usesTool, seg:ranUnderSnapshot, seg:usesModel, seg:appliesPolicy
Key properties
seg:Policy — safety/guardrail policy bound to a run.
seg:CalibrationPack — post-hoc calibration artifact.
seg:Model — model id & weights hash.
seg:Snapshot — frozen memory/index/tool state.
seg:Decision — an operational act (merge/deploy/publish).
seg:ToolCall — invocation with inputs/outputs & version pins.
seg Wit ness — the VIF tuple bound to an Artifact/Claim.
seg:Snippet — a bounded region inside a Source.
seg:Source — external input (doc, API, dataset).
seg:Artifact — any produced object (text/code/table/file).
seg:Claim — a statement the system asserts.
Core classes
xsd:       http://www.w3.org/2001/XMLSchema#
prov:      http://www.w3.org/ns/prov#
schema:    https://schema.org/
seg:       https://aimos.dev/seg#
@vocab:    https://aimos.dev/seg#
Namespaces
15.1.1 Vocabulary & classes
15.1 JSON-LD schema & SHACL
 a first-class, queryable substrate. The SEG stores claims, sources, tool calls, witnesses, decisions, and their temporal validity so that any output can be traced, sliced “as-of” time, exported for audit, and replayed.
evidence itself
 Make 
Aim.
Chapter 15. Shared Evidence Graph (SEG)
Part V — Verifiable Intelligence: VIF & SEG
, enabling safe automation, regulatory compliance, and user trust.
witnessed evidence
 to 
claims
. Together with ACL and HHNI, it upgrades outputs from 
replayable
run 
, and every 
quantified & calibrated
, every confidence 
provable
VIF makes every answer 
Outcome.
Persist gate record in SEG; surface in audit view.
 (deterministic or robust) when band≠green.
Replay
Offer 
Show badge + drivers; link to sources with chunk previews.
Enforce κ-policy by band; disable destructive actions on amber+.
Consumer (gates & UI):
Emit witness → SEG with edges.
Apply per-model calibration; include ECE.
(coverage & contradictions).
If RAG, compute 
signals (e.g., entropy + self-consistency).
Compute at least two 
Record hhni_slices and seg_refs used.
Attach weights_hash, prompt_template_id@hash, seed.
Producer (at every step):
14.6 Checklists (implementation-ready)
}
  strict: true            // block writes on amber+
  policy: risk_bands_v3   // stores thresholds and next-step recipes
  inputs: { uq: r }
gate uq: UQGate {
ACL snippet (policy-aware):
    abstain(kappa); propose next_steps()
else:
    pass_with_banner; require Verifier on downstream write/deploy
elif u <= 0.60:
if u <= 0.30: pass
Gate decision.
.
with defaults 
Unified risk score.
14.5 Putting it together — the gate math and policy
Export: acl export seg --bundle=vif+trace produces machine-readable audit packs.
; retain hashed surrogates and selectors only.
ingest
PII/PHI: redact at 
High-risk pipelines: ≥ 6 months.
Witnesses, stubs, and calibration packs are content-addressed; retention policy defaults:
Storage & retention.
 per policy.
tainted
 that enumerates differing hashes; auto-rollback or mark chain 
diagnostic witness
If determinism breaks under pins → emit ACL-D301 Determinism breach, attach a 
Failure semantics.
Seeds: seed (global) + per-step overrides.
; GPU type if applicable.
runtime_hash
Environment: OS/driver digests, 
.
container digests
Tools/indices: {name: version}, 
Data slices: hhni_slices@version, seg_refs@rev.
Prompts: prompt_template_id@hash, prompt_args.
Models: model_id, weights_hash.
What must be pinned.
 witness with set_id.
ReplaySet
decodes/temps; report mean±std, majority answer, and band stability. Store 
Re-execute with 
 (variance bounds):
Robustness replay
.
provenance deltas
; replay uses stubs. Drift shows as 
CAS blobs
Record I/O of tools (HTTP responses, file reads) as 
 (external calls stubbed):
Quasi-deterministic replay
 if upstream pins missing.
abstain
Same snapshot_id, seed, prompt_template_id, model_id@weights_hash, tool_versions, index_versions → identical output, or 
 (under pins):
Deterministic replay
Replay levels.
14.4 Reproducibility & replays
.
copy as JSON
 of a witness view for audits; expose 
pinning
Permit 
Always pair color with text/icon; offer “Why-this-confidence?” explainer modal.
Accessibility & UX notes.
}
  }
    ]
      "Narrow time window to last 90 days"
      "Add sources for section §2.3",
      "Open verifier report",
    "suggested_next": [
    ],
      {"name":"verifier_disagreement","value":1.0}
      {"name":"self_consistency_var","value":0.11},
      {"name":"evidence_coverage","value":0.62},
    "drivers": [
    "score": 0.47,
    "band": "amber",
  "confidence": {
{
Recommended payload (client contract):
: destructive ops (write, deploy, merge) are disabled or require HITL outside green band.
Action gating
: risk badge tied to changed hunks; link to tests that justify confidence.
Diff-aware code panes
: footnotes with doc_id#chunk hover to preview source, highlight aligned spans.
Inline citations
).
high sample variance
, 
verifier disagreement
, 
low evidence coverage
: “Why this band?” → show top-3 drivers (e.g., 
Tooltip
: green/amber/red, color-blind safe palettes.
Color
 on every artifact title: ✓ High confidence / ~ Medium / ! Low.
Badge
.
explainable on click
, and 
layered
, 
visible by default
 Confidence is 
Principles.
14.3 Confidence bands & UI cues
gate uq: UQGate { inputs: { uq: r }, policy: "risk_bands_v3" }
ACL example:
); propose next steps (more evidence, narrower slice, HITL).
 (
abstain
→ 
 
Red:
→ show banner; route Verifier or request user confirmation for high-impact actions.
 
Amber:
→ proceed.
 
Green:
Define risk bands after calibration:
14.2.3 κ-abstention policy
 and pinned in the witness (calibration.calib_id).
(model_id, domain, prompt_family)
Calibration artifacts are versioned per 
.
 (Expected/Adaptive Calibration Error): bucket predictions, compare avg confidence vs empirical accuracy; target 
ECE/ACE
 when monotonic but non-linear mapping fits better.
Isotonic regression
.
 on a labeled dev set: 
Platt scaling (logistic)
using:
to a calibrated 
 the model’s raw confidence 
post-calibrate
We 
14.2.2 Calibration
.
. Defaults: 
with 
Aggregation (bounded risk):
.
Score: 
Cross-doc consistency: contradiction rate among top-k sources.
Evidence coverage: fraction of claim spans aligned to citations.
Retrieval sufficiency.
.
Score: 
A second model/role critiques the claim; disagreement lifts uncertainty.
Verifier disagreement.
.
Score: 
forward passes with dropout; use predictive variance.
Sample 
MC-dropout (when logits exposed).
.
Score: 
independent decodes → majority consensus or agreement rate.
Self-consistency / ensembles.
.
Score: 
; measure textual dispersion (e.g., pairwise ROUGE-L or embedding distance).
Run the same prompt at 
Temperature sweep (multi-pass).
via min–max per head. Cheap, universal.
Mapped to 
.
 
Margin
on class/logit heads (where available).
Entropy / margin (single pass).
14.2.1 Per-step signals
: Do reported confidences match reality?
 
Calibration error
 across samples?
confident & consistent
: Is the model 
 
Model uncertainty
?
sufficient & consistent
: Is the grounding evidence 
 
Retrieval uncertainty
We quantify uncertainty along three axes:
14.2 UQ methods — computing uncertainty you can trust
(witness) -[ran_under]-> (snapshot::<id>)
(witness) -[used_tool]-> (tool::<name>@<ver>)
(witness) -[derived_from]-> (source_doc::<id>#chunk::<span>)
(artifact) <-[witnessed_by]- (witness)
 witness::<uuid> with edges:
SEG node
Each witness is written as a 
SEG anchoring.
 must add tool & index versions, seed, policy_ids, ECE, trace timing & token/costs, and provenance.chunk_locs.
Full
 must include: model_id, weights_hash, prompt_template_id, snapshot_id, hhni_slices, at least one uq.score.
Minimal
Design rules (VIF-minimal vs VIF-full):
}
  }
    "cost": {"usd": 0.032}
    "wall_ms": 8240,
    "tokens": 1842,
    "ended_at":"2025-10-12T11:02:22Z",
    "started_at":"2025-10-12T11:02:14Z",
    "chain_id":"research.oauth2.threats.v1",
    "step_id":"r:claim-01",
  "trace": {
  },
    "decision": {"kappa":0.55,"gate":"UQGate:pass"}
    "calibration": {"ECE":0.04,"bins":15},
    "bands": {"green":[0.0,0.3],"amber":[0.3,0.6],"red":[0.6,1.0]},
    "scores": {"entropy":0.23,"margin":0.61,"var_sc":0.08},
    "method": ["temp_sweep","self_consistency","ece_postcal"],
  "uq": {
  },
    "citations": ["[1] …"]
    "chunk_locs": [{"doc_id":"doi:…","start":"p.4 ¶2","end":"p.5 ¶1"}],
    ],
      {"doc_id":"doi:10.1145/…","hash":"sha256:…","license":"CC-BY-4.0"}
    "source_docs": [
  "provenance": {
  },
    "policy_ids": ["sec_web_readonly","pii_guard_v3"]
    "seed": 101,
    "index_versions": {"hhni:security":"v37"},
    "tool_versions": {"web.search":"1.9.3","pdf.extract":"0.7.1"},
    "snapshot_id": "snap-2025-10-01",
  "pins": {
  },
    "tools_used": ["web.search@1.9.3","pdf.extract@0.7.1"]
    "seg_refs": ["SEG:claims/2025-10-12/oidc"],
    "hhni_slices": ["HHNI:system->section('Security')->paragraph#12"],
    "prompt_args": {"question":"Summarize OAuth2 threats post-2024"},
    "prompt_template_id": "tpl.claim.v2",
  "inputs": {
  },
    "runtime_hash": "sha256:rt…aa"
    "weights_hash": "sha256:3f…c9",
    "model_id": "gpt-4o",
    "role": "Reasoner",
  "actor": {
{
Minimal JSON (machine-readable, embeddable):
: { step_id, chain_id, started_at, ended_at, cost, tokens, wall_ms }
trace
: { method[], scores, bands, calibration, decision: {kappa, gate} }
uq
: { source_docs[], chunk_locs[], citations[], license_tags[] }
provenance
: { snapshot_id, tool_versions{}, index_versions{}, seed, policy_ids[] }
pins
: { prompt_template_id, prompt_args, hhni_slices[], seg_refs[], tools_used[] }
inputs
: { role, model_id, weights_hash, runtime_hash }
actor
:
 
witness
(text, code, table, decision), we attach a 
For any produced artifact 
Definition (witness tuple).
14.1 VIF metadata — the witness tuple
 (deterministically or with bounded variance).
how to replay it
 (quantified, calibrated), and 
with how much uncertainty
 (versions, seeds), 
under which pins
 (prompts, data slices), 
with what
 produced it (model & tools), 
who
: 
answerable
 Make every artifact 
Aim.
Chapter 14. Provenance & Uncertainty (VIF)
Part V — Verifiable Intelligence: VIF & SEG
, and explain it to an auditor. It is the language that turns APOE intent into DEPP reality without losing memory, budget, or provenance.
read it, diff it, lint it, compile it, replay it
: you can 
software-grade
 ACL makes orchestration 
Outcome.
: Any change → ChainDiff + parity gates + (if high-risk) HITL.
Evolution
).
: Pins + snapshot = replayable trace (or 
Determinism
: Budgets enforced; policies applied; gates required.
Safety
: Artifacts + Witness + UQ; immutable; SEG-anchored.
Outputs
: HHNI/SEG selectors + JSON-typed payloads.
Inputs
13.17 Contract summary
Re-pin/rollback
Replay
Determinism breach under pins
ACL-D301
Quarantine + HITL
Runtime
Policy violation (PII egress)
ACL-S201
Splice verifier
Runtime
UQ calibration fail
ACL-R118
Rewrite/refactor
Runtime
Budget overrun (tokens)
ACL-R101
Add pins
Compile
Missing pins on frontier node
ACL-E037
Raise caps or refactor
Lint
Budget infeasible: min path > token_pool
ACL-E022
Add gate
Lint
Gate coverage missing on shard boundary
ACL-E014
Fix edge/types
Compile
Type mismatch: expected Evidence[], got Code
ACL-E001
Action
Phase
Message
Code
13.16 Error catalog (selected)
: produces regulatory export packs.
acl export seg
: re-executes traces under pins.
acl replay --snapshot …
: emits IR JSON with content hashes.
acl compile
: runs static analyses & lints.
acl lint
: canonical formatting, stable diffs.
acl fmt
13.15 Tooling: CLI, fmt, and IR
}
  }
    step w: Witness { inputs: { trace: ALL } }
    gate prov: ProvenanceGate { inputs: { witness: verdict } }
    reduce check[1..5] -> verdict using adjudicate=verifier
    fanout hyp -> check[1..5]
    step hyp: Reasoner { inputs: { evidence: ls, question: "Likely causes and tests?" } }
  shard "rca" {
  }
    }
      budget: { tokens: 800, wall_ms: 2000, calls: 4 }
      tools: ["logs.query"]
      inputs: { query: "p95 latency spike", slice: HHNI:system->section("Observability") , time: WINDOW:2025-10-10T12:00:00Z..2025-10-10T13:00:00Z }
    step ls: Retriever {
  shard "ingest" {
  header { snapshot: "snap-2025-10-10"; seeds: 42; budgets: { tokens: 60k, wall_ms: 60000, calls: 120 } }
pipeline "ops.rca.api-latency.v1" {
13.14.3 Ops RCA (logs→hypotheses→checks→decision)
}
  }
    step w:      Witness    { inputs: { trace: ALL } }
    gate policy: PolicyGate { inputs: { artifacts: code }, policy: license_policy }
    step tests:  Operator   { inputs: { cmd: "jest --coverage" } }
    gate diff:   DiffGate   { inputs: { artifacts: code } }
    gate parity: ParityGate { inputs: { spec: spec, artifacts: code }, strict: true }
    }
      budget: { tokens: 3500, wall_ms: 10000, calls: 10 }
      tools: ["git.patch","tsc","jest"]
      inputs: { spec: spec, codebase: HHNI:system->section("code")->folder("services/auth") }
    step code: Builder {
    }
      budget: { tokens: 2500, wall_ms: 4000, calls: 4 }
      inputs: { question: "Produce OpenAPI for Auth svc: login, refresh, mfa" , slice: HHNI:system->section("Auth") }
    step spec: Reasoner {
  shard "spec-and-solve" {
  }
    budgets: { tokens: 180k, wall_ms: 180000, calls: 420 }
    seeds: 7
    snapshot: "snap-2025-10-01"
  header {
pipeline "builder.auth-service.v2" {
13.14.2 Builder pipeline (spec→code→tests→parity)
}
  }
    step w: Witness { inputs: { trace: ALL } }
    gate prov: ProvenanceGate { inputs: { witness: v } }
    gate uq: UQGate { inputs: { uq: r } }
    step v: Verifier { inputs: { claims: r, evidence: evidence } }
    step r: Reasoner { inputs: { evidence: evidence, question: "What new threats post-2024?" } }
  shard "analysis" {
  }
    reduce doc[1..64] -> evidence using merge=maxRS
    fanout q -> doc[1..64] with anchors=super_index
    }
      policy: sec_web_readonly
      budget: { tokens: 1200, wall_ms: 2500, calls: 8 }
      tools: ["web.search","pdf.extract"]
      inputs: { query: "latest oauth2 threat models", slice: HHNI:system->section("Security") }
    step q: Retriever {
    caps { max_parallel: 32, token_pool: 40k }
  shard "retrieval" {
  }
    pins: { model: "gpt-4o@sha256:ab12…" }
    budgets: { tokens: 120k, wall_ms: 90000, calls: 240 }
    seeds: 101
    snapshot: "snap-2025-10-01"
  header {
pipeline "research.oauth2.threats.v1" {
13.14.1 Research pipeline (literature sweep → claim)
13.14 Worked examples
: tool processes run jailed; network egress by allow-list.
Sandboxing
; redaction policies enforce PII/PHI constraints.
provenance
 logged with 
Data egress
 bound per step/shard; default deny.
Capabilities
13.13 Security model
.
witness
 and 
ChainDiff
: risky diffs route to human review with 
Quarantine/HITL
 (Chapter 12).
rewrite controller
: on gate fail/low RS/over-budget invoke 
Rewrite hooks
with jitter; non-idempotent require policy exception.
: idempotent steps may retry 
Retries
 on overruns.
back-pressure
: weighted fair-share across shards; local token pools; 
Shard scheduler
13.12 Runtime semantics (scheduler)
 (warnings): oversize prompts, missing UQ emission, fanout without reduce, policy wildcard, etc.
Lints
 at all boundaries (in/out of shard, before merge).
Gate coverage
 (no dangling indices).
HHNI selector validity
 present on frontier nodes.
Determinism pins
 (no illegal effect paths).
Policy reachability
 (sum of min-costs ≤ caps).
Budget feasibility
 across edges.
Type & kind checking
13.11 Static analyses & lints
 for scheduling, replay, and audit.
source of truth
This IR is the 
}
  ]
    }
      "edges":[{"from":"r0","to":"r[1..128]","type":"fanout","opts":{"anchors":"super_index"}}]
      ],
        {"id":"r0","role":"Retriever","iotype":{"in":["Query","Slice"],"out":["Evidence[]","UQ","Witness"]},"budget":{…},"pins":{…},"policy":"sec_web_readonly"}
      "nodes": [
      "caps": {"max_parallel":64,"token_pool":60000},
      "id": "retrieval.sweep",
    {
  "shards": [
  "snapshot": "snap-2025-10-01",
  "pipeline": "depp.app-blueprint.v3",
{
:
canonical IR
The compiler emits a 
13.10 Compilation & IR mapping
 is an edge, not deletion.
contradiction
 are append-only facts with temporal validity; 
SEG writes
 binds reads to ASOF:2025-10-12T00:00:00Z or WINDOW:….
Time slicing
 scope retrieval: HHNI:system->section("Auth")->paragraph#3.
HHNI selectors
13.9 Memory-native reads & SEG writes
}
  reduce fix[1..max_iter] -> pick using adjudicate=verifier
  fanout c0 -> fix[1..max_iter]
  step c0: Critic { inputs: { code: code_in } }
flow refine(code_in, max_iter=3) {
:
bounded loops
 is expressed as 
Iterative refinement
.
no unbounded loops
 for parallelism; 
Fanout/fanin
13.8 Control flow (bounded)
.
least-privilege
 can be applied per step/shard/pipeline; resolved 
Policies
 are content-addressed; compiler caches by hash.
Imports
}
  require HITL for merges touching policy shards
  on over_budget                  => refactor node shrink=true
  on low_RS or high_UQ            => splice Verifier(rs_boost) before consumer
  on gate_fail(policy|provenance) => quarantine region
policy rewrite {
import flow   "flows/spec_and_solve.acl" as s2
import policy "policies/security.aclp" as sec
13.7 Namespaces, imports, and policies
 (+ witness) into SEG.
GateRecord
Every gate emits a 
: prevents destructive or outsized changes (size/scope thresholds).
DiffGate
: calibration and uncertainty bands (ECE/entropy/ensemble consistency).
UQGate
: VIF completeness: (model id, weights hash, prompt template id, tool ids, snapshot id, seeds).
ProvenanceGate
: data residency, PII/PHI filters, license compliance.
PolicyGate
: code/spec/tags/traces parity (SDF-CVF).
ParityGate
13.6 Gates & witnesses
.
abstain
 (modulo allowed float error windows) or 
bit-identical artifacts
 If pins + snapshot identical, runtime must produce 
Determinism contract.
 freeze versions: model:"gpt-4o@sha256:…", index:"hhni:auth@v37", tool:"grep@1.2.5", seed:"1337".
Pins
 hard-fail when exceeded unless soft=true in header policy (discouraged).
Budgets
13.5 Budgets & pins
}
  policy: sec_web_readonly
  budget: { tokens: 800, wall_ms: 1500, calls: 3 }
  tools:  ["web.search"]
  inputs: { query: "oauth2 threat models", slice: HHNI:system->section("Security") }
step r0: Retriever {
Example (cap-limited step):
 bound at runtime to principals/tenants, scoped per step/shard.
Capability tokens
: net.read, net.write, fs.read, fs.write, proc.exec, secrets.read, mail.send, db.query, seg.write.
Effects
 to constrain tool power and data egress.
effects
ACL annotates 
13.4 Effects & capabilities
 Compiler checks edge compatibility by kind + JSON Schema. Subtyping via $ref and oneOf. Mismatches → compile error.
Static typing.
Actions, Hints, UQ
Telemetry
Operator
Review notes, Risk score, UQ
Any
Critic
VIF tuples, SEG writes
Trace, Metadata
Witness
Code/Artifacts, Diffs, UQ
Spec/Plan, Codebase slice
Builder
Verdicts, Critiques, UQ
Claim[], Evidence[]/Artifacts
Verifier
Claim[], Explanation, UQ
Evidence[], Spec/Question
Reasoner
Evidence[], UQ, Witness
Query(JSON), HHNI slice, Time slice
Retriever
Output kinds
Input kinds
Role
 (illustrative):
Role I/O contracts
: JSON Schemas referenced by $id.
Structural types
: Artifact, Claim, Evidence, Trace, Blob, JSON, Table, Code, Spec, Diff, UQ, Witness.
Kinds
13.3 Types, kinds, and schemas
 per policy.
quarantine
 or 
rewrite
 Each step returns (artifacts, witness, uq). Gates consume these to decide pass/fail; failures raise 
Execution invariant.
: nested subgraph (macro) for reuse; inlined at compile unless marked export.
flow
: parallelization primitives (map→reduce, debate→adjudicate, etc.).
fanout/reduce
 before downstream steps read outputs.
succeed
: a typed check; must 
gate
.
policy
, 
pins
, 
budget
, 
model/tools
 selectors, 
slice/time
, 
inputs
, 
role
: a typed unit of work with 
step
: isolation domain with its own resource caps and routing; independently schedulable.
shard
.
global budgets
 and 
snapshot pin
: top-level plan with 
pipeline
13.2 Core constructs & semantics
 UTF-8, \" escapes supported.
Strings.
 // line, /* block */ ignored.
Whitespace/comments.
path          = /* URI-like selector with filters */ ;
bool          = "true" | "false" ;
seg_ref       = "SEG:", path ;
tool_list     = "[", string, { ",", string }, "]" ;
model_ref     = string ;
policy_ref    = ident ;
time_sel      = "ASOF:", iso8601 | "WINDOW:", iso8601,"..",iso8601 ;
hhni_sel      = "HHNI:", path ;           (* e.g., HHNI:system->section("Auth")->paragraph#3 *)
input_kv      = ident, ":", ( string | ident | hhni_sel | seg_ref ) ;
input_map     = "{", input_kv, { ",", input_kv }, "}" ;
pin_kv        = ("model" | "index" | "tool" | "seed"), ":", string ;
pin_map       = "{", pin_kv, { ",", pin_kv }, "}" ;
cap_kv        = ("max_parallel" | "token_pool" | "wall_ms_pool"), ":", integer ;
budget_kv     = ("tokens" | "wall_ms" | "calls" | "cost"), ":", integer ;
budget_map    = "{", budget_kv, { ",", budget_kv }, "}" ;
ident_range   = ident | ident, "[", integer, "..", integer, "]" ;
reduce_op     = "merge=maxRS" | "vote=majority" | "score=mean" | "adjudicate=verifier" ;
reduce        = "reduce", ident_range, "->", ident, "using", reduce_op ;
fanout        = "fanout", ident, "->", ident_range, [ "with", fanout_opts ] ;
flow          = "flow", ident, "{", { decl }, "}" ;
gate_type     = "ParityGate" | "PolicyGate" | "ProvenanceGate" | "UQGate" | "DiffGate" ;
               "}" ;
                  [ "strict", ":", bool ],
                  [ "policy", ":", policy_ref ],
                  "inputs", ":", input_map,
gate          = "gate", ident, ":", gate_type, "{",
role          = "Retriever" | "Reasoner" | "Verifier" | "Builder" | "Critic" | "Operator" | "Witness" ;
               "}" ;
                  [ "policy",":", policy_ref ],
                  [ "pins",  ":", pin_map ],
                  [ "budget",":", budget_map ],
                  [ "tools", ":", tool_list ],
                  [ "model", ":", model_ref ],
                  [ "time",  ":", time_sel ],
                  [ "slice", ":", hhni_sel ],
                  [ "inputs", ":", input_map ],
step          = "step", ident, ":", role, "{",
decl          = step | gate | flow | fanout | reduce | policy_block ;
               "}" ;
                  { decl },
                  [ "caps", "{", cap_kv, "}" ],
shard         = "shard", string, "{",
               "}" ;
                  [ "policy", ":", policy_ref ],
                  [ "pins", ":", pin_map ],
                  "budgets", ":", budget_map,
                  "seeds", ":", integer,
                  "snapshot", ":", string,
header        = "header", "{",
pipeline      = "pipeline", string, "{", header, { shard }, "}" ;
13.1 Surface syntax (EBNF)
.
SDF-CVF parity
 Pipelines shard/compose like software modules; changes must pass 
Composability.
 facts, never mutate memory directly.
SEG
 and time-slices; writes emit 
HHNI selectors
 Reads target 
Memory-native.
.
gates
 (provenance + UQ) and passes 
witness
 Every boundary emits 
Governed I/O.
 Tokens/time/calls/cost are first-class and enforceable.
Budget-first.
).
 Same snapshot, same seeds, same tools → same trace (or abstain, 
Determinism under pins.
13.0 Design goals (non-negotiables)
.
auditable under VIF/SEG
 and 
repeatable under pins
 language for declaring APOE/DEPP plans. It gives you typed pipelines, explicit budgets, policy-aware gates, and machine-readable provenance so plans are 
legible, versionable, executable
 ACL is the 
Purpose.
Chapter 13. ACL — AIMOS Chain Language
Part IV — Orchestration: APOE & DEPP
Export pack (SEG) reproducible for the plan.
, BA, D, LC, RSC healthy.
Dashboards show 
.
Replay passes on frozen snapshot; determinism 
Rewrite policy installed; quarantine & HITL paths wired.
Shards have token pools & caps; router rules documented.
DAG validates (types, gates, pins, budgets, seeds).
12.8 Checklists (ship readiness)
Quarantine region; run redaction pipeline; require HITL; log contradiction edge in SEG (do not delete).
When policy gate fails
Reduce fan-out; enforce shorter completions; split shard; push more work to retriever/critic before reasoner.
When token slope spikes
Check pin drift (models/indexes/tools); re-pin or roll back snapshot; recompute seeds; replay sample traces.
drops
When determinism 
Inspect RS histograms; widen HHNI slice; enable DVNS refinement; raise model tier for frontier nodes.
When κ triggers repeatedly in a shard
12.7 Runbook (operators & builders)
: Every emission carries VIF: model id, weights hash, prompt-tpl id, tool ids, snapshot id, seeds, UQ vector.
Provenance
: Any change that emits code/spec/tag/trace must pass SDF-CVF parity gates in one atomic commit.
Parity
 events).
snapshot
 (no direct mutation of memory state; new state arrives via 
SEG
, and 
witness
, 
trace
: Only to 
Writes
 computed with QS·IDS·(1–DD).
RS
 and time-slices; 
HHNI scopes
: DEPP steps read via 
Reads
12.6 Interfaces: DEPP ↔ CMC/HHNI ↔ SEG ↔ SDF-CVF
}
  require HITL for merges touching policy shards
  on over_budget => refactor node shrink=true
  on low_RS or high_UQ => splice Verifier(rs_boost) before consumer
  on gate_fail(policy|provenance) => quarantine region
policy rewrite {
12.5.2 Rewrite policy
}
  }
    step w: Witness  { inputs: { trace: ALL } }
    step v: Verifier { inputs: { claims: spec, artifacts: solve } }
  shard "verify-and-witness" {
  }
    gate parity: ParityGate { inputs: {spec, solve} }
    step solve: Builder  { inputs: spec }
    step spec: Reasoner { inputs: r_reduce; role: "SpecWriter" }
  shard "spec-and-solve" {
  }
    reduce r[*] -> r_reduce using merge=maxRS
    fanout r0 -> r[1..128] with anchors=super_index
    step r0: Retriever { inputs: { query: "all blueprint reqs", slice: "HHNI:system->section" } }
    caps { max_parallel: 64, token_pool: 60k }
  shard "retrieval.sweep" {
  }
    budgets: { tokens: 220k, wall_ms: 120000, calls: 480 }
    seeds: 1337
    snapshot: "snap-2025-10-01"
  header {
pipeline "depp.app-blueprint.v3" {
12.5.1 Thousand-node skeleton (excerpt)
12.5 ACL (AIMOS Chain Language) snippets for DEPP
Token budget overrun incidents ≤ 1 per 1,000 plan runs.
κ false-negative rate ≤ 2% on critical domains.
≥ 0.97.
≥ 0.98; Lineage completeness 
Determinism 
p95 step latency: Retriever ≤ 900 ms, Reasoner ≤ 3.5 s, Verifier ≤ 1.2 s.
12.4.5 Performance targets (reference)
 DVNS on super-index nightly.
pre-compute
: prefetch HHNI anchors for next K steps; 
Warm caches
 for risky rewrites; HITL triage with diffs & ChainDiff witness.
Quarantine queues
 to alternates.
shadow routing
 for flaky tools; automatic 
Circuit breakers
12.4.4 Failure handling & resilience
.
frontier nodes
: use small/fast models for broad sweeps, escalate to slow/accurate on 
Model tiering
 at start/end of prompts.
salient edges
: dumbbell compression + HHNI slices keep 
Context compaction
 under caps; hard stop at plan cap.
borrowing
 per shard with 
Token pooling
12.4.3 Token & memory budgets at scale
 compares spec↔artifact.
Parity Gate
: spec writer and solver proceed in parallel; 
Spec-and-Solve
 adjudicates with rubric.
Verifier
 (2–3 critics) on high-stakes claims; 
Debate×K
 for literature/codebase sweeps.
Map→Verify→Reduce
12.4.2 Parallel exec patterns
 (teams/tenants; enables independent releases).
Ownership shards
 (network-bound vs. CPU/GPU-bound).
Latency shards
 (PII regions, licensed content, export-restricted zones).
Policy shards
 (retrieval, reasoning, verification, build).
Functional shards
12.4.1 Partitioning strategies
12.4 Large-Scale Planning (thousands of nodes)
 to tune budgets and router rules.
role × domain
Aggregate per 
Emit OpenTelemetry spans: step.exec, gate.run, rewrite.apply, dvns.refine.
Telemetry plumbing
 when RSC drops below target for a shard (e.g., < 0.85).
auto-rewrite
Suggest 
of forecast.
slope exceeding 
Page on 
 > 0 in last hour.
policy gate fails
, or 
, 
Redline if 
Dashboards & thresholds
 (detect bottlenecks).
mean gate latency
 and 
Gate pass rate (GPR)
.
UQ ≤ 
and 
RS ≥ 
: share of accepted answers whose 
RS-coverage (RSC)
 present and valid hashes.
VIF tuples
: fraction of artifacts with 
Lineage completeness (LC)
(Accept within hashing tolerance on float outputs.)
Re-run N sampled subtraces;
 under pins:
Determinism score (D)
 (burn rate) not just level.
slope
Alert on 
:
 per class 
Budget adherence (BA)
 of abstentions vs. later ground truth (should catch bad cases without blocking good ones).
precision/recall
Track 
(abstention health):
Core metrics
all shards.
be all steps, 
Let 
12.3 Chain-Health Metrics (compute & act)
    return plan  # no-op
        return reroute(plan, targets=affected_edges(plan, event))
    if cause == "new_snapshot":
        return refactor(event.node, into=["RetrieverLite","ReasonerShort"], shrink=True)
    if cause == "over_budget":
        return splice(plan, before=event.node, with_="Verifier(rs_boost)")
    if cause in {"low_RS","high_UQ"}:
        return quarantine(plan.region(event.region), reason="policy")
    if cause == "policy_violation":
    cause = classify(event)  # gate_fail, low_RS, over_budget, policy_violation, new_snapshot
def maybe_rewrite(event, plan, telemetry):
12.2.4 Rewrite controller (pseudocode)
: policy distance must not shrink below thresholds.
Policy non-regression
: re-execute altered region on the same snapshot to confirm determinism.
Replay check
: if any edit touches code/spec/tags/traces, the quartet must pass parity gates in the same commit.
SDF-CVF parity
12.2.3 Consistency & parity
 with: reason_codes, old/new IR fragments, witness tuples, HITL approvals (if any).
ChainDiff
All edits produce a 
 cut a subgraph off the main line; park for human review.
Quarantine:
 only with gates + HITL if needed.
merge
 create a branch for risky exploration; 
Fork:
 split one bulky node into a micro-pipeline (maintain I/O contract).
Refactor:
 rebind inputs to a different retriever/index or model tier.
Reroute:
 insert a local verifier/critic step between nodes.
Splice:
 change ordering/weights of edges without topology change.
Rescore:
12.2.2 Rewrite primitives (safe graph edits)
 vs. budget envelope.
Cost/latency breach
 (new snapshots, user constraints, incident alerts).
External events
 (retrieval or reasoning uncertainty).
high UQ
 or 
Low RS
 (policy/UQ/provenance/diff).
Gate failure
12.2.1 Triggers
 when evidence or policy requires, and it leaves a trail.
only
DEPP changes itself 
12.2 Self-Rewrite via Evidence
 mark deprecations.
tombstones
; 
 tie reads to memory state 
Snapshot pins
 stores lineage (claim↔evidence↔decision).
SEG
All intermediate artifacts live in content-addressed blobs; 
12.1.4 Persistence & cross-links
.
PlanTrace
; plan emits 
ShardRecord
; shard emits 
StepRecord
: every gate emits a 
Checkpointing
: map → verify → reduce; debate → adjudicate; spec-and-solve.
Parallelization
 with back-pressure.
per-shard pool
 enforces a 
Token scheduler
 chooses model tiers and tool stacks per shard.
Router
12.1.3 Scheduling & execution
Co-locate steps whose inputs share HHNI anchors (cache locality).
 and high-latency tools (network isolation).
policy boundaries
Split shards at 
 when token budgets are tight.
wide-flat
 over 
deep-thin
Prefer 
Heuristic knobs
 points.
fan-out/fan-in
; annotate 
stable edge ordering
 Create DAG with 
Topological layout.
 to pre-rank anchors and reduce lost-in-the-middle effects.
Dynamic Vector Navigation
 For retrieval-heavy shards, seed 
DVNS kick.
 per shard.
reserve
 Estimate token/time/calls by historical medians (per role × domain) and 
Budgeting.
.
policy regions
, and 
time windows
 (system→…→sub-word indices), 
HHNI slices
 Each candidate step binds to 
Scope binding.
 Planner extracts sub-goals & constraints and emits candidate roles (retriever/reasoner/builder/verifier/critic).
Intent split.
12.1.2 Assembly (from goal → graph)
}
  pinned_snapshot, router_rules
  resource_caps{max_parallel, token_pool, wall_ms_pool},
  id, purpose, dependencies[],  # other shard ids
Shard {
Shard header
.
merge operator
, and 
fan-out policy
 (HHNI slice, time-slice), 
scope
: typed channel with 
Edge 
}
  inputs_ref, outputs_ref, witness, uq
  policy_slice, gates[],  # policy, UQ, provenance, diff, HITL
  pins{model@hash, index@id, tool@ver, seed},
  budget{tokens, wall_ms, calls, cost$},
  id, role, schema_in, schema_out,
Step {
:
Node (step) 
for scale and isolation.
 
shards
partitioned into 
: DAG 
Plan 
12.1.1 Canonical graph model (IR)
12.1 Master Chain as Graph
.
HITL two-key
 All chain edits pass SDF-CVF parity and policy gates; high-risk edits require 
Governed merges.
).
 (
abstain
 With fixed snapshot, seeds, and tool/version pins, the same inputs yield the same trace—or 
Determinism under pins.
.
witnessed diff
 (new evidence, failed gates, user input) and always emits a 
changes only for cause
 Chain structure 
Evidence-driven evolution.
 that executes under token/time/tool budgets.
typed, sharded DAG
 Breaks big goals into a 
Long-horizon tractability.
12.0 What DEPP guarantees
—graph-native, evidence-seeking, and self-rewriting under guardrails.
DEPP is the compiled program’s runtime
, adapt to new evidence, and stay reproducible under budgets and policy. If APOE is the compiler, 
thousands of steps
 that can span 
living, governed plan
 Turn a messy, evolving program of work into a 
Purpose.
Chapter 12. Dynamic Emergent Prompt Pipeline (DEPP)
Part IV — Orchestration: APOE & DEPP
Operator dashboard tiles populated.
κ reasons render actionable “next questions”.
Replay passes on frozen snapshot.
.
All steps declare gates; HITL paths wired for risk ≥ 
Plan IR validates (types, budgets, pins, seeds).
11.13 Checklists (shiproom)
 nondet drift, κ spike by domain, policy-violations, budget burn anomalies.
Alerts:
 chain determinism %, κ precision/recall, budget adherence, p50/p95 latency, cost per plan, lineage completeness.
Metrics:
 plan.build, step.exec, ann.search, dvns.refine, gate.run, kappa.abstain, witness.emit.
Spans:
11.12 Observability (what the operator sees)
 mandatory in CI for critical plans.
Snapshot replay
.
new id
 are immutable; diff produces a 
Prompt template ids
 everywhere; forbidden to rely on map iteration order.
Stable sorts
; reject execution if a pin cannot be honored.
Pin versions
; expose seed in every witness.
Seed all randomness
11.11 Determinism Toolkit
}
  "budgets":{"tokens":18000,"wall_ms":8000,"calls":12}
  "seeds":42,
  "pins":{"retriever.index":"ann-idx-2025-09","reasoner.model":"gpt-X-safe@sha256:..."},
  "version":"11.0",
  "name":"policy-sum-v1",
{
PlanManifest
}
  "spans":[{"name":"llm.call","ms":812}]
  "gates":{"policy":"pass","uq":"pass","schema":"pass"},
  "uq":{"entropy":0.19,"ece":0.05,"rs_margin":0.21},
  "witness":{"model":"gpt-X-safe","weights":"sha256:...","prompt_tpl":"tpl-17","tools":[], "snapshot":"snap-2025-10-01"},
  "artifacts_ref":"blob://.../claims.json",
  "budget":{"tokens":10000,"wall_ms":3500,"calls":0},
  "inputs_hash":"sha256:...",
  "role":"Reasoner",
  "id":"reason-1",
{
StepRecord
11.10 Core Data Structures (canonical)
emit: JSON-LD lineage with model/weight hashes, prompt-tpl id, tool invocations, snapshot id.
verify: per-claim decision with rule id.
reason: UQ bands; calibrated confidence.
retrv: RS distribution, anchors used, κ=false.
Expected boundary emissions:
}
  }
    verify -> emit
    reason -> verify
    retrv -> verify
    retrv -> reason
  edges {
  }
    outputs: { report: JSON-LD, lineage: SEGPatch }
    inputs: { verdict: verify.verdict, claims: reason.claims, trace: ALL }
  step emit: Witness {
  }
    gates: [ provenance_gate ]
    outputs: { verdict: PASS|FAIL, deltas: Diff[], witness: VIF }
    budget: { tokens: 3k, wall_ms: 1200 }
    inputs: { claims: reason.claims, evidence: retrv.topk }
  step verify: Verifier {
  }
    gates: [ policy_gate, uq_gate ]
    outputs: { claims: ClaimSet, witness: VIF, uq: UQ }
    budget: { tokens: 10k, wall_ms: 3500 }
    inputs: { evidence: retrv.topk }
  step reason: Reasoner {
  }
    outputs: { topk: EvidenceSet, witness: VIF, uq: UQ }
    budget: { tokens: 2k, wall_ms: 800, calls: 2 }
    inputs: { query: "policy summary + citations", slice: "2024-01..2025-10" }
  step retrv: Retriever {
  }
    budgets: { tokens: 18k, wall_ms: 8000, calls: 12 }
    model_tiers: { retriever: "embed-001", reasoner: "gpt-X-safe", verifier: "critique-small" }
    seeds: 42
    snapshot: "snap-2025-10-01"
  header {
plan "policy-sum-v1" {
 “Summarize policy doc and cite sources with time slice.”
Goal:
11.9 Minimal Runnable Example (plan IR)
: snapshot id + Merkle root over inputs → witness includes signature.
Signed snapshots
 (ids) not raw data when possible.
handles
: redact PII; pass 
Data minimization
: structured templates; strip & neutralize tool-returns; literal-block untrusted text.
Prompt hygiene
 (network egress allow-list; fs paths jailed).
Sandboxed tools
 per tool with least privilege & time-boxed scopes.
Capability tokens
11.8 Security Posture (execution hygiene)
circuit breaker; backoff; alternate tool path
API 5xx, timeout
Tool failure
block merge (SDF-CVF); open auto-fix PR; require HITL
code passes tests but violates spec
Spec drift
reseed & replay; if persists, flag tool/version drift
nondet beyond tolerance
Stochastic
expand anchors; widen time-slice; run DVNS with diversity boost
missing anchors; low RS
Data
κ-abstain; planner suggests scope/budget edits
budget exceeded; policy wall
Constraint
System Reaction
Example
Class
11.7 Failure Taxonomy & Recovery
 with escalations.
quarantine branch
 (if known), else 
auto-fix
 
⇒
Failure 
.
 two-key approval if risk score ≥ 
HITL gate (risked):
 parity spec↔code; tests ≥ coverage floor.
Diff gate (build/test):
 VIF tuple complete; hashes present.
Provenance gate:
 ECE within tolerance; entropy below threshold.
UQ gate:
 SEG constraints pass; no forbidden crossing.
Policy gate:
 inputs/outputs match contract (JSON Schema / SHACL).
Schema gate:
:
gate bundle
Each step ends with a 
11.6 Boundary Gates (quality & safety)
 (builder) require human or new snapshot/branch.
Non-idempotent
 (extra anchors, widened slice).
anchored perturbations
 steps (retriever) may retry with 
Idempotent
Retry policy
 (no dominated solution on RS, cost, policy distance).
Pareto
 (use UQ as weight).
Weighted majority
 / 
Borda
 (pick path with highest RS under policy-clean).
Max-RS
Merge operators
 planner spawns spec writer and solver; critic cross-checks parity.
Spec-and-Solve:
 2–3 reasoners argue; verifier adjudicates using rubric.
Debate:
 fan-out retrievers/reasoners; verifier collapses with majority/weighted vote.
Map → Verify → Reduce:
Parallel patterns
.
policy slices
, and 
tool stacks
 (fast vs. accurate), 
model tiers
 (lightweight classifier): routes intents to pipelines & chooses 
Router
11.5 Routing, Parallelization, Retry
Output: reason codes, suggested “next questions”, and minimal witness to replay context.
.
abstain
 
⇒
 
and
If 
Decision
: distance to forbidden region
Policy
: ECE (expected calibration error) bucket
Calibration
: RS dispersion (top-k margin, path consensus)
Retrieval
: entropy / variance (ensembles or temp sweep)
Model
(per boundary)
UQ vector 
& Uncertainty Emission (boundary behavior)
11.4 
 emit κ-abstain + next-best actions.
Fail-closed:
 boundaries (logs a reason).
witness-critical
 optional one-shot overrun for 
Grace step:
 shrink fan-out or shorten completion length if budget burn rate > slope.
Soft throttle:
Runtime adaptation
 planner rewrites with smaller fan-out / deeper caches / cheaper models.
⇒
If estimate breaches ceiling 
.
tool latency histograms
, 
avg completion
, 
fan-out
, 
emb len
Static estimate using 
Preflight
 estimated $ or GPU-ms envelope (operator view).
Cost:
 tool/API invocations (capability tokens).
Calls:
 wall-clock per step and plan total.
Time:
 prompt+completion tokens per step and plan total.
Tokens:
Budget classes
11.3 Budgeting & Scheduling
if nondet > tolerance.
Bound: sampling via fixed seeds and temperature schedules; otherwise 
 (doc-id, then shard-id).
stable sort key
Fix: top-k tie-breakers by 
Pin: model id, weights SHA, prompt template id, tool version, ANN index snapshot id.
Determinism discipline
 (version/weights hash) live in the plan header.
tool pins
 (PRNG) and 
Seeds
.
budget pass-throughs
, and 
policy region
 (HHNI indices, time-slice), 
scope
 annotate 
Edges
 (schemas).
typed channels
are steps with signatures; edges carry 
where 
is a DAG 
Plan 
11.2 Plans as Typed DAGs (the APOE “IR”)
  gates:   Gate[]      # pass/fail with reasons
  returns: { artifact: T_out, witness: VIF, uq: UQ }
  effect:  { read(M_t), read(G), write(trace) }
  budget:  { tokens, wall_ms, calls }
  tools:   ToolCaps[]
  inputs:  T_in
step S<T_in, T_out>:
Contract sketch (per step, abstract type)
 sufficient for replay & audit.
machine-readable summaries
*The Reasoner’s internal chain needn’t be fully exposed; but it must emit 
completeness %
snapshot-id, time slice, lineage
signed log/JSON-LD
all above
Witness
SLO conformance
tool usage, tokens, time
execution spans, costs
plan, env
Operator
defect density
rubric id, bias checks
review notes, risk score
artifact, rubric
Critic
build success, parity
toolchain hashes, diffs, compile logs
code, configs, migrations
spec, scaffolds
Builder
false-accept/false-reject
tests run, criteria, thresholds
acceptance/reject, deltas
claims, evidence
Verifier
coherence score, ECE
chain-of-thought summary*, UQ bands, seeds
structured claims, derivations
facts, rules, prompts
Reasoner
p@k, RS-lift
ANN index id, params, κ status, RS & UQ
top-k set, evidence paths
query, HHNI scope, policy slice
Retriever
plan validity %, budget fit
model+hash, prompt-tpl, seed, RS of retrieved reqs
plan DAG, budgets, role bindings
goal, constraints, snapshot-id
Planner
Quality KPI
Witness (must include)
Outputs (Artifacts)
Inputs
Role
 with strict I/O and a witness envelope. Roles may be chained, branched, or run in parallel.
typed step
Each role is a 
11.1 Role Model & Contracts
 No path may cross forbidden regions (SEG/guardrails) even if quality scores tempt it.
Policy-clean.
 Declared token/time/tool budgets bound execution; overruns fail closed with a reason code.
Budget honesty.
 Every boundary produces a witness tuple (model, weights-hash, prompt-tpl, tools, snapshot-id, UQ).
Lineage-first.
).
 (
abstain
within stochastic tolerance; else 
 identical trace 
⇒
(snapshot), tool versions, budgets, and seeds 
 Given fixed 
Reproducibility.
11.0 Guarantees (what APOE must uphold)
 that execute deterministically on top of CMC/HHNI and emit VIF-grade witnesses. APOE is the compiler; DEPP (Ch.12) is the large-scale planning fabric it feeds.
typed, budgeted, and auditable plans
 Convert messy intent into 
Purpose.
Chapter 11. Cognitive Compilation (APOE)
Part IV — Orchestration: APOE & DEPP
: spans, metrics, and a witness panel that satisfies VIF.
First-class observability
 with one-click mitigations (lower Δt, raise c, add anchors).
Failure-mode playbooks
 that adapt parameters safely per domain/tenant.
Auto-tuning guardrails
 that starts from top-k, refines locally, and emits auditable paths.
A deterministic, GPU-friendly DVNS runtime
What you can ship today
}
  }
    "path":["seg://adr/001","doc://spec#sec3","code://module/auth.ts"]
    "vif":{"model":"apoe-hyena-64k","weights_sha":"...","prompt_tpl":"ptl-42","tools":["seg.query@1.2"],"snapshot":"snap-2025-10-01"},
    "traceId":"t-...-abc",
  "witness": {
  "policy": {"violations":0,"forbidden_crossings":0},
  "score": {"RS":0.87,"UQ":{"ece":0.06,"entropy":0.21}},
  "spans": [{"name":"dvns.integrate","took_ms":7.1,"ΔE":[-0.22,-0.08,-0.03]}],
  "params": {"G":1.2,"k":0.8,"sigma":0.25,"rho":0.16,"c":0.18,"dt":0.2,"T":12,"r":16},
  "queryId": "q-...-001",
  "@type": "DVNSRun",
{
Logging schema (JSON-LD excerpt)
 button: executes on frozen snapshot; diff shown if any non-determinism flag was raised.
Replay
.
(model id, weights hash, prompt template id, tools, snapshot id)
with policy checks; VIF tuple 
Claim, RS, UQ bands; path 
Witness panel (per result)
: violations by rule; before/after DVNS projection.
Policy Map
: abstentions by reason; post-hoc human acceptance %.
κ Outcomes
: time-series of G,k,σ,c per tenant/domain.
Param Drift
vs. t; annotate mitigations.
: 
Energy Curve
: stacked spans per query with latency breakdown.
Flow Strip
Dashboards (tiles)
: oscillation rate; convergence steps; early-exit rate.
Stability
: median/95p latency; GPU-ms per query; tokens (if LLM rerankers used).
Cost
: policy-clean %, κ precision/recall, lineage completeness %.
Safety
: p@k, nDCG, RS-lift vs KNN baseline.
Quality
Metrics
: oscillation_detected, collapse_prevented, policy_wall, abstain.
Events
, r, T, ΔE trajectory, param snapshot {G,k,σ,ρ,c,Δt}, κ result, RS, UQ, policy violations.
, k
: k
Attributes
: ann.search, seg.filter, dvns.integrate, dvns.pathfind, gate.kappa, witness.emit.
Spans
Spans & events (OpenTelemetry)
10.4 Visualization & Telemetry
 (ask for time-slice, add source, or relax scope).
next actions
Emit: reason codes, UQ bands, top three 
 witness set below min cardinality.
(iii)
, 
 policy-clean path not found within L
(ii)
, 
 & UQ > τ
 RS < τ
(i)
κ triggers when 
Abstention best-practice (κ)
Super-index seeding; ANN cache
lower r/T; enable early exit
r,T too high; ANN retries
Latency spikes
Dedup at readout with hash-LSH
↑ρ; ↑σ
ρ too small; σ too low
 (near-dup results)
Redundancy
Basin-aware neighbor sampler
↑r; ↓σ; ↑T by +2
r too small; σ too high
 (low p@k)
Sparse recall
SEG “bridge lists” with audit tags
broaden allowed bridge set; widen slice
Forbidden edges; time slice too strict
 (no feasible path)
Policy wall
Super-index multi-basin seeding (§9.3)
add alternative anchors; ↓k
Bias from anchors; k too high
 (stuck in wrong cluster)
Attractor lock
Diversity guard: min-distance constraint
↑σ, ↑ρ; ↓G
σ/ρ too low; G too high
 (everything clumps)
Collapse
Adaptive damping; neighbor pruning policy
↓Δt; ↑c; cap r
Δt too high; c too low; dense neighbors
 (positions bounce)
Oscillation
Permanent Fix
Fast Mitigation
Likely Cause
Symptom
10.3 Failure Modes (and Fix Kits)
    - "repo://main/README"
    - "spec://adr/001"
  anchors:
    gamma: 0.1
    beta: 0.2
    alpha: 0.5
  path_cost:
    neighbors: 16
    steps_max: 12
    dt: 0.20
    c: 0.18
    rho: 0.16
    sigma: 0.25
    k: 0.8
    G: 1.2
  params:
  domain: "code"
dvns:
Config example (YAML)
 → ↑c (×1.5), ↓Δt (×0.75), shorten T.
oscillation
If 
 → ↑σ or ρ, ↑r a notch.
duplicative hits
If 
 (wider uncertainty) → add anchors, ↑k slightly, ↓σ.
UQ↑
If 
Runtime adaptors
; decay to global defaults if sparse.
per-tenant profiles
Persist 
Constrain drift: max 1 param change (±10%) per deployment window.
.
with reward
Contextual bandit (UCB/Thompson) over tuples 
Auto-tuning loop (bandit over safe ranges)
.3/.3/.3
20
10
0.20
0.20
0.20
0.45
0.6
0.9
Log forensics
.5/.2/.1
16
12
0.20
0.18
0.16
0.25
0.8
1.2
Code reasoning
.4/.2/.2
12
8
0.25
0.12
0.18
0.35
0.4
1.0
Ad-hoc QA
α/β/γ
r
T
Δt
c
ρ
σ
k
G
Domain
Domain presets (starting values)
.
 (path cost weights): smoothness/blocked/density penalties in 
α, β, γ
 (step): speed/accuracy trade.
Δt
 fewer oscillations, slower convergence.
⇒
 (damping): stability; ↑c 
c
 diversity, risk of dropping signal.
⇒
 (repulsion strength/radius): de-dupe pressure; ↑σ/ρ 
σ, ρ
 smoother, can over-fit clusters.
⇒
 (elastic): cohesion along trusted edges; ↑k 
k
 tighter recall, risk of redundancy.
⇒
 (gravity): semantic pull; ↑G 
G
What the knobs do
10.2 Parameter Tuning (G, k, δ, c, α, β, γ)
 if RS saturates and UQ is tight before T steps.
Early exit
 by domain (docs, code, logs).
anchor cache
Pre-warm 
 for ANN tie-breaks to improve determinism.
fixed seeds
Use 
Engineering notes
return best(paths), witnesses(paths)
if κ_gate(score): return ABSTAIN(uq, reasons)
score  = rank(paths, RS, UQ, policy_clean)
paths = beam_paths(G', sources=anchors, B, Lmax)
G' = induce_graph(W, X, policy_ok=true)
  if stop_rule(ΔE, t): break
  X = project_policy(X, policy_regions)      # forbid crossings
  X = X + Δt * V + 0.5 * (Δt^2) * (F / m)    # velocity Verlet
  V = V + Δt * (F / m)
  F = forces(X, V, W, Nbr, params)           # grav + elastic + repulse - c*V
for t in 1..T:
Nbr  = build_sparse_neighbors(W, r)          # semantic + SEG edges
X,V  = init_positions_velocities(W)          # from embeddings; V=0
W    = select_working_set(cand, anchors, k1)
cand = policy_filter(cand, seg_rules, time_slice)
cand = ANN.search(q, k0)
)
Pseudocode (single query 
 Claim→Evidence→Decision lineage (VIF).
Emit witnesses.
 Compute RS, UQ; κ-gate.
Score & gate.
 Beam search (B=3–8) on refined graph; respect policy geometry (no forbidden crossings).
Path find.
(8–16).
 Physics pass (Velocity Verlet; §9.1) with sparse neighbors 
Local DVNS refinement.
 (canonical witnesses, recent snapshots).
anchors
 = 64–256 items + 
 Keep k
.
Form working set 
 Apply SEG constraints (time-slice, allow-lists).
Policy & time filter.
 candidates (e.g., 512).
 ANN over embeddings → top-k
Coarse retrieve.
High-level loop
10.1 Online Refinement on Top-k
 visualization & telemetry.
(10.4)
 failure modes & mitigations, 
(10.3)
 parameter tuning at runtime, 
(10.2)
 online refinement on top-k, 
(10.1)
 Turn DVNS from equations into a production recipe. Four pieces: 
Intent.
Chapter 10. Implementation Patterns
Part III — Dynamic Vector Navigation System (DVNS)
 to prove lift over static KNN and catch regressions.
evaluation harness
An 
 that slashes online work and improves determinism.
super-index
An offline 
.
abstention gates
, and 
oscillation detectors
, 
stop rules
Clear 
 recipe (Velocity Verlet + adaptive step) that runs fast on GPUs.
numerically stable
A 
What this chapter gives you
(favor diversity)
 
Log forensics:
(favor cohesion)
 
Code reasoning:
 
Ad-hoc QA:
Tuning cheatsheet (per domain).
(neighbors).
, increase 
 lower 
Over-repulsion (loss of signal):
 fall back to KNN slice with explicit low-confidence witness.
Novel queries (no anchors):
.
abstain
 broaden anchor set; add approved bridge nodes; or 
Policy walls choke paths:
, cap neighbor degree.
, shrink 
 raise 
Oscillation in dense clusters:
Failure modes & mitigations.
 >0.8 (abstain when truly under-supported).
Abstention precision:
 +10–30% vs KNN+rerank (mitigated to <10% with super-index).
Latency impact:
 >99.5% (vs. 97–98% with post-hoc filters).
Policy-clean path rate:
 +15–30%.
De-dup@10:
 +5–12%.
nDCG:
 +4–10% vs. KNN; 
p@5:
Typical outcomes (targets, not promises).
 instability tails, higher abstentions.
⇒
−damp 
 redundancy spikes (near-dup piles).
⇒
−rep 
 cohesion breaks (sections split), path smoothness drops.
⇒
−elas 
 worse recall (semantic pull lost).
⇒
−grav 
Ablations (turn off each force).
 median latency, 95p latency, token/compute budget adherence.
Cost:
 lineage completeness (% artifacts with full VIF tuple), replay success.
Audit:
 % policy-clean paths, forbidden-edge rate.
Compliance:
 (Δ against KNN), de-dup@k (fraction unique sources).
RS-lift
 p@k, nDCG, 
Retrieval:
Metrics:
.
DVNS+super-index
, 
DVNS
, 
KNN+rerank
, 
KNN-only
Systems: 
 with human adjudication; time-slice enforced.
witness sets
Gold: top-k 
Corpora: (i) multi-doc QA, (ii) codebase Q&A/refactor, (iii) log forensics.
Evaluation protocol.
9.4 Empirical Lift vs. Static KNN
 20–60% reduction in per-query steps; more stable paths; better cold-start for rare queries.
Expected win.
 Keep latest and previous shard live for snapshot replays.
A/B-cache policy:
 Update basins incrementally as new atoms arrive; re-run full partition nightly.
Delta maintenance:
Maintenance.
) because you start “near” a solution.
aggressively (often 
Clip DVNS steps 
 (fast start).
skeleton witnesses
 and 
basin members
with 
Seed 
.
centroids 
to nearest 
Route query 
Runtime use.
 Maintain bitemporal shards (e.g., monthly) and policy partitions; invalidate/write-through on updates.
Shard by time & policy.
to canonical witnesses (standards, ADRs, specs).
 path templates 
policy-clean
 For each centroid, cache top 
Skeleton paths.
 (few edges connecting clusters).
spanners
(priority sum), 
 
mass
(mean embedding), 
 
Centroids
 Cluster the super-index with community detection over the SEG-endorsed graph + semantic edges. Precompute:
Attractor basins.
Artifacts.
 layer.
super-index
 at the 
path skeletons
 and 
basins
Goal: cut per-query work by precomputing 
9.3 Super-Index Precomputation
 if any projection resolved ties non-deterministically (rare).
determinism flag
Emit 
grid and clamp floating epsilons.
Quantize 
Fix seeds for ANN and tie-breaks.
Determinism knobs.
.
. Witness buffers add 
and sparse neighbor lists: 
Store 
Space complexity.
small.
. Use SEG-first beam to keep 
): 
, max length 
Path enumeration (beam 
viable at ms-scale on GPU.
, 
, 
. With 
: total 
Steps 
per step.
per item): 
Force pass (sparse neighbors 
.
–
 
⇒
(union of candidates + anchors) 
Build 
.
expected with modern indexes + re-rank 
ANN search (coarse→fine): 
Time complexity (per query).
.
and shrink 
per item; if median flips > threshold, raise 
 Track sign changes in 
Oscillation detection.
 abstention triggers (policy barriers dominate or UQ spikes).
(S3)
reached, or
 max steps 
(S2)
for two consecutive steps, or
 
(S1)
 when
stop
almost everywhere (minus projection). We 
. Damping yields 
active only for 
with 
Energy functional.
9.2 Convergence & Complexity
for code/log forensics
for QA; 
Steps 
(raise to 0.25 if oscillation detected)
Damping 
, strength 
Repulsion radius 
, rest-length 
; Elastic 
Gravitational 
, 
Default numeric profile (safe starting point).
 for policy/time; projection as masked coordinates or clamped kernels.
mask matrices
Apply 
 per item (top-r semantic + SEG edges); compute forces via sparse gather/scatter.
neighbor lists
Precompute 
.
Maintain 
Vectorized batch form (GPU-friendly).
(raise damping when you detect reversals).
(shrink when energy increases).
Adaptive step & friction.
.
 if you detect tight latency budgets or extremely small 
downgrade to symplectic Euler
 by default; automatically 
velocity Verlet
 Use 
Recommendation.
Cons: Slightly higher per-step compute (needs force eval twice).
Pros: Second-order, better energy behavior, fewer steps to converge.
; then
from 
Compute 
B. Velocity Verlet.
Cons: More numerical damping than Verlet; slightly less accurate per step.
.
 decent stability for small 
⇒
Pros: 1 line, cheap, symplectic 
A. Semi-implicit (symplectic) Euler.
.
 
projection
with policy/time 
. Forces:
, mass 
, velocity 
: position 
 For each working item 
State.
9.1 Force Integration (Verlet vs. Euler)
 empirical lift vs. static KNN.
(9.4)
 super-index precomputation, 
(9.3)
 convergence & complexity, 
(9.2)
 force integration choices, 
(9.1)
 Nail down the numerics, show the run-time costs, and prove DVNS is practical at scale. We focus on four things: 
Intent.
Chapter 9. Algorithms & Analysis
Part III — Dynamic Vector Navigation System (DVNS)
.
opaque neighbor lists
 (witnessed paths) over 
Audit trails
.
post-hoc filtering
 (policy geometry) over 
Compliance by construction
 (near-dup clumps).
echoes
 (repulsion) over 
Diversity
 (unrelated top-k).
scatter
 (smooth paths) over 
Coherence
What DVNS Guarantees (relative to plain KNN)
 if violated.
abstain
 (no forbidden terms, no leaking PII) and 
policy lints
 Before emit, run 
Safety hooks.
 with late fusion.
per-modality sub-loops
 (aligned encoders) or run 
shared latent
 For image/code/log nodes, operate in 
Multimodal.
; recent, frequently validated atoms pull harder.
 Use TPV (priority, decay) to set masses 
Adaptive priors.
.
cost counters
under APOE step budgets; expose 
, beam width 
, 
 Limit 
Budget awareness.
 in similarity.
monotonic
or learned bilinear forms; keep 
 Gravitational pull can be 
Pluggable kernels.
Design Notes & Interfaces
 invariants.
SEG
 and 
VIF
 (SEG node ids, CAS CIDs). This fulfills 
citations
, and 
, path features 
, snapshot_id, UQ vector 
exact index versions
Return 
Witnessing.
14 return top-N (P, RS*, u, path_witnesses, index_versions, snapshot_id)
13 score each P with C(P); compute RS*, UQ u; filter P by κ, u
12 paths ← enumerate_simple_paths(G', src=q, beam=B, max_len=L)
11 G' ← localized graph over W (SEG edges + nearest safe neighbors)
10     t ← t+1
9      ΔE ← energy_drop()
8          x_i, v_i ← integrate(F_i) ; x_i ← project(x_i, A)   # admissible region
7          F_i ← sum_grav(i,W) + sum_elas(i,SEG) + sum_rep(i,W) − c v_i
6      for i in W:
5  while t < T and ΔE > ε:
4  init velocities v_i = 0; t = 0
 anchors, policy=Π, timeslice=as_of)
∪
3  W     ← prune(cand 
2  cand  ← ANN.search(q_vec, filters=F, Kc→Kf)      # filter-first (tenant, policy, time)
1  q_vec ← embed(q); anchors ← SEG.anchors(as_of, F)
.
 ranked 
Outputs.
.
, policy map 
, as_of, filter set 
 query text 
Inputs.
DVNS: Minimal Execution Sketch
 unless bridged by acceptable anchors (e.g., tool outputs with VIF).
smoothness penalty
 hops (supports/derives) and treat free semantic hops as secondary with a 
SEG-endorsed
When a path must justify a claim, prefer 
SEG-first search.
 in ANN rerank.
clipped kernels
 (drop disallowed facets) or 
masked coordinates
Implement as 
:
, if 
For an update 
Projection operator.
 during integration. The path builder prunes them before enumeration.
hard projections
large) and as 
 in scoring (i.e., 
infinite barriers
We treat such edges as 
 without a resolving decision).
contradicts
 (e.g., explicit 
SEG assertions
violate 
 (e.g., verifier may not mutate memory),
role
contradict declared 
 (node or edge not valid at as_of),
time slice
break a 
cross into a policy-forbidden region (PII, export),
is illegal if traversing it would:
A candidate edge 
Forbidden crossings.
8.4 Policy-Aware Geometry (forbidden crossings)
up when hierarchy/SEG cohesion matters (e.g., code+tests).
Elastic 
up when diversity low (near-dup density).
Repulsion 
up when oscillation detected (energy up-ticks).
Damping 
Stability knobs.
: reason for abstention, thresholds, top conflicting pulls.
boundary witness
Emit 
Fall back to: (a) classic KNN slice + raw citations, (b) ask-clarify, or (c) route to HITL (risk-aware).
:
abstain
exceeds bound, 
 any component of 
or
If 
Abstention rule (κ-gating).
.
 
uncertainty vector
and 
→ take argmin; compute 
Score with 
 through refined graph (beam on SEG-endorsed edges + local neighbors).
simple paths
Enumerate 
 reached.
max steps
(converged) or 
 
energy drop
Check 
.
Project to admissible 
(semi-implicit Euler or Verlet).
, 
Update 
.
Compute 
:
. For 
Initialize 
 (tenant, namespace, policy, time).
filter-first
: coarse→fine KNN with 
Build 
Integration loop (per query).
8.3 Stability & Abstention
 from query to witnesses.
coherent, auditable route
. This turns “top-k neighbors” into a 
win
 Short, smooth, policy-clean, and non-redundant paths 
Interpretation.
is path cost after DVNS refinement.
and 
 is the base 
RS
where 
Retrieval score (with Part II RS):
Total cost (minimize):
.
 
Density (over-crowding / redundancy):
(large penalty).
 
Blocks (policy/temporal/SEG violations):
.
 
Smoothness (topic curvature):
.
, with 
 
Length (semantic travel):
through the refined neighborhood:
 
explanatory paths
We score candidate 
: length, smoothness, blocks, density
8.2 Path Cost 
(policy-safe, time-valid).
 
admissible region
is projection onto the 
where 
:
hard barrier
(forbidden) or item invalid at the as_of slice, project updates with a 
If 
Policy geometry (hard constraints).
 control for convergence.
temperature
Eliminates oscillation; acts like 
Damping (stability / early stopping).
.
diverse context
Spreads near-duplicates, promoting 
:
If 
Repulsive (redundancy / cluster de-dup).
 neighborhoods.
SEG-endorsed
 (IXPATH proximity) and 
hierarchical cohesion
Keeps 
(e.g., same section, same molecule, approved SEG edges),
For intended structural links 
Elastic (structure / hierarchy / policy keeping).
Pulls toward semantically similar, high-priority neighbors.
Gravitational (attraction / semantic pull).
Forces (GODN → retrieval semantics).
to a compact set of witnesses.
 from the query 
path
We simulate a small number of integration steps to refine a 
(bitemporal).
 interval 
Validity
policy mask (1=allowed),
 
Charge
(priority; e.g., TPV from Chap. 5),
 
Mass
(embedding),
 
Position
has:
Each item 
 implied by policy (PII, license, export tags) and time slicing (as-of).
Barriers
 from SEG (e.g., authoritative sources, recent decisions, pinned artifacts),
Anchors
 from the vector store after filter-first coarse KNN and fine rerank,
Candidates
be the union of:
Let the working set 
State space.
8.1 GODN Recap → Retrieval Mapping (grav, elastic, repulse, damping)
 through memory.
stable, policy-safe path
 of the CMC substrates (vector store, SEG, CAS, snapshot log), turning a query into a 
on top
 that respects memory priority, policy constraints, and auditability. DVNS runs 
physics-guided search
 Replace brittle, purely lexical/nearest-neighbor retrieval with a 
Intent.
Chapter 8. Physics-Inspired Retrieval
Part III — Dynamic Vector Navigation System (DVNS)
.
witness metadata
All APIs accept as_of and return 
 + index scrubbing.
overlay snapshots
Redaction & erasure implemented via 
, signed, and cross-region replicated.
append-only
Snapshot log is 
CAS uses content-defined chunking, delta chains, and KMS-backed keys.
; exports produce legally defensible bundles.
bitemporal
SEG is 
 and calibrated swap.
filter-first
Dual-index ANN with 
7.7 “Done Right” checklist
 deterministic replay from any snapshot_id under fixed tools/budgets.
APOE:
 content-addressed CAS + graph ensure doc/code/tag/trace parity.
SDF-CVF:
 and signatures.
witness URIs
 every store returns verifiable 
VIF:
, not deletes.
edges
 bitemporal graph; contradictions and redactions are 
SEG:
 snapshot-scoped writes/reads; single writer realized via snapshot log.
CMC:
7.6 Invariants crosswalk (this chapter)
: tag propagation into ANN and SEG; deny or redact at source.
PII & export control
: all commits signed; verifier can check toolchain SBOMs.
Signing & attestation
 search/graph traversal.
before
 evaluated 
Row-level policy filters
 for ANN, SEG, CAS; least-privilege scopes (read-only vs write).
Capability tokens
: every index row/edge/object scoped by tenant_id and snapshot_id.
Strong tenancy keys
7.5 Security & tenancy (applies to all stores)
 WORM buckets for the log itself.
Audit immutability:
 prunes expired data by policy while preserving graph integrity (keep tombstones & redaction overlays).
GC
 (RPO ≤ 1 min; RTO ≤ 15 min).
Cross-region replication
7.4.4 DR & GC
POST /snapshots/replay?from=...&to=... (reproduce a write path with frozen tools)
)
prod-2025-10-17
POST /snapshots/label (e.g., 
GET /snapshots?cursor=... (paged)
7.4.3 APIs
 references point to remediation plans (auto-fix, HITL).
Quarantine
 as as_of; no mutation retroactively.
earlier snapshot
 = select 
Rollback
 histories allowed (feature work, quarantines).
Linear or branched
7.4.2 Semantics
 vector index version ids, SEG batch id, object batch manifest.
State refs:
signer (key id, sig) • toolset_hash • created_at • notes (ADR link)
snapshot_id (uuid) • parent_id (uuid or null) • merkle_root • diff_summary
7.4.1 Record format
 for writes, reads, audits, and incident response.
single source of replay truth
 Append-only ledger of memory states; the 
Role.
7.4 Snapshot Log & Rollback
 (do not mutate old); scrub ANN cells and caches via tombstone propagation.
redaction overlay snapshot
 write a 
Right-to-erasure:
Retention policies per class (e.g., 6 mo for high-risk logs unless extended).
7.3.4 Lifecycle & compliance
 per-tenant egress quotas; LRU/CDN in front.
Bandwidth guards:
 with tenant keys; server-side KMS rotation.
At-rest encryption
 scoped to tenant, snapshot, and IXPATH range.
pre-signed URLs
Read via 
7.3.3 Access model
 to reconstruct IXPATH spans; stable anchors survive minor edits.
Line/AST maps
mime, charset, lang, license, pii_tags, source_uri, ingest_tool.
7.3.2 Metadata & lines
 binary diffs for large versions; capped chain length (periodic re-base).
Delta chains:
 content-defined (rolling hash) to maximize dedupe across revisions.
Chunking:
cid = H(normalize(payload)) (blake3/sha256).
7.3.1 CAS design
.
dedupe, delta, and encryption
 Immutable storage for raw payloads and heavy artifacts (docs, code blobs, images), with 
Role.
7.3 Object Store (content-addressed)
 nodes and edges; redaction marks are edges with policy:redacted.
both
 time-slice applies to 
Policy:
p95 path (≤ 5 hops): ≤ 80 ms; p95 neighborhood (≤ 200 edges): ≤ 120 ms.
7.2.5 SLOs & guardrails
GET /seg/pack/export?scope=case-123 (regulatory bundle)
POST /seg/annotate (adds annotates edges with reviewer witness)
GET /seg/path?from=claim&to=decision&as_of=...&max_hops=...
7.2.4 APIs (selected)
 Merkle over node/edge ids → quick integrity checks.
Subgraph signatures:
.
policy-aware pruning
Path queries: constrained BFS/Dijkstra with 
Composite: (label, snapshot_id, ts_valid_from); adjacency on (out_v, edge_type).
7.2.3 Indexes & algorithms
, not deletes; prior facts remain queryable with their time bounds.
Contradictions are edges
(model_id, weights_hash, prompt_template_id, tool_fingerprint, snapshot_id, UQ_vector).
VIF tuples
 (Chapter 6): edges/nodes carry 
publish
Emitted at 
7.2.2 Writes & lineage
Queries accept as_of_valid, as_of_system for compliance-grade replay.
 = when we learned/recorded it.
system time
 = when the fact holds; 
Valid time
Bitemporality.
Props: weight, policy_tags, ts_valid_[from,to), witness_uri.
 supports, derives, contradicts, annotates, usesTool, approvedBy.
Edges:
Common props: id, snapshot_id, jsonld, ts_valid_[from,to), uqlabels (risk, domain).
 Claim, Source, Snippet, ToolCall, Decision, Agent, Snapshot.
Nodes:
7.2.1 Data model (bitemporal property graph)
 (SEG): time-sliced, typed nodes/edges encoding claims, sources, tool calls, derivations, contradictions, and decisions.
substrate of truth
 The 
Role.
7.2 Evidence Graph Store (temporal)
: periodic rebuild per snapshot or tiered compaction.
Fragmentation
 (high fan-in/out): shard by namespace and cap degree in link proposal.
Hot hubs
 (recall drop): run dual-index warmup + calibrated swap.
Index drift
7.1.6 Failure modes → remedies
 ANN.
before
 no raw vector egress without scoped capability; PII/Export filters are applied 
Safety:
Recall@K target ≥ 0.95 vs. exact on sampled audits.
p95: coarse ≤ 60 ms, fine ≤ 120 ms (K_coarse=200, K_fine=40).
7.1.5 SLOs & guardrails
: which filters applied; index version; calibration id.
witness bits
Returns 
score = α·cosine + β·tpv_priority + γ·recency – δ·policy_penalty
search(q_vec, filters, K_coarse, K_fine) → candidates with:
7.1.4 Queries
 serves reads; hot-swap after calibration (A/B recall ≥ 0.95).
old_index
 while 
new_index
: dual-write to 
Model change
 (Chapter 6): batch insert (snapshot_id, nodes); prior snapshots remain immutable.
commit
Occur only at 
7.1.3 Writes
 periodic re-centroiding / graph rewire to limit drift.
Background compaction:
: tenant/namespace/policy prefilters prune search space before ANN.
Filter-first
 HNSW(ef) over emb_full for rerank within shortlist.
ANN-fine:
 IVF-PQ / ScaNN / HNSW over emb_proj (high recall, tiny memory).
ANN-coarse:
 per snapshot:
Dual-index
7.1.2 Indexing strategy
policy_tags (set: pii, license:GPL, export:EAR, …)
norm (float) • tpv_priority (float in [0,1]) • ts_valid_from/ts_valid_to
 passes (e.g., 768/1024)
fine
emb_full (float[D]) — full vector for 
 passes
coarse
emb_proj (float[64]) — projection head for 
modality (enum: text, code, log, image_meta, …) • namespace (str)
tenant_id (str) • snapshot_id (uuid) • node_id (uuid) • ixpath (str; L1–L5)
7.1.1 Schema (columnar / key–value hybrid)
.
link proposals
 selection and write-time 
coarse→fine
 Fast, filterable nearest-neighbor search over embeddings for L1–L5 items (projection + full vectors), feeding read-time 
Role.
7.1 Vector Store & KNN
.
snapshot-scoped, policy-aware, and replayable
. All semantics in Chapters 4–6 depend on these stores being 
snapshot log
, and an append-only 
object store
, a content-addressed 
evidence graph
, a bitemporal 
vector store
 that realize CMC: a high-performance 
four physical stores
 Specify the 
Intent.
Chapter 7. Storage Substrate
Part II — Context Memory Core (CMC) & HHNI
.
witness
: deterministic snapshots, safe evolution, fast reads, and every returned byte comes with a 
boringly reliable
 The write/read pipelines make memory 
Outcome.
, never silent drop.
quarantine with replay
Every error path is 
, not convenience.
policy first
Prefetch obeys 
 and monitored (ECE dashboards).
calibrated
RS is 
 a snapshot; no hidden mutable joins.
as-of
All reads are 
 (APOE/HITL).
soft-gate debates
 and records 
hard gates
Write path enforces 
6.7 “Done Right” checklist
 read outputs are κ-aware, budget-bounded, and ready for deterministic chains.
APOE:
 gating enforces parity; quarantines trigger auto-fix/ADR flows.
SDF-CVF:
 witnesses attached at commit; reads return boundary witnesses and replay URIs.
VIF:
 every publish emits time-sliced edges; contradictions preserved.
SEG:
 single writer, snapshot-first; all writes are idempotent and reversible via QUARANTINE/REPLAY.
CMC:
6.6 Invariants Crosswalk (this chapter)
recalibrate per domain; task-aware κ
κ too conservative
excessive denials
Over-abstention
bandit exploration limits; policy filters upfront
poor Markov model
bandwidth spikes
Prefetch waste
dual-index warmup; A/B calibrated swap
embedding/model change
recall drops
ANN drift
re-shard links; enforce degree caps
hub fan-in/out too high
many edits blocked
Hot hub DD spikes
chunked merkle, parallel trees
long merkle over big diffs
commits hang
Snapshot stall
Remedy
Root cause
Symptom
Failure
6.5 Failure Modes & Remedies
 governed by snapshot delta, not wall-clock; auto-GC on expired retention windows (policy-aware).
Storage growth:
 L1 ≥ 0.70 steady state; L2 ≥ 0.85.
Cache hit ratio:
 target ≤ $X (tunable); ANN recall ≥ 0.95 at 10× speedup.
Index build / GiB text:
6.4.3 Cost & footprint
 κ-abstain true-positive ≥ 90% on high-risk sets.
Abstention quality:
 0 P0 incidents; redaction success ≥ 99.9%.
Policy leakage:
 ≤ 0.03 per domain; alert at 0.05.
Calibration (ECE):
 100% match on replays (same snapshot/tools).
Reindex determinism:
6.4.2 Correctness & quality
witness hydration
40 ms
20 ms
6 ms
Assemble+VIF attach
vectorized isotonic
10 ms
6 ms
2 ms
RS calibration pass
includes policy mask
220 ms
120 ms
45 ms
Fine expand (K=40, 2 branches)
projection head ANN
120 ms
60 ms
20 ms
Coarse scan (K=200)
in-memory graph shard
60 ms
35 ms
8 ms
Impact preview (R=3, deg≤32)
includes merkle+sign
1.8 s
900 ms
350 ms
Write commit (≤ 2MB batch)
Notes
p99
p95
p50
Operation
6.4.1 Latency & throughput (per single region)
. If writes or reads blow budgets, APOE chains drift and VIF becomes impractical.
foundation
 Memory is the 
Why SLOs here:
6.4 Performance Targets & SLOs
 Weighted by (RS_lift · recency · hit_rate) / size.
Eviction policy:
 WFQ across tenants; emergency drain for hot snapshots.
Queue fairness:
 MB/sec and tokens/sec caps; backoff on contention.
Per-user soft budget:
6.3.3 Budget-aware preloading
 never prefetch atoms violating user scoping, PII policy, or license boundaries.
Guardrails:
-greedy on prefetch candidates to explore.
 
Bandit modulation:
maximizing:
successors of current state 
Prefetch top 
transition probabilities learned from anonymous session traces with policy filters.
be states = IXPATH prefixes (e.g., sec[*], para[*]), and 
Let 
6.3.2 Markov prefetch
 (changed IXRECs/edges).
diff
; snapshot advance invalidates by 
snapshot-scoped
 caches are 
Coherency:
: cold payload pages and SEG shards.
L3 page cache
: projection head vectors and ANN cells.
L2 vector cache
: decrypted atoms/IXRECs, small objects (TTL minutes; TTI).
L1 atom cache
 (per-request): RS scoring artifacts, policy masks (TTL seconds).
L0 inline
6.3.1 Cache hierarchy
. We exploit session patterns to predict next hops and stage atoms into fast caches without violating policy.
bursty and structured
 Reads are 
Thesis.
6.3 Caching & Preloading (Markov traversals)
; no raw vector export by default.
scoped tokens
 embeddings served under 
Leakproofing:
 redact over deny when possible; mark redaction in witness.
Redaction priority:
 configurable; APOE uses abstain→route patterns.
κ-bands per domain:
6.2.4 Safety & abstention
  return assemble(C, attach_witness=true)
    return ABSTAIN(with reasons, alternatives)
  if empty(C) or min_RS(C) < κ_domain:
  C ← policy_mask(C)                                      // redaction/PII/license
  C ← score_calibrated(C)                                 // RS calibrated
    C += fine_expand(branch, K_fine, max_tokens=budget.ctx)
  for branch in B:
  C ← []
  B ← coarse_scan(S, query, filters, K_coarse)           // L1–L3
  S ← select_snapshot(as_of)
function resolve(query, as_of, budget):
6.2.3 Read algorithm (sketch)
 (why this atom), not whole neighborhoods.
explanatory edges
Include minimal 
 of spans (lost-in-the-middle mitigation), plus atomic snippets critical to the claim.
beginnings and ends
Compose returned context to favor 
Assembly:
 (VIF tuples) and preview DD paths.
boundary witnesses
Attach 
 with calibrated normalizer.
RS = QS·IDS·(1−DD)
Recompute 
Expand only shortlisted branches to word/sub-word or AST token level.
Fine stage (L4–L5):
 (redaction masks, license scopes, RBAC).
policy prefilter
Apply 
 indexes to shortlist K branches (fast, low-dim).
projection head
Search 
Coarse stage (L1–L3):
6.2.2 Dumbbell compression (two-stage read)
 ACL step resolving inputs under budgets/policies.
Programmatic read:
 claim/evidence traversal in SEG with constraints.
Lineage search:
 query vector + filters (modality, domain, time).
Semantic search:
 IXPATH or node_id fetch at as_of time.
Direct lookup:
6.2.1 Query classes
 context for APOE.
witnessable
 to maximize relevance and minimize risk/cost, while returning 
just-enough atoms
 Serve 
Goal.
Hierarchical dumbbell, calibrated scoring, policy-aware assembly
6.2 Read Path — 
GET /memory/write/quarantine/{batch_id} → remediation report (policy hits, DD paths, suggested redactions)
POST /memory/write/commit?batch_id=… → {snapshot_id, witness_uri}
POST /memory/write/ingest → {batch_id}
6.1.4 Minimal write API
 with a replay spec (exact inputs, seeds, tools).
QUARANTINE
 any failure moves batch to 
Rollback:
, no read index mutation is visible.
SNAPSHOTTED
 until 
Write isolation:
 replay-safe.
⇒
 (cid, scope, parent_snapshot, toolset_hash) 
Idempotency key:
6.1.3 Transactional semantics
 provenance packets; update read indexes.
VIF
 nodes/edges and 
SEG
Emit 
.
Snapshot Log
Sign snapshot, allocate snapshot_id, write append-only to 
Freeze tool versions, model ids, weight hashes, prompt templates.
 over payloads and dependencies; compute H(root).
Merkle forest
Build 
Snapshot & Publish
Soft fail → quarantine with remediation hints (auto-fix candidates).
 vote; outcome logged as a witness.
APOE verifier
 or 
HITL
Soft pass → 
 gates: DD in caution band, low calibration (ECE), ambiguous license.
Soft
 gates: structural cycles, forbidden content, link into restricted region without exemption, DD above hard cap for that domain.
Hard
Gate
: PII, license incompatibilities, safety classes.
Policy risks
 for embeddings/links (variance across seeds/temps; optional ensembles).
UQ vector
 from the proposed edit center (Chapter 5 §5.2).
Dependency Delta (DD)
Compute risk
 (kept for audit).
filtered-out justifications
Record candidate set with scores and 
Semantic: KNN candidates (top-M), rerank by cross-encoder/DomainRank, policy filter (namespace/PII/license), cap fan-in/out.
 be acyclic and ordered.
must
Structural: contains(parent, child) per segmentation → 
Propose links
Compute embeddings (full + projection head); attach initial TPV tags.
 (author, source, timestamps, file path/AST path).
payload metadata
Extract 
 atoms/molecules.
IXPATH-stable
Segment to L1…L5 (Chapter 5) and emit 
Atomize
; else continue.
PUBLISHED
 snapshot lineage, short-circuit to 
current
Dedupe rule: if (cid, scope) already present in the 
Actions: normalize encodings, strip control bytes, detect modality/language, compute content hash cid.
Inputs: user prompts, code, files, tool outputs, logs, sensors.
Ingest
6.1.2 Stages (authoritative definitions)
          ↘ (any fail) → QUARANTINE
   → (merklize+sign) → SNAPSHOTTED → PUBLISHED (SEG/VIF emitted)
   → (risk/PII/licensing) → GATED
NEW → (dedupe) → ATOMIZED → (index) → PROPOSED_LINKS
6.1.1 State machine
.
snapshot id
 per memory space. All visible state corresponds to a signed 
one transactional writer
 There is exactly 
Contract.
Ingest → Atomize → Propose → DD → Gate → Snapshot
6.1 Write Path — 
. This chapter operationalizes C-1/C-2/C-3 (single writer, snapshot-first, two-stage read) and exposes the performance envelope and SLOs.
big, provable lineage
 with 
small, lossless contexts
 of AIMOS memory: how raw context becomes atoms, how links are proposed and risk-gated, how immutable snapshots are minted, and how reads assemble 
authoritative data paths
 Specify the 
Intent.
Chapter 6. Write/Read Pipelines
Part II — Context Memory Core (CMC) & HHNI
 indexing from system to sub-word—with change risk quantified up front and retrieval calibrated to reality.
adaptive
 HHNI gives us deterministic, cryptographically witnessed, 
Outcome.
 hash-match rate 100% on snapshot replays.
Reindex determinism:
 ≥ 99.9% for disallowed content (zero-tolerance classes).
Write reject rate (policy):
 p95 ≤ 50 ms for radius 3, degree ≤ 32.
Impact preview latency:
 ≤ 0.03 per domain bucket.
Calibration (ECE):
 ≥ 6.0; tail < 10% below 4.0.
IDS median (core corpora):
5.9 “Done Right” Targets
.
 orchestrators consume HHNI via calibrated RS and policy masks; abstain under 
APOE:
 changes across code/docs/tags/traces are reflected atomically through HHNI; impact previews gate merges.
SDF-CVF:
 every IXREC/link carries model+weights+prompt+tools+snapshot; all hashes verifiable.
VIF:
 (no destructive deletes).
contradictions are preserved
 edges are typed, temporal, and 
SEG:
 via acyclic contains + payload immutability.
reversibility
 atomize→index→snapshot→graph is enforced at every level; 
CMC:
5.8 Invariants Crosswalk (this chapter)
 token and policy approval.
single-writer
 Read-mostly; write paths require 
AuthZ.
GET /index/metrics: IDS distribution, tag budgets, calibration curves.
POST /index/preview-impact: returns ranked impact set with paths and DD.
POST /index/relink: propose semantic links; returns filtered set + witness.
GET /index/resolve?ixpath=…&as_of=…: fetch IXREC, parents, children.
POST /index/build: build HHNI for a given snapshot scope (system/section…).
5.7 APIs (minimal, authoritative)
Vector access scopes; on-write redaction; audit jobs
PII in embeddings
Privacy bleed
Rolling recalibration + ECE alarms per domain
RS stops tracking relevance
Calibration rot
Cap fan-in/out; shard edges; require verifier vote
DD spikes in a hub
Hotspot collapse
pruning + policy floors
Tag budget + 
Noisy/duplicated tags
Tag sprawl
Freeze segmenter+tokenizer at snapshot; record tool hashes
IXPATHs unstable across runs
Index drift
Minimum span, overlap window, merge heuristic
Too many tiny atoms; recall drops
Over-segmentation
Guardrail
Symptom
Failure
5.6 Failure Modes & Countermeasures
 (VIF) for APOE.
boundary witnesses
 answer context with 
Assemble
 candidates with calibrated RS; apply policy masks.
Score
 expand to L4–L5 only for candidate branches.
Dumbbell
 at higher levels (L1–L3) using projection head.
Coarse scan
5.5.2 Serve (read-time)
 block if cycle, PII leak, license breach, or missing witness.
Gate:
 IXRECs, edges, payload refs; emit VIF.
Persist
 dependencies; compute H(i); sign snapshot.
Merkle
 structural edges (contains) then semantic edges (KNN→rerank→policy filter).
Link
 with initial TPVs (policy+NER+domain classifiers).
Tag
 each unit; compute embeddings (full + projection head).
Atomize
 payload into L1…L5; produce IXPATHs (idempotent).
Segment
5.5.1 Build (write-time)
5.5 Build & Serve Pipelines
publish κ bands per domain: κ_low, κ_high
  update(calibrator) to minimize ECE on validation
  RS_cal ← calibrate(RS_norm) // isotonic fit
  RS_norm ← normalize(RS_raw, domain)
  RS_raw ← QS * IDS * (1 - DD)
{0,1})
∈
  D ← sample(gold_pairs) // (query, node, y
for epoch in 1..E:
Training loop (pseudo):
.
 ≤ policy target; APOE abstains or escalates below 
high-risk domains
s.t. false-positive rate on 
 choose 
Abstention bands:
 (expected calibration error).
ECE
 isotonic regression or Platt scaling on held-out gold sets; monitor 
Methods:
.
 
Calibration target:
 z-score or min-max per domain bucket (legal, code, design).
Per-domain normalization:
5.4.4 Normalization & calibration
 “how risky is it to rely on this node now?”
Interpretation:
From §5.2, bounded to [0,1]. 
5.4.3 DD (dependency delta)
above the median.
and 
 core domains achieve 
Target:
be connection density in its subtree:
be levels present beneath a node, and 
Let 
5.4.2 IDS (indexing depth score)
 weighted harmonic mean emphasizing weakest link.
Aggregation:
 complete VIF tuple (model id, weights hash, prompt id, tools, snapshot).
Provenance:
 coherence, redundancy, contradiction flags.
Model checks:
 schema conformance, language detect, PII scan, license safety.
Static checks:
5.4.1 QS (quality score)
.
 Make scores comparable across domains and over time; align RS with actual relevance; expose abstention thresholds 
Goal.
5.4 Retrieval Score (RS) — normalization & calibration
 tags and trims edges (keeps lineage).
removes low-
 prolonged non-use with high 
Demotion:
 (relates_to) for faster reads.
shortcut edges
threshold adds 
; crossing 
 repeated high-quality retrievals (grounded, accepted) elevate 
Promotion:
5.3.3 Promotion & demotion events
 tags with policy/critical never pruned; demote others below floor.
Policy floor:
.
 
Pruning score per tag:
 ≤ K tags per node (default K=8).
Budget:
5.3.2 Tag budget and pruning
, reducing RS unless refreshed.
increases 
 large 
Forgetting:
 boost policy/* tags).
⇒
can be raised by APOE (“compliance sprint” 
 
Task spikes:
:
After an interaction with outcome signals 
5.3.1 Online updates
(decay): time-based staleness.
 weight from observed usefulness (clicks, retrieval hit, grounding success).
endogenous
(relevance): 
 weight from current plan/policy.
exogenous
(priority): 
:
on node 
: high-value tags rise; stale/rare tags fade; task-critical tags spike under mission profiles. TPV per tag 
alive
 Keep indices 
Aim.
5.3 Priority & Decay (TPV dynamics)
 raises contradiction with higher priority claim → require verifier vote (APOE) or HITL.
Semantic:
 crossing into restricted region (PII/license) → route to redaction/HITL.
Policy:
 would introduce cycle in contains → hard fail.
Structural:
5.2.4 Conflict classes
 before commit.
impact preview recorded
 require 
C-1/C-2
 
Write gate:
 (diff previews).
what would change
 show top-K impacts with edge paths and 
UI contract:
  return sort_desc(impacts)
      visited.add(v); push(Q, (v, dist+1))
      if score ≥ τ: impacts.append((v, score))
      score ← w * γ^(dist+1) * Δ(v)
      if dist + 1 > R or v in visited: continue
    for each edge (u → v) with weight w:
    (u, dist) ← pop(Q)
  while Q not empty:
  Q ← [(r, 0)]; visited ← {r}; impacts ← []
function impact_preview(root r, radius R, threshold τ):
5.2.3 Impact preview (bounded BFS)
 high blast radius.
⇒
 Probability-like accumulation of risk; 
Interpretation.
controls attenuation with graph distance.
are limited by radius (hop count or cumulative weight).
Paths 
:
(e.g., edit distance, AST diff, or embedding drift). For an action centered at node 
be normalized change magnitude for 
Let 
5.2.2 Dependency Delta (DD)
 H(i) is logged in SEG; replays verify equality.
Witnessability:
bubbles via Merkle root without rescanning the world.
 a change in a dependent 
Localizing change:
(parents, references, semantic links). Compute:
 
dependency set
, define its 
For node 
5.2.1 Merklized dependencies
 impact preview.
live
 and shows a 
Dependency Delta (DD)
: every node carries a cryptographic view of what it depends on; any mutation computes a bounded 
safe by construction
 Make change and retrieval 
Goal.
5.2 Dependency Hashing & Impact Previews
 via alignment maps.
prefixes
 (≤ 6). Cross-modal nodes may share IXPATH 
bounded depth
 Containment graph is acyclic and 
Guarantee.
 between adjacent units for recall.
semantic overlap
 introduce 5–10% 
Overlap:
 utterance/clip aligned to VAD/shot boundary (L3), phoneme/object (L4), subphoneme/patch (L5).
Audio/vision:
 AST-first: function/method (L3), statement (between L3 & L4 as needed), identifier/token (L4), subtoken (L5).
Code:
 (keeps lemma & morphemes).
morphological split
 sentence boundary detection (punct+ML), word tokenization with 
Text:
5.1.4 Canonical segmentation
}
  "provenance": { "snapshot_id": "snap:…", "tool": "segmenter@vX", "model_hash": "sha256:…" }
  ],
    { "type": "relates_to", "dst": "sha256:…", "weight": 0.81, "valid_from": "…", "valid_to": null }
  "links": [
  "tags": [ { "name": "ner/ORG", "tpv": { "priority": 0.68, "relevance": 0.74, "decay": 0.02 } } ],
  "embedding": { "model": "…", "dim": 768, "vec": "…" },
  "span": { "char": [1340, 1349], "tok": [211, 211] },
  "order": 7,
  "parent": "…/sent[2]",
  "level": "word",
  "node_id": "sha256:…",
  "ixpath": "system://a/b@snap:2025-10-17/.../sec[3]/para[5]/sent[2]/word[7]",
{
5.1.3 Index record (IXREC)
.
view
 A node’s node_id is content-addressed; IXPATH is a 
Relocation safety:
 Re-indexing the same snapshot yields identical IXPATHs.
Idempotence:
 IXPATH is computed from canonical segmentation and snapshot.
Determinism:
          sec[{i}]/para[{j}]/sent[{k}]/word[{m}]/sub[{bpe}]
ixpath := system://{space}/{root}@{snap}/
:
hierarchical path
Each node has a content address (node_id) and a 
5.1.2 Stable addressing (IXPATH)
.
temporal
; semantic edges (relates_to, depends_on, contradicts) are 
acyclic
 and 
ordered
Containment edges contains(Ln, Ln+1) are 
subphoneme/patch
subtoken
morpheme/BPE
L5 Sub-word
phoneme/object box
identifier/token
token/word
L4 Word
utterance/clip
function/method
sentence
L3 Sentence
shot/track
file
paragraph
L2 Paragraph
scene/album
package/module
chapter/spec section
L1 Section
dataset
monorepo
corpus/app
L0 System
Audio/vision analog
Code analog
Text analog
Level
5.1.1 Level taxonomy (text & code analogs)
 an index entry. HHNI guarantees: stable addressing, acyclic containment, time-sliced cross-links, and reversible materialization at any level.
and
 Every level is both an addressable node 
Principle.
5.1 Indices from System → … → Sub-word
.
 that spans system→section→paragraph→sentence→word→sub-word (and code/file analogs), with cryptographic dependency hashing, real-time impact previews, adaptive tag priority/decay, and a calibrated Retrieval Score 
neural-grade index-of-indexes
 Turn the Fractal Memory Hierarchy into a 
Intent.
Chapter 5. Hyper-Hierarchical Neural Indexing (HHNI)
Part II — Context Memory Core (CMC) & HHNI
 Chapter 4 nails the substrate: what we store, how we store it, why it’s reversible, and how it stays legible across time and modality.
Outcome.
 ≥ 20% for large corpora (content-addressing at ingest).
Dedup ratio:
 ≤ 1e-4 (with redaction gates).
PII false-negative rate:
 100% for readbacks with identical IDs.
Snapshot replay fidelity:
 ≥ 0.85 on gold sets.
Memory precision@10 @ ≤50 ms:
 ≥ 6.0 for core domains (system→…→sub-word present; cross-links > 3 per atom).
Indexing depth (IDS):
4.8 What “good” looks like (targets)
 orchestrators declare budgets and produce witnessed traces that reference node_ids, never raw strings.
APOE:
 in molecules and edges; parity gates live in APOE execution.
atomically recorded
 changes across code/docs/tags/traces are 
SDF-CVF:
 every node/edge carries {model, weights_hash, prompt_tpl, tools, snapshot}.
VIF:
 edges are typed, temporal, contradiction-friendly.
SEG:
 atomize→index→snapshot→graph; reversible & monotone.
CMC:
4.7 Invariants crosswalk (this chapter)
 atom; originals remain sealed with access controls.
new
 policy engine gates CreateMemory and Link; redaction produces a 
PII/leakage:
 run dual-write (old+new) with snapshot binding; DVNS consults the overlay index while migration completes.
Embedding migration:
decay.
 cap tags per node; demote low-use tags via 
Over-tagging:
 at κ.
abstain
 QS drops over time; decay ensures RS reflects staleness; APOE may 
Semantic drift:
 reject; emit witness:violates(acyclic_contains).
Cycle injection (contains):
4.6 Failure modes & guardrails
 read (coarse→fine) for long contexts.
dumbbell
Supports 
→ ordered view, embeddings/tags, RS per node, lineage pointers
GET /memory/{node_id}?as_of=…&depth=…&view=atoms|molecule
4.5.3 Read (hierarchical)
 delete.
not
Policy mask applied before write. Contradictions generate type:"contradicts" edges; do 
→ 201 Created { edge_id, snapshot_id, witness_ref }
Body: { src, dst, type, weight?, policy? }
POST /memory/edges
4.5.2 Link (edge insert)
Validations: canonicalization, duplicate detection (content-address), policy pre-checks (PII/license). Reject if snapshot signing fails.
→ 201 Created { node_id, snapshot_id, rev, witness_ref }
}
  create_if_absent: true
  payload, modality, role?, parent?, source?, policy?,
Body: {
POST /memory/atoms-or-molecules
4.5.1 CreateMemory (single writer; C-1)
4.5 Interfaces (authoritative, minimal)
Snapshot: snap:2025-10-17T… signed; SEG stores witness tuples.
RS: computed per node; high for the molecule due to depth and low DD.
Edges: depends_on → lib/jose atom; relates_to → prior “auth patterns” molecule.
Embeddings: code and text embeddings + pooled molecule embedding.
TPV: topic/auth → [0.85, 0.77, 0.02].
Tags: topic/auth, risk/secret-handling, lib/jose.
Molecule: function molecule contains the above atoms.
Atoms: code atom (function body), text atom (docstring), event atom (paste).
Write path outcome.
 A user pastes a TypeScript function with JWT logic.
Input.
4.4.4 Example (end-to-end)
 hash vectors at rest if needed; enforce access scopes on sensitive embeddings (image faces, voiceprints).
Safety:
 (low-dim projection) for fast DVNS dynamics; use full vectors for ranking.
operational head
 keep an 
Projection:
; never silently overwrite.
join view
 with a 
parallel vectors
 store {model_id, version, dim, space}; switching models creates 
Model discipline:
4.4.3 Embedding policy
Calibration ensures RS ranks correlate with relevance probability.
 (restate, normalized):
Retrieval Score
 predicted impact of modifying/using the node, measured against connected dependencies (conflict potential).
DD (dependency delta):
 for that node’s subtree.
connection density
 and 
HHNI depth coverage
 logarithmic function of 
IDS (indexing depth score):
 per node; combines validation checks (language detect, PII scan, schema conformance), model-rated coherence, and provenance completeness.
QS (quality score):
4.4.2 Quality, depth, and dependency
come from the current plan/feedback.
where 
Update rule (online):
.
with horizon 
: time decay 
: learned from usage (clickthrough, dwell, grounding hits).
: task/user-specific weight (e.g., “compliance/PII” = high).
:
on node 
For tag 
4.4.1 Tag Priority Vector (TPV)
 and policy routing.
RS
: tags carry priority; embeddings carry semantics; both decay with time; all become inputs to 
auditable
 and 
adaptive
 Make retrieval 
Purpose.
4.4 Embeddings, Tags, and TPV
 longer molecules carry summaries; atoms remain raw for reversibility.
Compression:
 embeddings stored in vector store; metadata & edges in a graph or document DB; payload in object store.
Indexing:
 ≤ 4 KB inline, else object store.
Inline threshold:
4.3.3 Cost & storage
 turn each logical span (e.g., 2–5s audio) into an atom; group into a session molecule.
Streams:
 for captions, OCR, spectrogram notes.
derived atoms
 store as object; create 
Long media:
 (5–10%) to maintain recall.
semantic overlap
 splits; enforce 
sentence-aligned
 (hard <= 2k); prefer 
~512 tokens
 target 
Atoms (text/code):
4.3.2 Chunking strategy
 key–value canonicalization, schema capture.
Events/logs:
 perceptual hashes, CLIP-style embeddings, temporal cues.
Images/audio:
 tokenization, AST n-grams, symbol tables (for code).
Text/code:
Adapters handle:
}
  }
    "mime_hints": ["text/markdown"]
    "duration_ms": null,
    "token_span": [0, 256],
  "meta": {
  },
    "object_ref": "obj://bucket/key" // large objects
    "inline_text": "…",         // small text/content
    "bytes": "…base64…",        // optional if inline text present
    "content_type": "text/plain; charset=utf-8",
  "payload": {
{
Every node wraps payload in a uniform envelope:
4.3.1 The envelope pattern
4.3 Modality independence & payload abstraction
 new snapshots add nodes/edges or close intervals; earlier queries at as_of remain stable (SEG time slicing).
Monotonicity:
 an ordered traversal reconstructs all child payloads (no information loss beyond compression already witnessed in analysis.summary, which is preserved as a separate atom).
⇒
 Given a snapshot, contains is acyclic 
Reversibility:
4.2.3 Safety theorems (sketches)
 deprecations create valid_to on edges; nothing is silently removed.
Tombstones:
; immutability preserves replayability.
new node
over existing children produces a 
 new molecule 
Merge:
with identical canonical payload share node_id—dedup at write.
 two atoms 
Dedup:
 compute molecule embedding via weighted sum + nonlinearity (e.g., gated pooling on child TPVs).
Fold/Unfold:
4.2.2 Operations
 (usage, recency).
contextual gains
 of children plus 
functions
, folding children summaries upward. Emergence arises because embeddings/tags of molecules are 
materializes the ordered tree at time 
 
molecule view
A 
.
time-sliced
is arbitrary but 
.
, bounded depth 
acyclic
is 
molecules). Define:
∪
(atoms
Let 
4.2.1 Formal structure
4.2 Atomicity, Recursion, Emergence
 model “conflict” with contradicts edges; never delete evidence.
SEG/S-2 Contradictions:
 no edge or node visible without snapshot_id.
CMC/C-2 Snapshot-first:
Constraints → Invariants.
}
  "snapshot_id": "snap:…"
  "provenance": { "witness": "seg://edge/…" },
  "time": { "valid_from": "…", "valid_to": null },
  "policy": { "pii": false, "license_ok": true },
  "weight": 0.83,
  "type": "relates_to",
  "dst": "sha256:…",
  "src": "sha256:…",
  "edge_id": "sha256:src->dst:type@snapshot",
{
Operational: depends_on, executes, witnesses
Semantic: relates_to, contradicts, supports, duplicates
Structural: contains, is_summary_of, derives_from
Edge types are first-class records, not just pointers:
4.1.4 Edges (evidence-native)
}
  "rev": 4
  "snapshot_id": "snap:…",
  "provenance": { "...": "…" },
  "constraints": { "acyclic_contains": true, "max_depth": 8 },
  },
    "qs": 0.87
    "tags": [ { "name": "domain/legal", "tpv": { "priority": 0.73, "relevance": 0.81, "decay": 0.01 } } ],
    "embedding": { "model": "…", "vec": "…" },
    "summary": "hierarchical sum of children",
  "analysis": {
  "indexes": { "span_tokens": [0, 512], "span_time": ["…", "…"] },
  ],
    { "ref": "sha256:atom2", "edge": "contains", "order": 1 }
    { "ref": "sha256:atom1", "edge": "contains", "order": 0 },
  "children": [
  "role": "paragraph|function|conversation|session|codebase|blueprint",
  "type": "molecule",
  "node_id": "sha256:…",
{
4.1.3 Molecule (ordered DAG over atoms/molecules)
}
  "rev": 1
  "snapshot_id": "snap:2025-10-17T12:34:56Z",
  },
    "witness": "seg://node/…"
    "tool_calls": [],
    "prompt_template_id": "tpl://…",
    "weights_hash": "sha256:…",
    "model_id": "llm@vendor#version",
  "provenance": {
  },
    "qs": 0.84 // quality score for this atom (post-ingest checks)
    ],
      { "name": "topic/security", "tpv": { "priority": 0.92, "relevance": 0.88, "decay": 0.03 } }
    "tags": [
    "embedding": { "model": "text-embedding-004", "dim": 768, "vec": "…" },
    "summary": "…",
  "analysis": {
  },
    "license": "…"
    "lang": "en",
    "source": { "uri": "...", "offset": [123, 456] },
    "author": "user|agent-id",
    "created_at": "2025-10-17T12:34:56Z",
  "headers": {
  "content": { "inline": "...", "media_ref": null }, // object-store ref if large
  "modality": "text|code|image|audio|event|vector|schema|plan",
  "type": "atom",
  "node_id": "sha256:…",
{
4.1.2 Atom (immutable payload + rich headers)
rev: semantic revision counter (per node lineage).
snapshot_id: monotone, signed capture of a consistent state.
node_id: content-address (e.g., sha256 of canonical payload + headers).
4.1.1 Core identifiers
), all carried by an evidence-first substrate. No write exists without a snapshot; no composition breaks lineage.
molecules
), recursively composed into larger structures (
atom
 Smallest useful unit (
Design goals.
4.1 Atoms & Molecules (schemas)
 Specify the data model and invariants for a memory-native system that turns every bit of context into structured, queryable, reversible memory—across all modalities—without sacrificing provenance or performance.
Intent.
Chapter 4. Fractal Memory Hierarchy
Part II — Context Memory Core (CMC) & HHNI
 alongside reasoning, and proves it in the graph.
compiles safety
 We don’t “bolt on” safety—AIMOS/APOE 
No capability without a constraint; no answer without a witness.
 
Doctrine.
 (↑)
replay fidelity
 (SLSA level, SBOM completeness), 
Supply-chain conformance
 (↑)
RAG integrity score
 (↓), 
exfil attempt rate
 (↑), 
κ true-positive rate
 (↓)
time-to-detect
 (↓), 
false-positive rate
 (↑), 
Block/jailbreak rate
3.4.9 KPIs for the policy surface
}
  }
    on_fail { abstain "Untrusted sources"; hitl "Source integrity" }
    require vif.complete;
    require sources.signed >= 0.9;
  gate egress {
  run retriever with { query: Q, top_k: 8, policy: "no_external_forms,no_js" }
  }
    require κ(input_risk) < 0.45;
    require pii.redaction == "applied";
    require content.scan.injection == "clean";
  gate ingress {
  budget { tokens: 1500, time_ms: 1500, tools: ["net.fetch[allow:docs.example.com,*cdn*]","fs.read[tmp]"] }
step fetch_context {
3.4.8 Example: policy-aware APOE step (ACL)
: data minimization, purpose binding, retention timers with review.
Privacy by default
: transparent κ rationale; minimal, specific next steps; never “just try harder.”
UX for refusal
: Planner/Builder vs. Operator approvals; Counsel (UQ) cannot be Builder.
Separation of duties
 for high-risk changes (crypto-bound approvals; independent reviewers).
Two-key merges
3.4.7 Governance & human factors
SEG post-mortem with dependency tree.
SBOM diff triage; lockfile audit; increase admission policy level.
Revoke image keys; roll back to last signed image.
SC-03 Supply-chain
Mark deprecations; notify owners; export regulator pack if needed.
Recompute TPV/RS with source penalty; rebuild HHNI for slice.
Isolate source set; verify signatures/checksums.
RP-02 RAG poisoning
Run adversarial suite; adjust policy weights; publish VIF report.
Add contradiction edges for tainted claims; re-index.
Rotate capability token set for impacted tools.
Freeze plan branch (quarantine snapshot).
PI-01 Prompt-injection
3.4.6 Incident playbooks (condensed)
: nightly runs; deltas block promotion of policy packs.
Automation
: block rate, false-positive rate, time-to-detect, κ true-positive rate, coverage of guard families.
Scoring
 be caught).
must
 (known-bad prompts that 
policy canaries
 (URL schemas, MIME tricks), 
connector fuzzing
 (look-alikes, forged refs), 
RAG poisoning set
 (continuously updated), 
Jailbreak corpus
3.4.5 Red-team harness & regression suites
: κ thresholds tuned per domain, validated against adversarial suites (jailbreak corpora, injection galleries).
Calibration
: abstain; present rationale + minimal sufficient questions; offer HITL.
High
: degrade (stricter retrieval, read-only tools), require verifier step.
Medium
: proceed; log κ & UQ.
Low
:
Actions
: low < κ_1 < medium < κ_2 < high.
Risk bands
3.4.4 κ-gating and abstention policy
; export freeze & review.
lease revocation
; 
Key rotation
Respond
: divergence between replay and live lineage.
Replay drift
: unusual query cardinality, exfil-shaped patterns.
Access anomaly
Detect
 for AI-generated content; watermarking when applicable.
Synthetic labeling
; scope-limited tokens; cell-level redaction.
Read-only audit API
Prevent
E) Observation & export boundary
 to SEG with VIF pack.
post-mortem
 off; 
feature flags
 on SLO breach; 
Auto-rollback
Respond
: error budgets with SEG-linked rollouts.
Runtime SLO monitors
: test fault injection; mutation testing.
Pre-prod chaos
Detect
; progressive delivery (canary/blue-green).
Change windows & blast-radius caps
; policy admission (cluster side).
image signing
 gates; 
SLSA/SBOM
: pinned deps, hermetic toolchains, content-addressed artifacts.
Reproducible builds
Prevent
D) Build & deploy boundary
; HITL adjudication.
rebuild indices
; 
time-slice quarantine
 (tombstones); 
Deprecate not delete
Respond
: surge of near-duplicate atoms from new sources; low-trust domains.
Poisoning heuristics
: contradiction edge rate, sudden indegree/outdegree shifts, unusual TPV changes.
Graph consistency
Detect
: HHNI DD threshold, policy packs (PII, license), role approvals.
Write gating
: signed documents; allowed repositories; checksum enforcement.
Source integrity
 semantics.
snapshot-first
 with schema & policy validation; 
Single-writer flow
Prevent
C) Memory boundary (Orchestrator ↔ CMC/SEG)
 for RCA.
evidence snapshot
 offending plan branch; 
auto-quarantine
 per capability; 
Kill-switches
Respond
: taint tracking for sensitive content flowing into tools.
Runtime guards
: all tool invocations mirrored to SEG; diff-aware alarms (unexpected domains, file paths).
Policy audit hooks
Detect
: DNS/HTTP allowlists; signed request headers; response size & type limits.
Egress proxy
: seccomp, network namespaces, read-only mounts, time & CPU quotas.
Ephemeral sandboxes
 (fine-grained: fs.read, fs.write, net.fetch[allowlist], exec[toolset]); least-privilege by step.
Capability tokens
Prevent
B) Tool boundary (Orchestrator → Tools)
 escalation for risky intents.
HITL
 (read-only tools, lower temp, stricter retrieval); 
degrade
 with actionable rubric; 
Abstain
Respond
: high epistemic uncertainty near sensitive intents.
UQ tripwires
: entropy spikes, repetition, tool-intent deviation.
Anomaly sensors
Detect
: per-request token/time/IO ceilings up front.
Budget clamps
: prompt-injection, PII, malware; conservative defaults feed κ.
Classifier ensemble
: structural parsing + allowlisted formats; strip/neutralize model-targeting control tokens from user content.
Content firewall
Prevent
A) Input boundary (User → Orchestrator)
, mapped to each boundary.
Prevent → Detect → Respond
We structure defenses as 
3.4.3 Policy surface: the control lattice
Policy versioning, canary prompts, regression suites
Surface shrinkage
Silent drift of guardrails
Policy rot
Two-key approvals, risk bands, time-locks
Unsafe merge/deploy
Social or UX gap
HITL bypass
Signed snapshots, immutable logs, cross-checks
Audit failure
Fake VIF/SEG records
Provenance forgery
Repro builds, SBOM, pin+verify, image signing & admission
CI compromise, backdoor
NPM/PyPI trojan, base image
Supply-chain
Capability-scoped sandboxes, seccomp, read-only mounts
Lateral movement, tampering
Shell/fs misuse
Tool abuse
Rate limits, quotas, dumbbell compression, early budget clamps
Starvation, κ drift
Token-budget DoS
Context flooding
Egress proxy, DNS/HTTP allowlists, fetch-capability tokens
Internal network exposure
Untrusted URL fetch
SSRF / Egress abuse
DLP/redaction, secret shims, output scanners, data diodes
Data breach
Coax model to leak secrets
Exfiltration
Source signing, document allowlists, triage scores, contradiction edges in SEG
Hallucinated but “grounded” output
Corrupted/forged sources
RAG poisoning
Content firewalls, allowlisted tool intents, κ-abstention, role separation
Tool misuse, policy bypass
Instruction smuggling in docs
Prompt injection / Jailbreak
Controls (preview)
Impact
Example
Class
3.4.2 Threat taxonomy (STRIDE×LLM) and misuse catalog
 (long-horizon poisoning of memory & lineage)
Advanced persistent
 (malicious dependency/image/template)
Supply-chain actor
 (credential abuse, policy bypass, data dragnet)
Insider
 (malicious connector, poisoned RAG corpus)
Grey-box integrator
 (jailbreaks, prompt injection, exfiltration)
External opportunist
Adversary profiles
 (APIs, dashboards, exports)
Observers
 (package, sign, deploy)
Build > Runtime
 (write/read to CMC & SEG)
Orchestrator > Memory
 (exec, network, filesystem)
Orchestrator > Tools
 (prompt input, file upload)
User > Orchestrator
Trust boundaries
: logs, traces, κ/UQ dashboards, cost/budget data.
Telemetry
: source repos, SBOMs, images, keys, environment configs.
Build & deploy
: sandboxes, credentials, egress channels, data connectors.
Tool surface
: ACL pipelines, budgets, prompts/templates, κ policies.
APOE plans
: claims, evidence, tool calls, decisions; time-sliced lineage.
SEG
: atoms, indices, snapshots; HHNI dependency graph; secrets in metadata.
CMC
Crown-jewel assets
3.4.1 Assets, trust boundaries, and actors
 lineage.
prove
 uncertainty, and 
measure
 power, 
constrain
 misuse, 
anticipate
: the system must 
security, safety, and privacy as first-class capabilities
 AIMOS/APOE operates on living memory, executes tools, and ships software. That makes it a high-value target. We treat 
Thesis.
3.4 Threat & Misuse Model (policy surface)
 reproducible, witnessed, and safe. The IDE in the loop is how APOE turns plans into running, verifiable systems without breaking the invariants that keep AIMOS honest.
Ship reasoning the way you ship code:
Doctrine. 
Guarantees: deterministic replays under frozen snapshots; provenance-complete releases; bounded autonomy via κ-gates; one evidence graph for all actions.
KPIs: spec↔code parity ≥ 0.9; test pass ≥ 0.9; line coverage ≥ 0.85; CFR ≤ 10%; MTTR ≤ target; κ true-positive rate.
3.3.8 KPIs & guarantees
Dependency volatility → lockfiles + SBOM diffs; fail closed on unexpected supply-chain changes.
Over-automation → κ increases with risk class; HITL on merges & deploys; degrade instead of “try harder.”
Prompt-rot / flaky builds → pin prompts/templates per step; cache seeds; use deterministic containers.
Spec↔code drift → enforce parity gates; auto-generate failing tests; quarantine branch.
3.3.7 Failure modes & mitigations
Every gate writes a decision envelope (metrics, κ, policy hash) to the SEG; every artifact carries a VIF (model id, weights hash, prompts, snapshot id).
}
  }
    gate egress { require slo.error_budget.ok; emit rollout, traces }
    run operator with { target: "staging", strategy: "bluegreen" }
    gate ingress { require window.change_open; require risk.blast_radius <= "staging" }
  step deploy depends package {
  }
    gate egress { require provenance.slsa >= 2; emit attestation }
    run packager with { dockerfile: "./app/Dockerfile" }
  step package depends test {
  }
    gate egress { require tests.pass >= 0.9; require coverage.line >= 0.85; emit vif, coverage }
    run verifier with { cmd: "pnpm test --coverage" }
  step test depends generate_code {
  }
    }
      emit vif
      on_fail { quarantine; hitl "Security issues" }
      require sast.crit == 0
      require lint.errors == 0
    gate egress {
    run builder with { repo: "./app", targets: ["auth", "users"] }
    gate ingress { require parity.spec_code >= 0.8 }
  step generate_code depends scaffold {
  }
    gate egress { require sbom.ok; emit vif }
    run scaffold with { template: "react+fastapi", dst: "./app" }
    gate ingress { require policy.licenses.allowed; require κ(R*) < 0.4 }
  step scaffold depends plan_blueprint {
  }
    gate egress { require vif.complete; emit seg.link("ADR-001") }
    run planner with { blueprint: "specs/app.yaml" }
  step plan_blueprint {
  budget { tokens: 20000, latency_ms: 4000, tools: ["fs:sandbox", "node:20", "docker:build", "k8s:staging"] }
pipeline AppV1 {
3.3.6 Minimal executable example (ACL)
Two-key merges: risk≥θ requires dual human approvals; both identities and diffs logged to SEG.
Degradation recipes: strict prompts, read-only tools, smaller context, temperature clamp, extra retrieval.
Pre-exec gates: no code exec without sandbox + policy hash; no network egress without egress proxy & allowlist.
3.3.5 Safety & policy hardening
Counsel emits UQ & κ decisions; Witness stamps VIF; Archivist writes SEG.
Operator packages/deploys with rollout policies.
Verifier runs tests, computes parity, mutation, security.
Builder generates/refactors code under budgets.
Planner compiles blueprint → plan graph.
3.3.4 Roles in the loop (APOE)
All stages run in ephemeral, capability-scoped sandboxes with read/write tools whitelisted per step.
traces, metrics snapshots
SLO error budget checks
logs, traces, KPIs
Observe
change ticket, rollout events
change window, blast radius
env plan, rollout
Deploy
provenance (in-toto), digest
supply-chain attestations
image/artifacts
Package
junit, coverage.json
pass ≥ θ, mutation score ≥ θ
suite matrix, coverage
Test
diffs, lint/SAST reports
parity(spec↔code), lint, SAST
patches, ASTs
Codegen/Refactor
SBOM, license report
license/headers, policy packs
file graph, diffs
Scaffold
spec@sha, prompt templates
schema, policy, ambiguity check
YAML/ADR/spec tree
Blueprint
Witness artifacts
Gates (examples)
What APOE sees
Stage
3.3.3 The pipeline surfaces (what the IDE exposes to APOE)
A UI text editor replacement; unrestricted code exec; bypassing corporate SDLC.
Non-goals:
Budget discipline (tokens, time, cost surfaced as first-class constraints)
End-to-end provenance (VIF envelopes into SEG)
Bounded autonomy (κ-gates + HITL for high-risk merges)
First-class tests (gates use coverage & parity, not vibe)
Reproducible builds (containerized, pinned deps, signed outputs)
Goals:
3.3.2 Design goals & non-goals
 faster diagnosis and better auto-repair. Failures feedback into prompts and plans immediately; prompts get hardened by concrete build/test telemetry.
⇒
Tight loop 
E. Latency & learning.
Specs, prompts, code blobs, test results, coverage, and SBOMs are linked in one provenance thread. Audit reads one graph instead of reconciling multiple CI/CD logs.
D. Single lineage (VIF/SEG).
 anything touches prod.
before
Before code exec, network egress, or deployment, gates check RS/UQ/policy/budget. Unsafe paths degrade, reroute to verification/HITL, or abort—
C. Inline safety (κ-gating).
Plans compile to typed steps that invoke the actual toolchain (scaffold, lint, test, package, deploy) under fixed budgets and seeds. Replays use frozen containers + lockfiles; identical inputs produce identical build graphs.
B. Determinism & replay (APOE).
traces, and deployment artifacts to the same atomic commit and the same snapshot id, enforcing parity gates at each boundary.
Separate chat + dev stacks drift. IDE-in-the-loop binds doc edits, code changes, test 
A. Parity over time (SDF-CVF).
3.3.1 Why an IDE inside APOE (and not a separate toolchain)
 what it reasons, then reasoning and software production cannot be split. The IDE belongs inside the orchestration loop so that spec ↔ code ↔ evidence stay in lock-step (SDF-CVF), κ-gates can halt unsafe actions, and every artifact carries a witness (VIF) into the SEG.
ship
 what it knows and 
prove
Thesis. If the system must 
3.3 IDE-in-the-Loop Rationale
 κ-gating is how the system proves it.
If you can’t prove it’s safe, you can’t prove it’s useful.
Doctrine. 
Composability. Gates are first-class ACL constructs; they compose with roles, budgets, and tools without side-channels.
Provenance. Every gate writes a decision envelope to SEG (who/what/why/when, including κ, R*, and active policy).
Determinism under fixed context. Given the same M_t, policy hash, budgets, and seeds, κ-gates make the same decisions (or abstentions).
3.2.11 Guarantees
Split hard vs. soft predicates; log counter-examples; adjust rules via HITL.
Over-blocking benign content
Policy false positives
 once per branch.
Degrade
Put hard caps on reroutes; prefer 
Reroute loop expands chain
Latency blowouts
Recalibrate; enforce temperature sweeps; require ECE witness before publish.
Low ECE training, high test ECE
Silent overconfidence
Add hysteresis δ; rate-limit re-entry; cache previous decision for Δt.
Rapid degrade/proceed cycles
Gate flapping
Mitigation
Symptom
Mode
3.2.10 Failure modes & mitigations
One-click paths. “Approve once”, “Always approve for this repo”, or “Tighten policy”.
Traceability. A “Why paused?” link opens the VIF bundle (policy hash, κ, metrics, snapshot id).
Bands, not decimals. Green/Amber/Red badges with short tooltips; full metrics in a collapsible panel.
Plain reason + next action. “I’m pausing because retrieval is thin (RS=0.42). I can: (a) search your docs, (b) ask 3 clarifying questions, or (c) proceed in safe-mode.”
3.2.9 UX for abstention (what the user sees)
}
  }
    }
      on_fail { quarantine; hitl request "Spec/code parity low" }
      require parity.spec_code >= 0.9
      require tests.pass_ratio >= 0.9
    gate egress {
    run builder …
    gate ingress { require budget.tokens_left >= 0.3 }
  step generate_code depends retrieve_spec {
  }
    gate egress { emit vif, uq, rs }
    run retriever …
    }
      }
        if (policy.prompt_injection) abort "Policy violation";
        if (UQ.ece > 0.05) degrade { temp: 0.2, style: "strict" };
        if (RS < 0.65) reroute add_retrieval;
      on_fail {
      forbid policy.prompt_injection
      require UQ.ece <= 0.05
      require RS >= 0.65
    gate ingress {
  step retrieve_spec {
  budget { tokens: 12000, latency_ms: 2000, tools: ["sandbox:v2"] }
pipeline BuildFeatureX {
3.2.8 APOE/ACL expression (executable example)
Explainability on: require rationales, cite-keys, and uncertainty bands in UI.
Tool downgrades: read-only sandboxes; disable network writes; deny code exec; cap concurrency.
Template hardening: switch to strict, minimal prompts; disable creative expansions; force structured outputs.
Context diet: apply dumbbell compression more aggressively; pin top-K atoms with highest TPV; avoid mid-body bloat.
3.2.7 Degradation strategies (safe modes)
Rule of thumb: If ECE > 0.05 on the class of tasks in play, force Degrade (more retrieval, lower temperature) or Reroute to verification.
Budget-aware κ. When β_tok or β_lat approaches 1.0, κ tightens (risk of prompt-rot / timeout rises).
Context-aware κ. Raise κ for sensitive datasets, lower for public FAQs.
 deploy steps; higher κ for read-only retrieval.
Engineer
Per-role κ. Lower κ for 
Calibrate UQ offline with held-out corpora; compute ECE bins; set κ per domain and action class.
3.2.6 Calibration and thresholds
Policies are declarative (e.g., Rego/SHACL-like over JSON-LD/VIF envelopes) and versioned; the active policy hash is part of the witness.
Soft predicates (graded): sensitive topics, thin retrieval, low calibration → Degrade or Reroute.
Hard predicates (binary): disallowed domains, PII exfiltration, local file read outside sandbox, network egress beyond egress proxy → immediate Abort.
3.2.5 Policy model (hard vs. soft)
Before publish. Counsel’s Witness Gate checks UQ calibration and lineage completeness; no witness → no publish.
On tool invocation. Before any external call (browser, code exec, file I/O), enforce Capability Gates (policy + budget).
At plan boundaries. Every APOE step starts with an Ingress Gate (pre-work) and ends with an Egress Gate (pre-handoff).
3.2.4 Where κ-gates live (chain anatomy)
Hysteresis prevents flapping: once degraded, require R* < κ_low − δ to return to full power.
Incident-grade VIF + SEG contradiction edge if hostile input.
Stop; emit safe explanation and next steps; snapshot state for replay.
r_policy=1 hard violation or budget breach
Abort
Store reviewer identity, decisions, timestamps, comments.
Pause; request two-key approval or edits; show diffs and impacts.
R* ≥ κ_high on high-risk data/actions
HITL
Link to new sub-plan and its budgets.
Change plan: add retrieval, add verification, switch to safer template.
R* ≥ κ_mid but fix is available
Reroute
Attach “degradation profile” and rationale.
Reduce capability: smaller context, safe-mode tools, redact outputs, lower temperature.
κ_low ≤ R* < κ_mid
Degrade
Record metrics + benign decision record.
Continue with planned tool/role.
R* < κ_low
Proceed
Evidence (VIF/SEG)
Action
When triggered
Outcome
3.2.3 Gate outcomes (finite set)
Design note. Use max for fail-closed behavior on hard risks (policy). For softer regimes, L∞ can be replaced with a convex combination; always preserve monotonicity and calibrate α-weights per domain.
Proceed iff R* < κ. Otherwise, gate.
          α_ctx·r_context )
          α_budget·r_budget,
          α_policy·r_policy,
          α_UQ·r_UQ,
R* = max( α_RS·r_RS,
Composite risk (monotone aggregator):
r_context derives from sensitivity class (e.g., 0.7 for PII)
r_budget = max(β_tok, β_lat)
r_policy = 1 if any hard predicate fails, else 0 (or fractional under soft rules)
r_UQ = clamp(w1·norm(H) + w2·ECE + w3·norm(Var) + w4·Δ)
r_RS = 1 − RS
r = ⟨ r_RS, r_UQ, r_policy, r_budget, r_context ⟩, where, for example:
Define a normalized risk vector
Context risk: data classification (public/internal/sensitive), action class (read-only vs. write/vend).
 [0,1], cost burn rate, remaining budget slack.
∈
Budget: token & latency utilization β_tok, β_lat 
Policy: Boolean predicates over content/tooling (PII present? disallowed domain? prompt-injection heuristics?).
Uncertainty (UQ): entropy H, expected calibration error ECE, variance of sampled outputs Var, and disagreement score Δ (e.g., temperature sweep/ensemble).
 [0,1] (Section 4–5), plus coverage and novelty.
∈
Retrieval: RS 
Let a step produce metrics:
3.2.2 Signals that feed κ
Gate. A typed decision point in a chain step that consumes metrics + policy and produces {proceed | degrade | reroute | HITL | abort} plus a witness for why.
κ (kappa). A configurable abstention threshold applied to one or more signals (retrieval quality, uncertainty, policy risk, budget pressure). If the composite risk exceeds κ, the system gates.
 with the current inputs and budgets. Abstention is not failure; it is control.
now
Abstention. A deliberate, explainable refusal to proceed 
3.2.1 Core concepts
 that decides what not to do—early, explicitly, and reproducibly. κ-gating is the mechanism that lets APOE halt, narrow, or reroute work when uncertainty, policy, or budget signals say “stop.”
first-class control system
Intent. Treat safety not as a filter bolted on at the end, but as a 
3.2 Safety as Capability (abstention, κ-gating)
With these scopes and contracts, “C-3PO-with-a-Workshop” stops being a metaphor and becomes an operating model: the right agent, with the right budget, doing the right work, leaving the right evidence.
Budgets are real; safety is a feature.
Operator: 
No witness, no publish.
Counsel: 
Plans before code; parity before pride.
Engineer: 
Store what you can prove, and prove what you store.
Archivist: 
Translate without leaking.
Ambassador: 
3.1.10 Doctrine (one-liners per role)
New stacks: Engineer adds templates/components; parity and license gates inherit.
New guardrails: Counsel updates SHACL/JSON-LD; UI adds banding; Operator enforces.
New modalities: Archivist adds atom schema + embedder; HHNI updates taggers.
New tools: Ambassador extends capability tokens & schema; Operator assigns sandbox tier.
3.1.9 Extension points
Publish with SEG lineage: claim → evidence → decision, as-of the deployment commit.
Operator checks budgets and SLOs; deploys to preview; telemetry attached.
Counsel calibrates UQ, builds VIF; replays on pinned snapshot; green band.
Engineer compiles APOE plan: update code + tests; runs IDE-loop; parity gate passes.
Archivist atomizes change; links to prior spec via HHNI; creates snapshot_id.
Ambassador parses the human edit; strips PII; emits typed change request.
3.1.8 Example: end-to-end “spec change → running code”
 abort chain step; suggest compression; open DEPP re-plan; notify user with partial witness.
Action:
 tokens/latency > budget. 
Signal:
Budget blowout (Operator).
 block publish; run temperature sweep; attach VIF; reroute to HITL.
Action:
 low calibration, missing witness path. 
Signal:
Overconfident publish (Counsel).
 quarantine branch; auto-fix suggestions; require two-key approval.
Action:
 parity gate fail, flaky tests. 
Signal:
Spec/code divergence (Engineer).
 trigger reindex job; tighten dumbbell compression; annotate SEG with drift incident; temporary κ-raise for risky reads.
Action:
 RS-lift drop, precision@k regression. 
Signal:
Index drift (Archivist).
 revoke capability token; rotate sandbox; mark SEG contradiction on offending instruction; require HITL before re-enable.
Action:
 unexpected DNS/HTTP egress. 
Signal:
Prompt injection → tool misuse (Ambassador).
3.1.7 Common failure modes & playbooks
Operator: budget breach <1% chains; κ-abstention true-positive rate ≥ target; MTTD < 5 min.
Counsel: lineage completeness ≥0.99; ECE ≤ θ; replayable claims 100%.
Engineer: spec↔code parity ≥0.9; coverage ≥80%; CFR <10%; MTTR within target.
Archivist: precision@10 ≥ target at p95≤SLO; ≥99.99% snapshot durability; replay success ≥99.5%.
Ambassador: 0 critical guardrail escapes; ≥99.9% schema-valid messages.
3.1.6 Role-scoped SLOs (minimum bars)
Rule: no envelope → no work. Missing snapshot_id or asOf → reject (C-2, S-1).
}
  "uq": {"ece": 0.03, "entropy": 1.7, "band": "green"}
  "vif": { "model": "gpt-x", "weights_hash": "sha256:…", "prompt_template": "tpl_…"},
  "payload": { "... domain object ..." },
  "budget": {"tokens": 12_000, "latency_ms": 1500, "tools": ["sandbox:v2"]},
  "actor": "Engineer|Archivist|…",
  "snapshot_id": "snap_…",
  "asOf": "2025-10-18T12:34:56Z",
  "envelope_id": "uuid",
{
All inter-role handoffs are typed envelopes:
3.1.5 Handoffs (message shapes)
I: Compliance
C: Engineer (spec parity), Ambassador (display/UX)
A: Operator (policy), Archivist (snapshot pin)
R: Counsel
Flow C — Publish Claim (witnessed output)
I: All (release announcement)
C: Archivist (snapshots), Ambassador (tool contracts)
A: Operator (budgets), Counsel (calibration gate)
R: Engineer
Flow B — Plan→Build (APOE) with IDE-in-the-loop
I (Informed): Engineer (downstream reads)
C (Consulted): Ambassador (redaction policy), Counsel (VIF tags)
A (Accountable): Operator (C-1/C-2 adherence)
R (Responsible): Archivist
Flow A — CreateMemory (ingest → atomize → snapshot → SEG)
3.1.4 RACI for canonical flows
lineage ≥ 0.99, ECE ≤ θ
lineage completeness, ECE
Counsel
Verifiability
CFR < 10%, parity ≥ 0.9
coverage %, spec↔code score
Engineer
Quality/Parity
precision@k@latency, replay success
p95 read/write, index hit-rate
Archivist
Memory I/O
Zero SSRF/exfil events
sandbox tier, network scope
Ambassador/Operator
Tool Risk
Budget adherence %, p95 < SLO
tokens_per_step, p95 latency
Operator
Token/Latency
Leading KPIs
Examples
Owner
Budget Class
3.1.3 Budget classes & KPIs (owned per role)
Mitigations: token governors, rot monitors, sandbox rotations, kill-switch.
Failure modes: budget blowouts, prompt rot, tool compromise.
Gates: κ-abstention on risk, budget aborts, guardrail violations.
Outputs: throttling, re-routing, incident packs, exports.
Inputs: chain traces, budgets, telemetry.
Operator (cross-cutting)
Mitigations: parity gate, temperature sweep calibrations, quarantined branches.
Failure modes: spec drift, silent miscalibration, flaky tests.
Gates: unit/integration thresholds, ECE<θ, parity checks, license & SBOM.
Outputs: code, tests, deploy artifacts + UQ & VIF manifests.
Inputs: plan graph (ACL), retrieved context, tool chain.
Engineer ↔ Counsel (build/verify path)
Mitigations: super-index precompute, mark-and-sweep reindex, abstain on low RS.
Failure modes: lost-in-the-middle, stale indices.
Gates: RS threshold, dumbbell compression, contradiction flags from SEG.
Outputs: HHNI coarse set → atom pack, RS metrics, snapshot_id.
Inputs: query, asOf, budget.
Archivist → Engineer (read/plan path)
Mitigations: strict schemas, redaction traces, egress proxy.
Failure modes: schema drift, late PII, tool SSRF.
Gates: PII redaction, tool allowlist, prompt-injection filters, max-tokens.
Outputs: sanitized request, candidate atoms.
Inputs: raw user/tool context C_t, policy profile, capability token.
Ambassador → Archivist (write path)
3.1.2 Role contracts (inputs, outputs, gates)
Operator ↔ operator (budgets, SLO, safety)
Counsel ↔ verifier + witness (provenance/UQ side)
Engineer ↔ planner + builder + verifier + critic
Archivist ↔ retriever + witness (memory side)
Ambassador ↔ router + retriever wrappers
Mapping to APOE micro-roles:
Cost ceilings, runtime policy enforcement, containment paths.
Budget dashboards, drift/rot signals, incident packs.
SLOs, token/time budgets, OpenTelemetry, guardrails.
Keep the system budgeted, observable, safe.
Operator
Calibration error budgets, attestations, claim lineage.
Confidence bands, VIF manifests, replay receipts.
UQ calibrators, provenance schemas, replay pins.
Quantify uncertainty and attach witness (VIF/SEG).
Counsel
Spec↔code parity, supply-chain hygiene, reproducible builds.
Build artifacts, coverage & parity reports, preview envs.
APOE plans, ACL specs, scaffolds, codegen, tests, deploy units.
Compile intent into working software (IDE-in-the-loop).
Engineer
Schema integrity, time slicing, deduplication, rollback points.
Atoms, indices, snapshot_id, lineage deltas, RS metadata.
Atomization pipelines, indices, snapshots, SEG edges.
Turn context into memory (CMC/HHNI) with reversibility.
Archivist
Capability boundaries, prompt-injection shields, PII redaction.
Canonical requests/responses (typed), policy-clean inputs to chains.
Protocol adapters, schema mappers, tool routers.
Translate between humans ↔ tools ↔ data ↔ devices.
Ambassador
Protects
Produces
Owns
Mission
Macro-Role
3.1.1 Macro-roles (what they own, produce, and protect)
 the micro-roles from APOE (planner, retriever, reasoner, verifier, builder, critic, operator, witness).
contain
 of AIMOS/APOE. These roles make “machine communication” tangible: they speak protocols, remember with integrity, compile plans into actions, and keep the shop safe. Think of them as macro-roles that 
operational cast
Intent. Define the 
3.1 C-3PO-with-a-Workshop: Roles & Scopes
Chapter 3 — Design North-Star
This table is the contract of the system. If a feature can’t point to its row—what axiom it fulfills, how it proves compliance at build time, and how it stays honest at runtime—it doesn’t ship
2.6.7 Why this matters
S-series → Evidence KPIs (as-of coverage, pack integrity, contradiction coverage).
E-series → DORA KPIs (CFR, MTTR, parity).
W-series → Verifiability KPIs (lineage %, ECE).
O-series → Orchestration KPIs (determinism %, budget adherence, κ true-positive rate).
C-series → Memory KPIs (precision@k, replay success, read latency).
2.6.6 Mapping to KPIs
Parity fail (E-1): Branch quarantined; launch auto-fix; require two-key HITL merge.
Replay fails (W-3): Freeze route; pin previous snapshot; incident type REPLAY-BREAK; RCA must include SEG pack.
Budget overflow (O-1): Auto-abstain, surface partial witness, open DEPP sub-plan to re-budget.
2.6.5 Run-book Triggers (examples)
  - assert: SUGGEST deprecate(edge_id) + add(contradicts)
  - assert: REJECT
then:
given: mutation.delete(edge_id)
# PT-SEG-003 — No destructive delete
  - assert: exists(seg.best_witness_path(artifact, asOf=now))
then:
when: publish_request
given: artifact.claim
# PT-VIF-002 — Lineage required to publish
  - assert: every(step).has(budget.tokens & budget.time & budget.tools)
then:
when: compile
given: acl_plan.yaml
# PT-APOE-001 — Budgets required
2.6.4 Minimal Policy Tests (pseudo)
DORA metrics exported (E-3)
Auto-fix chain available; quarantine path tested (E-2)
Code/docs/tags/traces changed together (E-1)
SDF-CVF
Export pack checksum reproducible (S-3)
Contradictions via edges, not deletes (S-2)
Queries specify asOf/txnAsOf (S-1)
Confidence bands visible; ECE < θ (W-2)
JSON-LD valid; SHACL passes (W-1)
VIF/SEG
Replay passes on pinned snapshot (W-3)
Step outputs {artifact, uq, prov, diff} (O-3)
Required roles present; verifier isolated (O-2)
All steps declare budgets (O-1)
APOE/ACL
SEG edges (derives/supports) recorded on write
Read path executes HHNI→atoms with dumbbell compression (C-3)
Every response includes snapshot_id (C-2)
Only CreateMemory service account may write (C-1)
Memory API (CMC)
2.6.3 Acceptance Checklists (per subsystem)
: % queries with asOf, pack integrity rate.
Graph
: CFR, MTTR, parity score.
Evolution
: lineage completeness %, ECE bands, contradictions coverage.
Verifiability
: budget adherence, determinism %, κ-abstentions (true-positive).
Orchestration
: precision@k@latency, snapshot replay success.
Memory
Dashboards (minimum).
SEG: node/edge metadata axiom_ids: ["VIF","SEG"], constraint_ids: ["W-1","S-1"]
ACL: gate id: O-3.boundary_uq_prov
Comments: @axiom CMC @constraint C-2
IDs in code & plans.
2.6.2 Crosswalk: Design Artifacts & Where They Live
Fail audit → halt release
Pack creation SLO & signature validity
Checksum reproducibility test
Deterministic “pack” bundles (JSON-LD+blobs+manifest)
S-3 Export packs
Require approver signature
Contradiction coverage shown in UI
Mutation tests forbid delete; require deprecate+edge
Use contradicts edges; no destructive edits
S-2 Contradictions first-class
Block anonymous slice; ops page
% queries with explicit slice == 100%
API lint: reject missing asOf
Every read requires asOf/txnAsOf
S-1 Time-slicing API
SEG Evidence is a graph
Change freeze; postmortem in SEG
CFR < 10%, MTTR within target
CI exports metrics; dashboards
CFR/MTTR per repo visible
E-3 DORA telemetry
Escalate to Maintainer; backout
Mean quarantine time < target
Simulated failures must trigger auto-fix
Remediation chains for common failures
E-2 Auto-fix/Quarantine
Quarantine branch; auto-fix task
Drift monitor: spec↔code parity score
CI gate: fail if parity missing
Same-commit updates across code/docs/tags/traces
E-1 Parity gates
SDF-CVF Evolve atomically
Freeze model route; incident RCA
Replay failure rate < SLO
Deterministic replay test on nightly pins
Snapshots pin models/prompts/tools; replay() must succeed
W-3 Replayability
force HITL
Raise risk class; 
Live ECE & κ-abstention rate dashboards
ECE < θ in eval
Visual regression tests; 
UI shows confidence bands by default
ence hygiene
W-2 Confid
Rollback publish; require witness path
Missing-lineage counter == 0
Schema conformance (SHACL) in CI
All artifacts serialize VIF schema
W-1 JSON-LD lineage
VIF Lineage or it doesn’t exist
Block chain merge; open HITL review
% steps with UQ & prov == 100%
Contract test: step must return {artifact,uq,prov}
Each step emits UQ, provenance, diff
O-3 Boundary gates
Trigger “thin-verifier” incident
Role skew monitor (e.g., verifier invoked %)
Plan compile: role coverage & segregation checks
Planner/Retriever/Reasoner/Verifier/Builder/Critic/Operator/Witness
O-2 Typed roles
to operator
Auto-abstain; route 
Budget burn chart per chain; overflow alarms
rejects missing budgets
Static ACL linter (EBNF) 
ACL requires tokens/time/tools per step
s explicit
O-1 Budget
is compiled
APOE Reasoning 
Re-index; raise read budget temporarily
p50/p95 read-latency + precision@k vs. baseline
Golden query diff vs. flat read
HHNI coarse → atoms (dumbbell compression)
C-3 Two-stage read
Freeze endpoint; hotfix gate
Ratio: responses_without_snapshot_id == 0
Contract test on APIs: 4xx if missing snapshot
No artifact exposed without snapshot_id
C-2 Snapshot-first
Quarantine shard; rotate keys; RCA in SEG
Alert on any write bypass (DB audit log rule)
Unit: reject direct DB writes; Policy test: block non-flow service accounts
All writes go through CreateMemory flow; one queue/txn domain
C-1 Single-writer
CMC Memory must persist
Escalation
Runtime Monitor
Verification (Build-time)
Design Manifestation
Constraint (ID)
Axiom
2.6.1 Master Traceability Table
IDs are stable; they appear in code comments, ACL plans, SEG nodes, and dashboards.
Purpose. Make every invariant operational. Each line binds: Axiom → Non-negotiable constraint → Design manifestation → Verification → Runtime monitor → Escalation.
2.6 Axioms → Design Constraints (traceability table)
Chapter 2 — System Axioms
Bottom line: By making evidence a time-aware, signed, typed graph—never a log of strings—we earn replayability, auditability, and composable trust. This is the substrate that lets everything else (memory, orchestration, evolution) remain coherent over time.
SDF-CVF merges cannot proceed unless the graph proves parity.
VIF has a canonical place to live and propagate trust.
APOE can compile to witnesses, not prose, and re-execute plans on pins.
CMC can persist atoms with lineage preserved forever as-of.
11) What SEG guarantees the rest of the system
Pin / Replay controls bound to Snapshot nodes.
Export button (pack includes JSON-LD subgraph, blobs, signature manifest, checksums).
Conflict banner with navigation to contradicting claims.
Best witness panel (path, UQ, signatures).
As-of switcher on every evidence view.
10) Operator & UX commitments
.
. UI shows confidence drop and link to 
→ same path but penalized by contradiction: 
@ 
Explain 
.
; 
+ toolcall 
→ returns path 
@ 
Explain 
Queries:
.
starts at 
(reason: updated regulation) and 
(“Policy X does not apply to Y”) with 
Later, 
, 
Edges: 
(“Policy X applies to dataset Y”)
(RAG retrieval; model M, weights W, prompt P; UQ u)
(extracted paragraph) with 
(doc hash H_A)
)
9) Minimal worked example (as-of 
: store key fingerprints in export packs; rotate with cross-signed manifests.
Mitigation
: unverifiable content after retention rotation.
Symptom
Signature drift.
: enforce DAG on derives at write time (topological check on slice).
Mitigation
: replay non-termination.
Symptom
Cycle in derives.
from qualified principals; throttle by reputation; show penalty but gate acceptance.
: require 
Mitigation
: cascades of low-quality contradict edges.
Symptom
Contradiction storms.
.
: schema rule—any edge referencing a Snapshot must satisfy 
Mitigation
: edges valid outside the parent snapshot window.
Symptom
Temporal leaks.
: block publication; open DEPP task for witness acquisition.
Mitigation
.
: 
Symptom
Orphan claims.
8) Failure modes & mitigations
tracks transaction intervals, redaction or retention expiration is observable in audit mode even when validity has ended.
Because 
No hidden deletion.
. This ensures historic auditability.
for 
; it may create contradictions that alter 
Adding new edges or nodes never invalidates prior accepted claims as-of their acceptance time 
Monotonicity under extensions.
and all tool calls are either pure or re-executed in simulation mode with pinned inputs. Because derivations are a DAG and all nodes are content-addressed, path reconstruction is deterministic.
are valid at 
, replay on snapshot pins succeeds iff all edges in 
with witness path 
accepted at time 
Given a claim 
Replay soundness.
7) Soundness & monotonicity sketches
Repeated assertions with identical payloads collapse by content-address keys.
Idempotence.
export_pack(root, t) → bounded subgraph with signatures + hashes.
with human signature.
approve(decision, approver) → 
; record cause.
deprecate(edge_id, t_close) → set validity 
link_contradicts(u,v,reason,τ) → explicit conflict.
link_supports(u,v,meta,τ) → add supporting edge.
.
with 
link_derives(u,v,meta,τ) → add 
.
with 
assert_claim(payload, snapshot_id, uq) → 
All writes are append-only; mutations create new versions with new transaction intervals.
6) Operations (append-only discipline)
is number of contradicting claims on slice.
where 
Maintain bitsets per claim of active contradictors; update penalty product in 
Contradiction accounting.
.
using delta-propagation until change < 
for reachable 
updates, recompute 
Maintain reverse dependency lists; when 
Incremental recompute.
.
per query; amortize via 
Complexity: 
(e.g., upper bound on remaining support).
; prune with time-aware admissible heuristic 
Use label-setting variant of Dijkstra with edge cost 
Best-witness search.
worst-case; typical is bounded by degree & hop cap.
Complexity: 
.
edge/type filter; 2) interval containment 
As-of traversal. Two filters on each expansion:
Core procedures.
: signature manifest keyed by content-address.
: per-node top-k witness cache (path sketches) per risk class.
(txn-time).
(valid-time) and 
: interval index on 
→ edge ids (fan-out).
: 
Indexes.
Projection: RDF/JSON-LD for interoperability (Chapter 15 covers shapes).
.
and 
Primary: property graph (adjacency index + columnar attributes), augmented with interval trees on 
Storage choice.
5) Algorithms & indexing
defaulting to “now” unless specified.
with 
All operators preserve bitemporality: they operate on 
Explain: returns best witness path plus UQ vectors and signatures.
.
Best witness: 
.
Conflict set: 
.
Impact (forward): 
.
Lineage (backward): 
.
hops over edges of type 
→ nodes within 
Neighborhood: 
.
→ 
Slice: 
.
denote evaluation at 
We define an algebra over typed, temporal graphs; let 
4) Query algebra (time-aware)
Locality: Updating an edge rescales only scores reachable from that edge (facilitates incremental recompute).
(penalties only from explicit contradicts).
Monotonicity under addition: adding a new supporting path cannot decrease 
Properties.
tunes penalty strength.
, and 
at 
are claims contradicting 
where 
Contradictions apply as penalties:
is path length.
: hop attenuation; 
: node reliability (publisher reputation, model calibration for ToolCall, human approver class).
).
: edge weight (evidence strength, calibration-adjusted; decays with age: 
.
to any 
paths from 
) 
: set of valid (at 
:
at time 
for a claim 
We define a bounded, composable support score 
3) Trust calculus on a typed, temporal graph
S-4 Replay pins: a Snapshot node freezes model id, weights hash, prompt template id, tool versions; plans/claims reference snapshots by id.
S-3 Export packs: deterministic projection of a bounded subgraph to a portable bundle (JSON-LD + binary blobs + signature manifest).
S-2 Contradictions: represent as edges, never destructive edits; UIs render red stripes across affected claims.
. Defaults must be explicit.
and/or 
S-1 Time-slicing API: every read includes 
Design constraints (expanded):
from the responsible principal.
NF-5 (Signatures): Any edge that changes a public artifact (e.g., Decision) must carry 
NF-4 (Minimality): Derivation paths should be irredundant (no subpath removal preserves reachability).
.
NF-3 (Witness completeness): A Claim is publishable iff there exists a supported derivation path to at least one Source on 
add explicit contradicts edges with a reason/code.
on validity, and/or
set 
NF-2 (No deletion): Retractions are encoded as
NF-1 (Identity): Every vertex has a content-address (hash of canonicalized payload).
2) Normal forms & constraints
. Cycles may exist across other relations but are disallowed in derives to preserve replayability.
, then 
Edges of type derives form a time-respecting DAG on any as-of slice: if 
Causality discipline.
(even if validity is past/future).
s.t. 
: 
Audit snapshot at processing time 
.
and 
s.t. 
: 
As-of snapshot at time 
Time slices.
: cryptographic signatures for nodes/edges (model key, tool key, human approver).
Signatures 
: edge payload (provenance hash, tool id, prompts, weights, confidence).
Attributes 
: node schemas (minimal shape: id, type, content hash, content addr, author keys, UQ vector if claim).
Signatures 
(when the record exists in the store). Together they give bitemporal semantics.
Transaction-time 
(when the statement holds in the domain).
: valid-time interval 
Validity 
Multi-edges allowed.
with relation types
Edges 
.
: typed nodes 
Vertices 
We model the Shared Evidence Graph as a bitemporal, typed, edge-labeled multigraph with signatures:
1) Formal model
All claims, sources, tool invocations, derivations, and decisions must be represented as a time-aware, typed, signed graph. Deletion is replaced by deprecation; contradiction is first-class; and every query is as-of a time slice.
Evidence is a graph.
Statement (SEG)
2.5 Substrate Invariant (SEG) — Graph-theoretic underpinnings
Chapter 2 — System Axioms
Bottom line: SDF-CVF turns “keeping everything in sync” from an aspiration into a merge contract. If it can’t pass together, it doesn’t ship.
SEG updated with claim→evidence lineage for the change.
Rollback plan materialized.
and all gates pass (or two-key override).
Parity score ≥ 
Single atomic delta-quartet with pinned witnesses.
10) Contract (what merges must promise)
Over-automation (fixes that mask intent): HITL thresholding by risk class; diff semantics highlight behavior changes beyond tolerance.
Trace rot (replay breaks under env drift): environment pins & simulators; if external API changed, attach contradiction edge in SEG and route to policy.
Tag drift (labels stale): nightly parity scan opens DEPP tasks; auto-patch or Jira ticket.
; auto-synthesize tests.
& 
Spec-only edits (no tests/code): blocked by 
9) Failure modes & mitigations
One-click rollback (to last green snapshot) with witness link.
Risk banner (class, thresholds, two-key status).
Obligation list with “Auto-fix” buttons (preview diff + tests).
Parity bar on PRs with breakdown (C↔D, C↔F, C↔V).
8) Operator UX (minimum viable)
ratio).
Replay fidelity for traces (VIF 
Quarantine rate and rollback frequency.
Change Failure Rate (CFR) and MTTR (DORA).
Obligation closure time (mean time from deficit → auto-fix or HITL).
(p50/p90 by service & risk class).
Parity score 
7) Metrics & SLOs (SDF-CVF)
fails → spec patch synthesized; parity restored.
If doc unchanged → 
Obligations: doc update (error table), contract tests, VIF witness for change note.
: handler signatures.
B) Code refactor alters API error model.
Gates: tests & tags & trace. Auto-fix proposes TTL patch + test; reviewer approves; merge.
Obligations: add retention test, update data job TTL, rotate tags (#PII-retention:30d), regenerate SEG lineage for policy-driven changes.
: policy text.
A) Spec tightened (PII retention 90→30 days).
6) Worked micro-examples
On persistent failure, branch enters quarantine with a frozen witness bundle and a rollback plan (last good snapshot + revert diffs); merge unblocks via two-key HITL only.
Quarantine & rollback.
Trace parity: draft VIF records; attempt replay; annotate deltas.
Tag parity: static/data-flow analysis inserts sanitizers/DP ops; updates policy labels.
Spec→Test parity: synthesize tests from normative language; bind to code via symbol grounding.
Auto-fix strategies.
Re-evaluate → pass gates or quarantine.
: generate obligation graph → feed APOE auto-fix chains (e.g., test synthesis, doc patch, SEG witness scaffolding).
If 
& component distances; emit diffs (missing tests/specs/tags/traces).
Compute 
on the PR snapshot.
Build projections 
Pre-merge parity checker.
5) Algorithms (practical)
 distances add over disjoint supports; normalization preserves bounds.
Sketch:
if each individually meets it.
, then parity scores combine as a weighted average and cannot violate 
touch disjoint slices of 
If 
Compositionality.
 each failed gate yields a finite set of obligations (missing tests, tags, traces) that APOE can synthesize; obligations strictly reduce a deficit measure.
Sketch:
.
monotonically until 
and auto-fixes that increases 
reachable by finite edits, there exists a finite sequence of atomic commits 
For any desired spec-conforming behavior 
Liveness (no deadlock of safe change).
 gates enforce preconditions; witnesses pin artifacts; replay is idempotent under pins (cf. VIF). Therefore deviations are detectable and blocked.
Sketch:
→ quarantine (no silent violation).
; any downstream divergence re-surfacing under replay raises 
yields a state where projections remain within 
passes gates at review time on snapshots referenced by its VIF, then applying 
, and 
If all gates hold at 
Soundness (gate preservation).
4) Proof sketches (intuition)
.
is implied by 
(e.g., 0.95 for critical paths, 0.85 for experimental branches). Slack 
. Policy: require 
with 
:
Define a parity score 
3) Parity scoring & slack
If any gate fails → Auto-fix (localized synthesis/refactor) or Quarantine (branch isolates with rationale & witness), never a silent merge.
Failure policy.
— risk score ≤ threshold or has two-key HITL approval; redactions applied.
— VIF/SEG updated: each outward-facing claim has lineage; replay on pinned snapshots matches; export pack builds.
— labels/policies/types (e.g., PII, license, SLAs) are consistent with code/data flows: no unguarded sinks, correct encoders/DP transforms.
.
— updated requirements/specs align with behavior: 
— all tests (unit, property, contract) pass; new behavior has tests; coverage thresholds met.
2) Gate catalog (binding)
.
and parity is preserved (commutativity). If overlaps exist, a merge gate checks conflicts in 
that touch disjoint semantic slices, 
For independent commits 
Composition.
for high-risk classes.
is a domain-specific semantic distance (e.g., spec clause coverage vs. test behavior; policy label coverage vs. PII filter paths). 
where 
:
After apply, projections agree within a bounded slack 
Parity constraint.
(claims/evidence implied by traces)
(policy labels, data contracts)
(requirements/spec clauses)
(behavior extracted from code/tests)
(the spec/behavior model):
Define projection functors to a common semantic space 
Functorial parity.
with each component a typed edit script on its domain (AST diff, doc diff, tag set diff, SEG subgraph diff).
is a delta-quartet
A commit 
Unit of change.
1) Compositional model of change
preserves referential, behavioral, and evidential consistency.
After apply, 
is valid iff there exists a single atomic commit that transforms each projection coherently, and all parity gates pass:
A change 
=VIF/SEG traces.
=facts/tags/metadata, 
=documentation/specs, 
=code, 
where 
be the quartet
Let a system state at time 
Code, docs, tags, and traces evolve as one.
Formal statement (SDF-CVF)
2.4 Atomic Evolution (SDF-CVF) — Compositionality & parity
Chapter 2 — System Axioms
Cultural norm: if you can’t show the witness, you don’t ship.
Engineering leverage: replayable bugs, measurable calibration, searchable contradictions.
Regulatory posture: instant export of machine-readable lineage.
Operational trust that’s computed, not asserted.
What VIF gives the system
, APOE may proceed; otherwise it would abstain or escalate to HITL.
Since 
.
) → 
Aggregate (weights e.g., 
.
. ECE=0.05 → 
Calibration 
. Signed PDF + checksum in registry → 0.95.
Provenance 
.
→ 
. Last updated 30 days, 
Freshness 
. Deterministic match → 1.00.
Replay 
. No contradictions in policy history slice → 1.00.
Consistency 
.
. nDCG@5=0.92; coverage 0.88 → 
Support 
Claim. “Section §4.2 of Policy-X requires redacting SSNs before storage.”
10) Worked micro-example
Provenance forgery → verify signatures; mismatches quarantine the plan.
.
Calibration drift (rising ECE) → auto-schedule recalibration jobs; tighten 
) → warn, route to retriever refresh.
Stale sources (low 
, block.
Orphan claims (no sources) → 
9) Failure modes & mitigations
Copy as JSON-LD provides the machine-readable witness for export.
“Recheck now” button triggers replay/calibration with current policies (read-only budgets).
“Show lineage” opens the SEG slice: sources with highlighted spans; tool and prompt cards; replays.
and breakdown hovercard (S/C/R/F/P/L).
Confidence band (green/amber/red) with 
8) UI/UX (operator & end-user)
for new claim c: search SEG for contradicts(c, t_asof) → if any active → lower C; require verifier
Contradiction scan (online):
gather_subgraph → compute S,C,F,P,L,R → aggregate T → compare to κ_T → {emit|abstain}
Trust evaluation (per artifact):
collect_inputs → hash_prompts → pin_model/tool → run → hash_outputs → compute_u → run_gates → emit_witness → attach_to_SEG
Witness-assembly (per step):
7) Algorithms (obligation-level)
cap the score.
and 
; 
Anti-inflation. Appending unsupported citations or non-verifiable tool calls cannot raise 
bounded by the weakest mandatory component.
(rumor). Partial lineage yields 
Conservativeness. In absence of lineage, set 
Replay Lemma. If tools, models, seeds, and inputs are content-addressed and pinned, then replay is idempotent modulo external nondeterminism; divergence surfaces as a witnessed diff.
6) Properties (sketches)
W-4 Redaction. VIF pipelines apply PII/license redaction before logging sources; SEG stores redacted derivatives + reversible escrow hashes.
before merge; otherwise quarantine.
W-3 Replayability. High-risk classes require 
, display risk banners and route to verifier or HITL.
or 
W-2 Confidence hygiene. If 
W-1 Machine-readable lineage. No artifact may be emitted without at least one witness that forms a connected path to the claims it asserts.
5) Gates & policies (binding)
}
  "seg_links": [{"edge":"derives","from":"retrieval:77","to":"claim:policy-summary"}]
  "signatures": [{"by":"system","alg":"ed25519","sig":"…"}],
  "gates": [{"name":"source_overlap>=0.85","pass":true},{"name":"pii_policy","pass":true}],
  "uncertainty": {"entropy":0.17, "agreement":0.08, "ece":0.04},
  "outputs": [{"artifact":"claim:policy-summary","mime":"text/markdown","digest":"b3:…"}],
  "budgets": {"tokens":{"used":2389,"cap":4000},"time_ms":{"used":820,"cap":3000},"cost_cents":1.2},
  "inputs": [{"seg_id":"src:doc:123#p4","digest":"b3:…"}],
  "tools": [{"id":"web.search","version":"2.4","args_hash":"b3:…"}],
  "prompt_template_hash": "sha256:…",
  "model": {"name":"gpt-X","weights_hash":"sha256:…"},
  "actor": {"role":"verifier","plan_step":"verify-03"},
  "time": "2025-10-17T21:04:12Z",
  "witness_id": "b3:6a1f…",
{
4) VIF schema (concrete, minimal JSON)
Store reliability diagrams and ECE in witness.
: bin predictions by stated confidence vs. empirical correctness on gold or replay checks.
Calibration 
: ensemble or temperature-sweep disagreement.
Agreement-based 
: normalized token-level entropy / variance.
Entropy-based 
3.3 Calibration protocol
and diffs.
Record replay_witness with 
Canonicalize outputs → compute digests → compare.
with the same budgets.
Re-execute the plan slice producing 
Freeze referenced snapshot ids (memory, tools, prompts, seeds).
3.2 Replay protocol (boundary contract)
validity; queries accept an as-of time.
Each edge carries 
Edges: supports, derives, paraphrases, contradicts, uses-tool, tested-by.
Nodes: source, snippet, retrieval, tool-call, transform, claim, decision.
3.1 Lineage in the SEG (time-sliced)
3) Auditability: what we log, how we verify
.
and so 
; adding contradictory evidence decreases 
 evidence cannot decrease 
consistent
Monotonicity. Adding 
) fails.
or any mandatory component (e.g., 
-abstain if 
Abstention rule. Emit 
.
L (Calibration): inverse expected calibration error
normalized score by policy (e.g., peer-reviewed > blog).
P (Provenance quality): source/auth chain, signatures, licenses
(per source, aggregated).
F (Freshness): temporal validity
or proportion matched.
if all replays match; else 
R (Replayability): digest match under replay
.
C (Consistency): absence of contradictions in SEG slice
over cited spans vs. claims.
S (Support): coverage and strength of citations
 truth; it is operational confidence grounded in evidence.
not
that the system displays and gates upon. It is 
We compute a trust score 
2) Trust calculus
Every step in a plan emits one witness; the artifact’s top-level witness references all interior witnesses via the SEG.
signatures (optional: step signer, system signer)
gates (test results, policy checks, redactions)
UQ vector 
outputs (artifact digests, MIME, size)
budgets (tokens, time, cost) used vs. allowed
inputs (SEG node ids / snapshot ids + content digests)
tools (tool ids + versions + args digests)
model (name, weights_hash) • prompt_template_hash
time (wall clock, monotonic seq) • actor (role, step id)
id (content address, e.g., BLAKE3 of canonicalized witness JSON)
Witness tuple (minimal):
 a narrative explanation; it is the evidence bundle that makes explanations auditable.
not
It is 
A witness is a machine-readable, cryptographically addressable record that binds who/what/with-what created which artifact, from which inputs, under which budgets, and with what confidence.
1) What a Witness is (and isn’t)
is replayable on the referenced snapshot(s); replay either reproduces digest-equivalent artifacts or yields a flagged divergence.
, and
carries a calibrated uncertainty vector 
encodes a verifiable lineage from sources → retrievals → transforms → outputs in the Shared Evidence Graph (SEG),
such that:
, there must exist a witness 
(text, code, decision) produced by APOE on memory state 
For any artifact 
A claim that cannot show its lineage is a rumor.
Formal statement (Witness Invariant, VIF)
2.3 Witness Invariant (VIF) — Trust calculus & auditability
Chapter 2 — System Axioms
Compile the plan. Execute the plan. Show the witness. Or abstain.
Governance — every boundary emits VIF metadata into SEG for regulators and SREs.
Velocity — parallel sections run safely; retries are idempotent.
 outcome.
first-class
make abstention a 
Safety — gates and 
Modularity — compositional plans enable reuse and safe refactors.
Reliability — compiled chains are auditable, replayable, and resource-bounded.
What this buys the whole system
Witnesses for each step anchor model/prompt hashes and inputs/outputs. The plan succeeds; replay reproduces digests. If Verifier failed, APOE would abstain or route to HITL.
→ emits redaction function; gate runs on synthetic PII corpus; passes parity tests.
Builder (codegen)
→ checks summary against sources (overlap ≥ 0.85), PII taxonomy matched.
Verifier (tests + policy gate)
.
, passes 
→ artifact: concise policy summary; UQ 
Reasoner (budget: 8k tokens)
(low uncertainty).
→ artifacts: top-k sections + SEG citations; 
Retriever (budget: 3 tool calls, 4k tokens)
Goal: “Summarize policy doc, extract PII rules, and propose safe redaction filter.”
Micro-example (4-node plan)
.
O-9 Metrics everywhere — per-node budgets, latency, UQ, RS; per-plan 
O-8 Version pinning — models, weights, prompts, tools are versioned; drift → error.
O-7 Parallel joins are safe — only join on content-addressed artifacts; race-free merges.
O-6 Side-effect isolation — tool calls run in sandboxes; writes are snapshot-first.
or RS falls below threshold, stop/route to HITL.
crosses 
O-5 Abstention first — if 
O-4 Replay semantics — traces must re-run on frozen snapshots.
O-3 Boundary gates — per-step tests, safety, provenance, and UQ must pass.
O-2 Typed roles — steps declare role; policies attach by role.
O-1 Budgets explicit — every step carries token/time/tool/cost limits.
Design constraints (bind to APOE)
Inputs (digests) • Tool spec (model id, weights hash, prompt template id, tool args) • Budgets consumed • Artifacts (digests) • UQ vector • Gate outcomes • SEG pointer
Boundary contract (every step)
Retry policy: bounded exponential backoff; idempotent re-runs; seed policy pinned.
Scheduler: (a) topological order, (b) respect budget/resource locks, (c) width-bounded parallelism.
Gates: attach tests, safety/PII scans, UQ thresholds, provenance minima.
Budgets: assign token/time/tool/cost caps per node.
.
planner, retriever, reasoner, verifier, builder, critic, operator, witness
Decompose into roles: 
INTENT_PARSE → DECOMPOSE (roles) → ALLOCATE (budgets) → INSERT (gates) → ACL_EMIT → SCHEDULE (topo + budgets) → EXECUTE (parallel safe) → COLLECT (witnesses) → REPAIR/ABSTAIN → FINALIZE (snapshot links)
APOE compilation pipeline
Algorithms (obligation-level)
Sketch. The critic rejects or downgrades low-confidence outputs; repair improves or abstains. By selection, accepted set’s mean risk decreases; calibration verified on held-out traces.
is non-increasing and expected RS is non-decreasing over accepted outputs.
. Then expected risk 
be a refinement that adds a critic step and a repair step guarded by 
Claim. Let 
Thm 6 — Refinement monotonicity (Evaluator-Optimizer)
Sketch. Witnesses pin all degrees of freedom (tool versions, seeds, prompts, inputs). Re-execution reproduces digests; any drift indicates external mutation and is surfaced.
and the snapshot id(s) referenced by its witnesses, replaying the plan yields artifacts that are digest-equivalent or a flagged divergence.
Claim. Given 
Thm 5 — Replayability
or produces abstention; thus no infinite descent.
as (remaining nodes, remaining budgets). Each reduction strictly decreases 
Sketch. Define a well-founded measure 
safe bands or budgets exhaust.
, and no cyclic deps, execution terminates in success or abstains at some boundary where 
Claim. Under fair scheduling, finite 
Thm 4 — Safe liveness (termination or abstention)
. By DAG induction and monotone resource flow, local postconditions compose to the global postcondition. Violations cannot leak because boundary gates block propagation.
as local Hoare triples 
Sketch. Gates encode obligations from 
(tests, safety, provenance minima).
, then the whole plan satisfies the global policy 
satisfies its preconditions and passes its gate set 
Claim. If every step 
Thm 3 — Gate soundness (safety)
Sketch. Interfaces are product types of inputs/outputs. Composition is node/edge union with interface alignment and topological merge; tensor is disjoint union. Because gates are attached to node boundaries, their satisfaction composes (induction on topo order). This establishes modularity and permits verified refactors.
with identities and associativity holding, so refactoring does not change denotation.
: parallel composition;
tensor 
: interface-typed gluing;
composition 
morphisms: plans;
objects: typed interfaces;
Claim. ACL plans form a strict symmetric monoidal category:
Thm 2 — Compositionality (plan algebra)
; within-band variation is allowed but artifacts’ canonical forms (digests) remain equal or are rejected by gates.
and node id → repeated runs hash-equivalent. Tolerance bands (e.g., beam sampling) are logged in 
Sketch. Each step consumes content-addressed inputs and pinned tool versions. Randomness is derived from 
is unique up to declared stochastic tolerance bands; retries are idempotent.
, the witnessed trace 
, ACL, and seed 
, 
, 
Claim. With fixed 
Thm 1 — Determinism under fixed context
Theorems (with proof sketches)
, the runtime executes rollback of side-effects and emits an abstain event.
crosses abstention 
fails or 
, gate outcomes). If any gate in 
(model id, weights hash, prompt id, inputs digests, outputs digests, UQ vector 
only through snapshotted writes, and appends a witness record 
updates budgets and 
where 
(all preds satisfied), producing:
A reduction executes any ready node 
.
with scheduler state 
We write configurations 
Operational semantics (small-step)
.
(tokens, time, calls, cost), and seed 
(version-pinned), budget vector 
(from §2.1), tool registry 
where memory 
Execution environment
(tests, policy, provenance), and effect type (pure, tool, external).
with pre/postconditions, gate set 
gives each node a step schema:
: acyclic edges (data/control deps).
: steps; 
where:
A plan 
Plan as a typed DAG
Model (objects and semantics)
with rollback).
(iv) safe liveness (terminates in success or abstains at 
(iii) boundary gates (every step emits provenance + UQ), and
(ii) compositionality (plans compose without changing meaning),
(i) determinism under fixed context (up to declared stochastic bands),
with:
yields a witnessed trace 
on 
that is a finite, typed, budgeted DAG in the AIMOS Chain Language (ACL) such that execution of 
, there exists a plan 
and memory state 
For any goal 
Reasoning must be compiled, not improvised.
Formal statement (Orchestration Invariant, APOE)
2.2 Orchestration Invariant (APOE) — Formal statement & proofs
Chapter 2 — System Axioms
.
abstained
, or gracefully 
replayed
 and 
proven
For users: answers that can be 
For SDF-CVF: parity checks join code/docs/tags/traces at commit time.
For VIF/SEG: every memory fact has a witness and replay.
 memory, not drifting chat; boundary gates consume calibrated RS.
stable
For APOE: plans operate over 
What this buys the whole system
, green band; lineage expands to show witnesses.
Read: query auth token → HHNI retrieves section→sentences; local re-rank surfaces the diff atom; dumbbell packs front (requirements) + tail (tests); UI shows 
Graph: Derivation(LLMRun) witnessed by {model,weights_hash,prompt_id,tools}; Claim “JWT added without PII leak” supported by test result + static scan.
Snapshot: manifest digest sha256:… signed; lossy operator: middle-summary (ε=0.03).
Index: sentence/word embeddings; tags #auth, #jwt; dependency hash binds diff↔test.
Atomize: 7 atoms (2 text spans, 3 code spans, 2 events).
Context: user prompt + code diff + log excerpt.
Worked micro-example (end-to-end)
C-6 Witness everywhere. Each transition emits a VIF payload into SEG.
.
C-5 Loss budgets. Each lossy operator declares a bound; rehydration reports 
C-4 Calibrated RS. Score calibration fitted, tracked, and versioned.
C-3 Two-stage read. Mandatory hierarchical search + dumbbell packing.
C-2 Snapshot-first. No state leaks without snapshot_id.
C-1 Single writer. One transactional CreateMemory endpoint; conflicts resolved before snapshot.
Design constraints (bound to CMC)
COARSE(HHNI nodes) → RE-RANK(local atoms) → DUMBBELL(pack) → UQ/ABSTAIN(κ) → RENDER + LINEAGE
Read pipeline (two-stage):
INGEST → ATOMIZE → INDEX(HHNI) → SCORE(QS,IDS,DD) → SNAPSHOT(sign,digest) → GRAPH(upsert witnesses)
Write pipeline (deterministic):
Algorithms (obligation-level)
, the system abstains or routes to HITL.
or uncertainty 
 returned fact has a replay recipe; if 
any
, 
Because every read/write is (i) snapshot-first, (ii) time-sliced, and (iii) witnessed into 
Corollary — Safety by construction
.
and 
. UI and gates consume 
giving target type-I error 
, one chooses 
Sketch. Apply isotonic or Platt calibration on held-out gold sets to map raw scores to empirical probabilities. By Neyman-Pearson style thresholding on 
.
yields a bound on false-positive retrievals 
with 
is a well-calibrated probability; choosing 
such that 
Claim. There exists a monotone calibration 
Theorem 6 — RS calibration & selective abstention
. This yields the “dumbbell” layout as the optimal packing strategy; middle spans contribute via summaries to preserve latent links.
, selecting top-mass spans near the ends maximizes 
with maxima near boundaries. For a budget 
Sketch. Model position-weight as 
Claim. For attention kernels with “lost-in-the-middle” bias (concave in the center), placing critical cues at the front and tail and summarizing the middle minimizes expected recall loss under a fixed token budget.
Theorem 5 — Dumbbell compression minimizes position-bias loss
is empirically calibrated and tracked in RS-lift dashboards.
Sketch. HHNI constructs a cover of the atom space with hierarchical representatives (sections/sentences). Under standard assumptions (Lipschitz similarity in embedding space; bounded drift), a coarse ANN retrieval followed by local refinement approximates the oracle ranking. The deviation 
.
of an oracle full-scan search of atoms, for calibrated 
 set whose expected F-measure is within 
with multi-granular embeddings, tags, and dependency hashes, the two-stage read (coarse→fine) returns a top-
Claim. Given the HHNI index 
Theorem 4 — Query sufficiency of HHNI for top-k
. Thus, the visible graph can shrink in a slice, but the ledger grows monotonically.
Sketch. Writes are append-only; corrections add contradicts/supersedes edges. Time-slice queries mask edges outside 
modulo explicit tombstones/deprecations; history is never destroyed, only superseded.
is a subgraph of 
, 
Claim. For 
Theorem 3 — Monotonicity under event sourcing
(witness payload).
 truncation, vector quantization). Loss budgets are logged in 
is the supremum of declared lossy operators’ bounds (e.g., top-
 (possibly lossy). Rehydration is exact for atoms and structural indices; for compressed spans we restore summaries within quantizer error. 
summaries/embeddings
Sketch. Snapshots pack raw atoms (lossless) and 
is a declared budget from (a) lossy compressions and (b) quantized embeddings.
, where 
with distortion 
such that 
Claim. There exists 
Theorem 2 — Reversibility with bounded distortion
 equal snapshot digest. Idempotence follows since re-ingest compares digests and short-circuits.
⇒
 equal manifests 
⇒
Sketch. Content addressing (SHA-256 over canonicalized payloads) + frozen tool metadata removes nondeterminism from hashing. The single-writer gate serializes concurrent writes; equal inputs 
digest.
is idempotent and yields the same 
are deterministic; re-applying to 
Claim. Under fixed toolchain (model ids, weights hashes, prompt templates, seeds) and a single-writer gate, 
Theorem 1 — Determinism & Idempotence
Theorems (with proof sketches)
Time-sliced lineage. Every transformation emits a Witness node; queries accept asOf.
Two-stage reads. Hierarchical read (coarse HHNI → fine atoms) with dumbbell compression (front-load + tail-load essentials; middle summarized) for long contexts.
id.
Snapshot-first visibility. No user-visible state without an 
digests.
Single-writer determinism. All writes pass a transactional CreateMemory gate with fixed seeds and tool versions → identical inputs yield identical 
Required properties (as obligations)
.
(isotonic/Platt) so that 
with post-hoc calibration 
(quality, indexing depth, dependency delta). Define
Let 
Retrieval score (normalized)
: time-sliced evidence edges among {claim, source, derivation, decision, witness}.
Graph 
: immutable, content-addressed pack (manifest + blocks), signed and versioned.
Snapshot 
: HHNI indices (system→section→paragraph→sentence→word→sub-word), tags, embeddings, TPV (Tag Priority Vectors), dependency hashes.
Indexing 
 (text span, code span, event, tool-call, file blob, embedding), each content-addressed.
atoms
: a typed multiset of 
Atomization 
contains)
Construction (what 
.
are witnessed and time-sliced in the Shared Evidence Graph 
 retrieval under the system’s scoring functional; (v) witnessability: all transitions 
are sufficient statistics for top-
+ 
only by explicit deprecation/tombstones; (iv) query sufficiency: 
for 
with bounded loss; (iii) monotonicity: 
from 
reconstructs 
under fixed seeds/tools; (ii) reversibility: a left-inverse 
is a deterministic functional of 
such that (i) determinism: 
, there exists a canonical memory state
Concretely, for any time-indexed context stream 
 memory.
reversible
An intelligent system must convert ephemeral context into structured, queryable, and 
Formal statement (Memory Invariant, CMC)
2.1 Memory Invariant (CMC) — Formal statement & proofs
Chapter 2 — System Axioms
Bottom line: Documents are narratives. Evidence graphs are guarantees.
SDF-CVF uses SEG to verify parity (doc/spec/test/code) before accepting evolution.
VIF is the per-artifact envelope; SEG is the system-level tapestry.
APOE/ACL ensures every step emits a witnessed derivation.
CMC/HHNI supplies atoms and indices; SEG links them into explanations.
L. How SEG anchors the rest
Time-slice: As of 2025-10-17T12:34Z, all edges valid; at 2025-10-18 a new Claim with contradicts appears when latency regresses—UI shows yellow band and blocks auto-rollout.
Edges: supports(Claim←Source/Derivation), witnessedBy(Claim←Witness), derivesFrom(Decision←Claim).
Decision: “Approve release v1.8,” two-key approvers, rationale, outcome=APPROVED.
Witness: model+weights hash + prompt template for the summarizer used to generate the release note.
Derivation(LoadTest run@sha, tool=k6, params), Derivation(DP scanner report@sha).
Source(OpenAPI spec@sha), Source(latency dashboard snapshot@sha), Source(DP policy doc@sha).
Supports:
Claim: “Release v1.8 complies with PII policy and meets p95 latency < 120 ms.”
K. Micro-example (end-to-end)
S-5 Single writer: CreateEvidence is transactional; partial writes are rejected.
S-4 Content addressing: all artifacts referenced by digest; mutable URLs are advisory only.
S-3 Export-ready: one-click packs with replay and UQ are mandatory for “High-Risk” scopes.
S-2 Contradictions as first-class: we add contradicts edges; we do not delete history.
S-1 Time-slicing API: every read accepts asOf and returns only active edges.
J. Operational commitments (design constraints)
Risk lenses: toggle to highlight un-witnessed nodes, low-confidence edges, or policy-tagged sources (PII, license).
Explain button: expands a minimal proof (fewest edges) for the selected claim.
Time scrubber: slide along the timeline to watch edges appear/disappear.
Subway-map lineage: Decision at right; sources at left; derivations in the middle; chips for Witness and UQ bands.
I. UI/UX for comprehension
Packs are immutable; re-issuing creates a new pack with derivesFrom the prior.
Redaction map: what was hidden, under which legal basis.
UQ & calibration report: κ/ECE bands, failure cases.
Replay: deterministic recipe (container images, model ids, prompts, seeds).
Artifacts: content-addressed pointers + signed digests (optionally inlined small files).
Graph slice: JSON-LD nodes/edges reachable within constraints.
Manifest: top-level Decision/Claim ids, time slice, policy scope.
A SEG Export Pack is a zipped, signed bundle with:
H. Export packs (regulatory, read-only)
Abstention hooks: if lineage depth < τ or calibration error > κ, render claims with yellow bands and route to HITL.
Least disclosure: privacy-sensitive attributes are redacted-at-ingest with reversible redaction tokens stored under purpose-bound keys.
Non-repudiation: nodes/edges are signed; any replay verifies content digests and signatures.
Completeness (w.r.t plan): APOE plan execution must emit a Witness per step; empty or partial witnesses fail gates.
G. Quality & safety properties
WHERE depth <= 3 AND include = {Witness, Derivation}
SELECT lineage FROM Claim('urn:…') AS OF '2025-10-17'
Interfaces: SPARQL/Gremlin-style, plus a high-level “LineageQL”:
Replay recipe: from a Decision, collect the frontier of Derivations + Witnesses; emit a frozen replay manifest.
with a contradicts edge active in the slice; rank by affected Decisions.
Contradiction detection: find pairs 
.
, enumerate Decisions reachable via
Impact (forward): given a Source 
within the time slice. Return the minimal hitting set of sources that cover the claim’s predicates.
, find all acyclic paths
Lineage (backward): given a Claim 
Canonical queries:
F. Read path (how we answer “why?”)
All writes funnel through CreateEvidence (the “single writer” analog for SEG).
Materialize index views (by time, by project, by policy tag).
Sign & time-bound nodes/edges; publish to SEG log.
Assert claims with supports/derivesFrom/witnessedBy edges.
Mint nodes: Source for the artifact; Derivation for the process that created it; Witness for VIF (model, weights hash, prompt id, tool list, signature).
Produce artifact → hash → store in object store (content-addressed).
E. Write path (how facts enter)
Attachments. Large artifacts (docs, models, logs) remain in object stores; SEG stores content digests + URIs.
Identifiers. Use urn:seg:<kind>:sha256:<digest> over canonicalized payloads.
}
  "validFrom": "2025-10-17T12:00:00Z"
  "witnessedBy": "urn:seg:witness:sha256:ef…",
  "supports": ["urn:seg:source:sha256:ab…", "urn:seg:deriv:sha256:cd…"],
  "text": "Export packs include VIF and UQ bands.",
  "type": "Claim",
  "id": "urn:seg:claim:sha256:7a…",
  },
    "validTo": {"@id":"https://aimos.ai/seg#validTo","@type":"xsd:dateTime"}
    "validFrom": {"@id":"https://aimos.ai/seg#validFrom","@type":"xsd:dateTime"},
    "witnessedBy": {"@id":"https://aimos.ai/seg#witnessedBy","@type":"@id"},
    "contradicts": {"@id":"https://aimos.ai/seg#contradicts","@type":"@id"},
    "derivesFrom": {"@id":"https://aimos.ai/seg#derivesFrom","@type":"@id"},
    "supports": {"@id":"https://aimos.ai/seg#supports","@type":"@id"},
    "Witness": "https://aimos.ai/seg#Witness",
    "Decision": "https://aimos.ai/seg#Decision",
    "Derivation": "https://aimos.ai/seg#Derivation",
    "Source": "https://aimos.ai/seg#Source",
    "Claim": "https://aimos.ai/seg#Claim",
    "type": "@type",
    "id": "@id",
  "@context": {
{
D. Minimal JSON-LD schema (sketch)
Tombstones: deprecations are explicit nodes/edges, not deletes—preserving audit trails.
excludes the slice.
Time-slicing: every query is evaluated “as of” a timestamp; the graph kernel masks edges whose 
Event-sourced: new facts append; we never silently mutate. Corrections add contradicts or supersedes edges.
C. Temporal model & reversibility
and content addresses (hashes) for immutability.
All nodes/edges carry validity intervals 
Edges (typed): supports, derivesFrom, contradicts, annotates, usesTool, witnessedBy
Witness: {id, model_id, weights_hash, prompt_id, tool_invocations[], timestamp, signature}
Decision: {id, policy, approvers, outcome, rationale}
Derivation: {id, kind: ("LLMRun"|"Build"|"Test"|"Query"), inputs[], outputs[], tool, params, udf_hash}
Source: {id, uri|digest, modality, snapshot_id}
Claim: {id, text, scope, metrics, uncertainty}
B. Core vocabulary (minimal types)
Is not: a general document store, wiki, or vector DB. Those are attached as sources; the SEG carries relationships and witness.
Decisions (approvals, releases, merges).
Derivations (transformations: prompts, tools, compilers, tests),
Sources (documents, datasets, code, runs),
Claims (propositions the system asserts),
Is: a temporal, typed, content-addressed knowledge graph that binds the four pillars:
A. What the SEG is (and isn’t)
Every claim, source, derivation, tool-call, and decision is a typed node with signed, time-bounded edges. We query lineage, not folders.
Evidence is a graph.
Principle (Substrate Invariant, SEG)
Documents, tickets, chats, PRs, dashboards, and code reviews live in silos. They describe reality but rarely prove it. Over time, links break, screenshots rot, and “source of truth” collapses into trust-by-habit. Reasoning atop such strata is brittle and unauditable.
Problem
1.6 From Documents to Evidence Graphs (SEG)
Bottom line: SDF-CVF converts “did we change the code?” into “did we evolve the system?”—and proves the answer, every time.
Security & Compliance: tags drive guardrails and retention; export packs satisfy audit pull-requests.
VIF/SEG: each bundle is a decision node linked to its claims, sources, and tools—time-sliced and exportable.
APOE/ACL: plan steps include gate{…} constructs; failure auto-routes to remediation chains.
CMC/HHNI: ABM is the write gateway; accepted bundles update atoms/indices and tombstone deprecated nodes.
K. Interfaces to the Rest
, all gates PASS → ACCEPT, snapshot minted, Merkle root updated.
Result: 
Traces: new contract tests; VIF replay for sample pack; SEG node types verified.
Tags: “exportable:true”, “contains:provenance”, “PII:none”.
Docs: API section + example pack schema.
Code: new endpoint + signer.
 add “Export evidence pack” API.
Change:
J. Micro-Example
Spec/code lag (time from code change → spec/runbook change) ≈ 0 for accepted bundles.
Lineage coverage 100% (all bundles witnessed).
MTTR for quarantines and rollbacks (target by tier).
Change-failure rate (CFR) < 10% (DORA).
per merge, p95 ≥ θ.
Parity median 
I. KPIs (Atomic Evolution)
κ-gate g_risk → ABSTAIN/HITL; recalibrate UQ
Confident but miscalibrated changes
Risk blindness
Gate g_trace blocks; auto-witness on retry
Artifact has no VIF
Broken lineage
Trace parity fails; scaffold test stubs; block until green
Spec updated, tests unchanged
Ghost tests
Gate g_tags requires instrumented checks & runbook diffs
Tags updated, no enforcement
Policy holes
Gate g_spec blocks; auto-generate spec diff stubs
Code changed, spec didn’t
Silent drift
Mitigation
Symptom
Mode
H. Failure Modes & Mitigations
One-click replay (frozen snapshot) and SEG lineage overlay.
Auto-fix suggestions (apply-patch buttons) + HITL two-key banner if risk ≥ τ.
Gate bar (5 lights) with drill-downs; any ABSTAIN is clickable to root cause.
Parity chip (“P 0.92 • PASS”) expandable to sub-parities and missing links.
Quartet diff view (4 synchronized panes) with cross-highlighting.
G. UI/UX (reviewer ergonomics)
Ensure every changed public surface has updated contracts (OpenAPI/ABI), tests, and telemetry selectors; VIF covers all public claims.
Trace parity:
Validate presence of enforcement & redaction; diff runbooks for incident steps.
For each changed policy/tag, find binding sites (schemas, routes, collectors).
Tags↔Code parity:
.
Require: each changed symbol resolves to ≥1 updated anchor; each changed anchor resolves to ≥1 changed symbol. Compute F1 as 
Map anchors to code symbols (types/functions) via static analysis & comments.
Extract spec anchors (requirements IDs, invariants).
Spec↔Code parity (AST-aware):
F. Algorithms (sketches)
}
  "signatures": {"bundle_sig":"ed25519:…"}
  "witness_id": "w_01HV…",
  "snapshot_id": "snap_01HV…",
  "decision": "ACCEPT",
  },
    "risk":"PASS"
    "trace":"PASS",
    "tags":"PASS",
    "spec":"PASS",
    "tests":"PASS",
  "gates": {
  },
    "P": 0.92, "theta": 0.9
    "trace_code": 0.95,
    "tags_code": 0.88,
    "spec_code": 0.93,
  "parity": {
  },
    "traces": {"tests":[...], "vif_ids":[...], "seg_edges":[...]}
    "tags": {"adds":[...], "removes":[...], "migrations":[...]},
    "docs": {"anchors":[...], "spec_map":[...]},
    "code": {"files":[...], "ast_hash":"sha256-…"},
  "diffs": {
  "parent_snapshot": "snap_01HU…",
  "bundle_id": "abm_01HV…",
{
Atomic-Bundle Manifest (ABM)
E. Data Structures (minimal)
and attach contradiction edges in SEG (we amend, never silently overwrite).
If remediation exceeds SLA or raises risk, rollback to 
Open a remediation branch with suggested diffs and a check-list.
Generate auto-fix plan (missing doc sections, tag migrations, test stubs).
Quarantine loop (asynchronous):
Decide: ACCEPT / QUARANTINE / ROLLBACK; emit snapshot & witness.
, UQ-risk, and budget deltas.
Score: compute parity 
Prove: run tests; build VIF witnesses; update SEG working set.
Link: validate cross-refs (spec anchors, code symbols, policy targets, test names).
Diff: compute typed diffs and impact graph (which files/paths must change).
Normalize: parse/AST docs & code; canonicalize tags; extract trace selectors.
Pipeline steps (synchronous):
D. Atomic Bundle Pipeline (δ → decision)
Non-bypassable: If a gate can’t run, it returns ABSTAIN and blocks the merge.
 HITL two-key
⇒
κ decision from UQ; risk score ≥ τ 
Risk & HITL
g_risk
VIF completeness; SEG lineage; telemetry contracts
Evidence & observability
g_trace
PII/PD/License tags; breaking policy deltas escalate
Policy/labels correctness
g_tags
Spec-to-code trace links; unresolved TODOs = FAIL
Doc/spec ↔ code parity
g_spec
Unit/integration/e2e; golden IO; schema/ABI stability
Functional/contract correctness
g_tests
Minimal signals
What it checks
Gate
C. Gate Catalog (binding, extendable)
Reproducibility. Every accepted change is anchored by a snapshot id and a witness envelope (VIF) that ties diffs to models, prompts, tools, and tests used.
Else QUARANTINE with an auto-fix plan or ROLLBACK to last green snapshot.
Acceptance rule.
is a normalized semantic-diff alignment (1.0 = perfectly synchronized).
where each 
aggregates sub-parities:
A parity score 
Each commit produces gate outcomes:
be a proposed change-set. Define typed diffs:
Let 
B. Formalization
 and the system can prove it.
in the same commit
Parity means: for any semantic change in one member, the impacted members reflect that change 
Traces: tests, telemetry contracts, evidence links (VIF), SEG lineage, incident notes.
Tags: policies, data classifications, PII labels, license headers, ACLs.
Docs: specs, ADRs, runbooks, user help, API docs.
Code: source, configs, schemas, migrations.
Artifacts (minimal):
A. Artifact Quartet & Parity
We treat every change as an atomic, witnessed bundle that preserves parity across the quartet and is either accepted as a whole or quarantined as a whole.
 names the quartet we bind together: Source/Docs/Facts ↔ Code/Verification/Forensics.)
SDF-CVF
(
Code, docs, tags, and traces must evolve as one.
Principle (Atomic Evolution Invariant)
Software and knowledge systems rot when their artifacts evolve out of sync. A model fixes a bug in code but not in docs; a policy tag changes but logs don’t record the new constraint; a test is updated but the incident runbook isn’t. This artifact drift creates invisible failure surfaces that no prompt can paper over.
Problem
1.5 From Drift to Atomic Evolution (SDF-CVF)
Bottom line: VIF turns answers into evidence—measurable, explainable, and safe to build upon.
With SDF-CVF: releases are witnessed decisions; if later contradicted, we amend—we don’t silently overwrite.
With SEG: VIFs are edges & nodes in the evidence graph; time-sliced queries return who-knew-what-when.
With APOE: every boundary emits a witness; gates consume UQ to accept/abstain.
With CMC/HHNI: VIF envelopes bind claims to atoms & indices at the moment of use.
J. How VIF Fits the Whole
Replay: re-run retrieval + summarization from same snapshot; identical citation set; textual diff = 0.
VIF: cites NIST SP 800-38D (spans), model/weights/prompt hashes, UQ band B, κ=ACCEPT.
Claim: “AES-256-GCM provides confidentiality and integrity with 128-bit tags.”
I. Micro-Example (research paragraph)
Export pass rate (evidence packs that validate end-to-end).
Abstention quality (precision/recall of κ decisions).
Calibration health (ECE by bucket; drift alarms).
Replay fidelity (% deterministic replays within tolerance).
Lineage coverage (% artifacts with valid VIF).
H. KPIs (VIF)
Sign & Merkle-root; verify on read/export
Edited envelopes
Provenance forgery
Continuous ECE monitoring; recalibrate or raise κ
Confidently wrong answers
Calibration rot
Capability tokens; tool registry; log all side-effects
Hidden HTTP/FS access
Tool-call blind spots
Hash prompts; diff at gate
Same template id, different text
Prompt drift
V-1 hard fail; quarantine branch
Artifact with no envelope
Orphan claims
Guard
Symptom
Failure
G. Failure Modes & Mitigations
Risk banners: red/yellow bands for out-of-calibration buckets; direct “Send to reviewer.”
Citations as anchors: clicking a citation jumps to the SEG node/selector.
Replay button (guarded): re-execute with frozen inputs; diff overlay of outputs.
One-click lineage panel: sources, tool calls, prompt template, model hash, snapshot id.
Inline confidence chip (“Conf: B • ±11%”) with hover to expand how it was computed.
F. UI/UX for Trust
or ECE > ε for the bucket, ABSTAIN or ESCALATE (HITL).
κ-gating: If 
.
Hybrid risk score 
Calibrators: Platt/Isotonic on task-specific dev sets → ECE.
Retrieval overlap (top-k overlap across reruns) → grounding confidence.
Dropout/seed ensembles → variance proxy.
Temperature sweep (T=0.2…1.0) with agreement rate → spread.
E. UQ Methods (practical menu)
V-5 Synthetic labeling. All AI-generated content carries machine-readable labels (content authenticity metadata).
V-4 Tamper-evidence. Envelopes are signed (ed25519) and rooted in a Merkle tree committed to the snapshot log.
V-3 Replay or retract. Any contested claim must be replayed from its snapshot; if replay fails, mark claim RETRACTED and create a contradiction edge.
V-2 Show uncertainty by default. UI must render confidence bands; low-calibration buckets are yellow/red-flagged.
V-1 No envelope, no artifact. If a step fails to produce a valid VIF, its artifact is non-exportable and cannot advance the chain.
D. Operational Rules (binding)
Citations point into the SEG with byte/line spans (or structured selectors).
Prompt template and weights are versioned and hashed.
All large payloads are content-addressed; the envelope stores hashes + IDs, not blobs.
Notes
}
  }
    "chain_root": "merkle:…"
    "witness_sig": "ed25519:…",
  "signatures": {
  ],
    { "source_id": "kb:design:authz-v2", "section": "3.1", "hash": "sha256-…" }
    { "source_id": "doc:ISO27001:2022", "span": "L210-L245", "hash": "sha256-…" },
  "citations": [
  },
    "kappa_decision": "ACCEPT"  // or ABSTAIN/ESCALATE
    "ece_at_bucket": 0.024,
    "calibration_bucket": "B",
    "ensemble_spread": 0.11,
    "entropy": 1.27,
  "uncertainty": {
  },
    ]
      { "name": "rag.search", "version": "2.3.1", "args_hash": "sha256-…" }
    "tools": [
    "prompt_args_hash": "sha256-…",
    "prompt_template_id": "tmpl:summary@1.12.4",
    "weights_hash": "sha256-…",
    "model_id": "gpt-5t-2025-10",
  "provenance": {
  },
    "inputs_hash": "sha256-…"
    "read_packs": ["rp:docs:…", "rp:code:…"],
    "snapshot_id": "snap:c1c9…",
  "context": {
  },
    "parents": ["claim:outline:v2"]
    "hash": "sha256-…",
    "type": "text/markdown",
    "id": "claim:summary:v3",
  "claim": {
  "actor": { "role": "reasoner", "principal": "apoe@system" },
  "time": "2025-10-17T19:21:54Z",
  "witness_id": "w_01F8MECHZX3TBDSZ7XRADM79XE",
{
Each boundary (APOE step) must emit a VIF envelope:
C. VIF Envelope (at every step boundary)
such that:
Replayability: There exists a function 
over held-out checkpoints; otherwise claims in that band require HITL.
Calibration: expected calibration error 
:
and uncertainty vector 
with a provenance tuple 
is valid iff there exists a path:
A claim node 
.
be the Shared Evidence Graph (SEG) at time 
Let 
B. Minimal Formalism
Exportability: Self-contained evidence packs (for audit/compliance).
Replayability: The ability to re-execute the exact trace on the exact data/model versions.
Uncertainty disclosure: Calibrated UQ vectors; abstention if risk ≥ κ.
Provenance integrity: Immutable IDs (content hashes), signed envelopes, versioned prompts/tools.
Lineage: A machine-readable path from claim → evidence → sources/tools → snapshot.
A. What VIF Guarantees
 it is queried, displayed, and audited.
how
 must be recorded at each boundary and 
what
VIF (Verifiable Intelligence Framework) makes every artifact provable, replayable, and calibrated. It standardizes 
A claim that cannot show its lineage is a rumor.
Principle (Witness Invariant)
Outputs that look right but can’t show how they were made are un-auditable risks. In regulated or high-stakes workflows, an answer without lineage is indistinguishable from a rumor.
Problem
1.4 From Claims to Witness (VIF)
APOE converts “ask the model” into compile-and-run a program over memory, tools, and policies. The result is crisper answers, lower variance, transparent cost, and replayable trust—the necessary substrate for safe, large-scale machine communication.
J. Why It Matters
Lineage completeness (VIF coverage).
Repair efficacy (first-repair success), rewrite frequency.
Budget adherence (tokens/time/cost), cost per accepted artifact.
.
Gate pass-through (per role) and true-positive abstentions at 
Determinism rate (trace match under replay).
I. KPIs (for APOE)
    return state, full_witness()
        state.update(y); record_vif(s, w)
            else: return ABSTAIN, witness_so_far()
            if decision == "repair": plan = bounded_rewrite(plan, s, evidence=w)
            decision = repair_or_abstain(s, x, y, w)
        if not gate_pass(s, y, w):
        y, w = execute(s, x)               # tools bounded by budgets
        x = collect_inputs(s, state, CMC)
    for s in topo_sort(plan):
    state = {}
def run(plan):
H. Pseudocode (orchestrator core)
Execution result: note.md + SEG lineage; replay uses the same snapshots & seeds.
end
  witness all
    gate    = {len(critical(issues)) == 0}
    out     = issues[]
    tools   = {llm.review}
    inputs  = {note.md}
  step critique as critic
    gate    = {UQ.band in [A,B], cites(sources)}
    out     = note.md
    budgets = {tokens:6k}
    tools   = {llm.write}
    inputs  = {outline, sources}
  step draft as reasoner
    gate    = {p_at_5(sources) >= 0.8, policy.ok(sources)}
    out     = sources[]
    budgets = {tokens:3k}
    tools   = {rag.search}
    inputs  = {outline}
  step retrieve as retriever
    gate    = {nonempty(outline)}
    out     = outline
    budgets = {tokens:4k, time:30s}
    inputs  = {goal}
  step plan as planner
pipeline ResearchNote(goal)
ACL sketch
G. Tiny Example (research→draft→critique)
O-3 Boundary gates. Every step ends with verifiable gates (tests/RS/UQ/policy) and emits VIF.
O-2 Typed roles. Steps must declare role and permitted effects (read, write, network, exec).
O-1 Budgets explicit. Tokens/time/tools/cost must be declared per step and enforced.
F. Constraints (binding)
Spec/code drift. Output without parity gates or atomic commits.
Heuristic retries. “Try again” loops without calibrated UQ or acceptance tests.
Hidden tool use. No lineage or policy check; exfiltration risk.
One-shot megaprompting. No budgets, no gates, brittle outcomes.
E. Anti-Patterns APOE Eliminates
Emit artifacts + replayable trace; update CMC; surface KPIs.
Closeout.
If evidence suggests a better route, perform bounded DEPP self-rewrite (new ACL version, linked in SEG).
Adaptation.
For each boundary: record model id, weights hash, prompt template id, tool calls, snapshot ids, UQ.
Witnessing.
Orchestrator runs steps; retrieval uses CMC (RS-aware); reasoning uses LLM; verification runs tests/critics.
Execution.
Lower draft into ACL with types, effects, and static guarantees.
Compilation (ACL).
Input: user goal + context sketch → plan draft with roles, tools, budgets, gates.
Plan Synthesis.
D. APOE Lifecycle (concise)
; budgets respected.
subject to: All gates pass; global risk 
Minimize 
Objective (multi-criteria)
(from calibrated UQ), the step returns ABSTAIN.
: if 
Abstention 
iff all predicates hold: tests, RS, policy, UQ.
accepts 
Gate 
: witness node(s).
: new/modified artifacts; 
: set of atoms/read-packs; 
Typed step:
C. Minimal Formalism
Witness trace. All inputs/outputs/tool calls/snapshots recorded to SEG.
Self-rewrite via evidence. If a gate fails with actionable evidence, planner may edit the plan, bump version, and continue (bounded by rewrite budget).
 → repair, fallback, or abstain.
band or RS<
Boundary gates. Each step emits VIF+UQ; if 
Routing & parallelization. Topologically schedule; run independent branches in parallel; cache stable subplans.
Run-time (when executing):
Emission of ACL. Plan lowered into ACL (AIMOS Chain Language) for execution.
Acceptance criteria. Per step success predicates & gates (tests, RS thresholds, UQ bands).
Static checks. Type/effect checks (e.g., “tool:db.write” forbidden in read-only plan), PII policy, cyclicity.
Budgeting. Allocate token/time/cost envelopes per step; define global caps.
Intent parse → task graph. Decompose goals; annotate edges with data/decision dependencies.
Compile-time (before any LLM call):
B. Compile-Time vs Run-Time
).
yields the same trace (or abstains at 
(memory), tools, seeds, and budgets, 
Determinism under fixed state: With fixed 
: planner, retriever, reasoner, builder, verifier, critic, operator, witness.
(typed executors)
Roles 
Witness: VIF provenance + UQ vector (entropy/calibration) + snapshot ids.
Artifacts: text/code/config/test/results.
.
Budgets: 
Tools: LLM calls, RAG queries, code runners, HTTP, sandboxed shells.
Inputs: atoms/read-packs from CMC, constants, prior step outputs.
Step signature
define data/control flow.
, edges 
is a finite DAG over steps 
Plan 
A. What APOE Is
APOE (AIMOS Prompt Orchestration Engine) turns intent into a typed, budgeted, auditable plan; executes it; and emits a witnessed trace you can replay.
Reasoning must be compiled, not improvised.
Principle (Orchestration Invariant)
Single-shot prompting improvises reasoning. It drifts with phrasing, is hard to reproduce, and hides cost/risk. Complex work (research, coding, operations) needs plans, not vibes.
Problem
1.3 From Improvisation to Compilation (APOE)
C-5 Witness-ready. Every read result carries VIF suitable for SEG insertion.
C-4 Policy-aware. PII masks & labels must propagate into every read pack.
C-3 Two-stage read. Coarse→refine with dumbbell; DVNS optional.
C-2 Snapshot-first. Nothing surfaces without a snapshot_id.
C-1 Single writer. All writes via CreateMemory transactional flow.
J. Design Constraints (binding)
A week later, replay(S-8421) reproduces the same pack for audit.
Output cites S-8421, tool calls, model hash, and UQ band.
DVNS elevates salient spans; APOE proposes remediations.
HHNI links errors↔deploy events; snapshot_id=S-8421.
Logs atomized; masked; embedded.
After (CMC):
“Summarize the 3GB logs and suggest fixes.” → One-off answer; no sources; can’t reproduce.
Before (chat):
I. Example (before/after)
Privacy coverage: PII mask hit-rate, redaction drift
Edit safety: mean DD, count of blocked high-impact edits
Lineage completeness % (atoms with VIF)
Snapshot replay fidelity (exact/functional)
p@k@latency on retrieval; RS-lift vs. static KNN
H. KPIs (for CMC)
    return rehydrate(packed)  # atoms + provenance + snapshot_id
    if packed.RS < kappa or packed.UQ.bad: return Abstain
    packed = dvns_refine(refined, policy=policy)  # optional
    refined = dumbbell_compress(cands)
    cands = knn(query.embedding, scope=(t, policy))
def read_memory(query, t=None, policy=None):
    return snap.id
    emit_vif(snapshot=snap, io=io)              # SEG lineage
    snap = snapshot(atoms, idx)                 # content-addressed
    if not gate(qs=atoms.QS, ids=idx.IDS, dd=dd): raise GateReject
    dd  = dependency_delta(idx)                 # impact of edits
    idx = index_hhni(atoms)                     # IDS, edges, hashes
    enrich(atoms)                               # summary, tags, embeddings, QS
    atoms = atomize(io)                         # modality-aware
def write_context(io):
G. Minimal Pseudocode
Monolithic context. Huge prompts with LIM; no dumbbell or HHNI.
Mutable facts. Silent edits without snapshots; untraceable changes.
Append-only amnesia. No indices, no decay, no retrieval control.
Blob memory. Unstructured chat logs; impossible lineage.
F. Anti-Patterns (what CMC prevents)
Privacy by design. PII masked at ingest; redaction maps carried in snapshots; policy labels enforced at read.
Determinism (under fixed state). Given (M_t, tools, seeds) the same read returns the same pack (within tolerance) or abstains.
Monotonicity. Graph grows with time; deprecations leave tombstones/contradictions.
Reversibility. restore(snapshot) → (atoms, indices); diffs are explicit.
E. Guarantees
}
  tool_calls[], snapshot_id, uq{entropy, ece, band}, valid_from,to?
  artifact_id, model, weights_hash, prompt_template_id,
VIF {
SEG Node (claim/tool/decision)
}
  created_by, created_at
  id, digest, redactions[], policy_labels[], atom_refs[], index_refs[],
Snapshot {
Snapshot
}
  weight, dependency_hash, impact_preview[]
  src_id, dst_id, type{contains|supports|contradicts|relates_to},
Edge {
Index Edge
}
  pii_mask, parent_molecule_id?
  tags[], embedding[], tpv{priority, relevance, decay},
  id, ts, author, modality, payload, summary,
Atom {
Atom (core)
D. Data Contracts (concise)
If RS < κ or UQ is poor → abstain or route to HITL.
Rehydrate. Expand final spans back to atoms; attach provenance, masks, and snapshot_id.
DVNS (optional): physics-guided reranking (gravity/elastic/repulse/damping) under policy constraints.
Dumbbell: keep early and late critical spans, compress the middle (prevents “lost-in-the-middle”).
Refine.
Coarse select. Vector KNN on embeddings + HHNI filters (scope, time, policy) → candidate packs.
Two-stage read with “dumbbell compression”:
C. Read Path (Memory → Context)
Retrieval Score (used later by readers):
Graph. Emit VIF lineage into SEG (with time slice [t_from, t_to)).
Snapshot-first. Produce snapshot_id; nothing surfaces without it.
Gate (CMC-G). Require thresholds: QS≥θ_q, IDS≥θ_i, DD≤θ_d.
Score. Compute DD (dependency delta) if editing linked content.
Index. Insert into HHNI; compute IDS (depth/coverage).
Enrich. Summaries, tags, PII masking, embeddings; compute QS (quality).
Ingest & Atomize. Normalize IO (prompt, file, API, log) into typed atoms.
Pipeline: ingest → atomize → enrich → index → score → gate → snapshot → graph
B. Write Path (Context → Memory)
Contradictions are edges, not deletions.
Lineage: (model, weights_hash, prompt_template_id, tool_calls, snapshot_id)
JSON-LD graph nodes for claims/sources/tools/decisions with temporal validity.
SEG
Evidence (how it is trusted) — 
Reversibility: restore(snapshot_id) → (atoms, indices)
Signed digest, redaction map, policy labels
Content-addressed, immutable bundles of {atoms + indices + metadata}.
Snapshots (how it is frozen)
IDS (Indexing Depth Score) and impact previews for safe edits
dependency edges (parent/child, supports, contradicts, relates_to)
Fractal, recursive indices from System → Section → Paragraph → Sentence → Word → Sub-word, with:
HHNI
Indices (how it’s found) — 
embedding (vector), tpv (Tag Priority Vector: priority, relevance, decay)
id, ts, author, modality{text|code|event|tool}, payload, aux{tags, spans, pii_mask}
Minimal, typed facts created on ingest:
Atoms (what exists)
A. The Four Layers
CMC makes this operational by turning every input/output/tool call into atoms → indices → snapshots → evidence—the four layers of a memory-native stack.
An intelligent system must convert ephemeral context into structured, queryable, and reversible memory.
Principle (Memory Invariant)
Raw prompts are ephemeral. Without structure, yesterday’s hard-won insight can’t be found, reused, audited, or reversed. “Chat logs” are not memory; they’re sediment.
Problem
1.2 From Context to Memory (CMC)
Machine communication replaces “chat” with a memory-native, plan-driven, witness-first discipline. AIMOS/APOE operationalizes this with CMC (remember), APOE (compile), VIF (prove), SDF-CVF (evolve atomically), and SEG (graph the evidence). The result is a system that can translate, build, and decide—and show its work every step of the way.
One-paragraph summary
Governance fatigue: HITL two-key only on R2/R3 risk tiers; everything else auto-merges under gates.
Plan bloat: ACL static checks, budget caps, chain health metrics (κ_chain).
Overconfidence: mandatory UQ, κ-abstention, calibration dashboards.
Prompt injection / exfiltration: tool sandboxes, capability tokens, redaction by default, policy-aware DVNS.
Risks & mitigations
Silent drift between docs, code, tests, and traces.
“One-shot miracles” without plans, budgets, or witnesses.
Hidden tool usage or mutable, unlogged state.
Hallucinated citations or unverifiable claims.
Anti-goals (what we refuse to do)
Compliance: export time (mins), redaction coverage %, contradiction capture rate.
Evolution: change-failure rate↓, MTTR↓, spec↔code parity score↑.
Trust: lineage completeness %, ECE (calibration) bands, κ true-positive abstentions.
Orchestration: % deterministic plan replays at fixed seeds; budget adherence.
Memory: p@k@latency↑, RS-lift vs. static KNN, snapshot-replay fidelity.
KPIs (what improves when you leave “chat” behind)
Result: Running app whose spec↔code↔tests↔traces are in parity.
Flow: Blueprint→APOE (scaffold, codegen, tests) → SDF-CVF gates → preview env → SEG export pack.
Input: “Scaffold a browser app, OAuth2 login, audit log export.”
C) IDE-in-the-loop build (user↔code).
Result: Redaction proof + remediation plan, both replayable.
Flow: Chunk→index (HHNI) → DVNS selects salient spans → redact per policy → APOE proposes fixes → κ/HITL on high risk → SEG anchors.
Input: “Summarize this 3GB log, redact PII, and propose remediations.”
B) File diplomacy (device↔file↔policy).
Result: Auditable transform with replayable witnesses and contract-level budgets.
Flow: Ingest → CMC atoms/snapshot → APOE plan (mapping, validation, post) → VIF at each step → SEG lineage.
Input: “Convert this vendor XML feed into our JSON schema, validate, and post to /ingest.”
A) Protocol translation (machine↔machine).
Worked mini-scenarios
DVNS refinement: post-KNN force-guided pathing (gravity/elastic/repulse/damping) to improve Top-k precision under policy constraints.
Abstention threshold: κ (decline when RS < κ or UQ > κ).
QS content quality, IDS indexing depth, DD dependency delta.
 [0,1]
∈
Retrieval score: RS = norm(QS · IDS · (1 − DD)) 
Core mechanics (concise)
Temporal truth. SEG queries are as-of time; deprecations leave tombstones and contradiction edges.
Atomic parity. No doc/spec change merges without corresponding tests/code/provenance passing gates.
Witness or abstain. If RS < κ or calibration poor, the system must decline or escalate.
Budgets at boundaries. Each step declares tokens/time/tools; breaches abort or route to HITL.
Two-stage reads. Coarse → fine retrieval, with dumbbell compression to avoid “lost in the middle.”
Snapshot-first IO. Nothing user-visible exists without a snapshot id.
Design consequences (non-negotiable)
Application layer: SEG — time-sliced evidence queries and exports.
Session layer: SDF-CVF — parity gates across artifacts; HITL checkpoints.
Transport layer: VIF — provenance packets and UQ headers at each hop.
Network layer: APOE — typed plans, budgets, routes, parallelization.
Link layer: CMC — atoms, indices, snapshots (write once, cite forever).
Minimal surface: the five invariants as protocol layers
Claims, sources, tools, decisions live as typed nodes/edges with temporal validity; contradictions are first-class, not deletions.
5) Graph substrate.
A single commit spans code/docs/tags/traces, gated by tests/spec/provenance/HITL. Quarantine on failure; rollback is cheap.
4) Atomic evolution.
Every artifact carries VIF: model id, weights hash, prompt template id, tool calls, snapshot id, and UQ (calibrated confidence).
3) Verifiable speech.
Tasks are plans (DAGs) with roles, tools, and explicit budgets. Plans run deterministically (or abstain).
2) Compiled reasoning.
All IO (prompts, files, API calls, logs) lands first as atoms in CMC → indices (HHNI) → snapshots → graph entries in SEG.
1) Memory-native IO.
What “machine communication” requires
Conclusion: “Better prompts” cannot fix structural defects. Architecture must.
Silolization. Documents, tools, and time live in separate islands; no cohesive lineage.
Drift. Code/spec/tests/provenance diverge; fixes are tribal knowledge.
Opacity. Outputs lack provenance, uncertainty, or replays; trust is performative.
Improvisation. One-shot prompting has no budgets, no roles, no contracts.
Ephemerality. Conversation context evaporates; decisions cannot be reproduced.
Why “chat” fails at scale
Together, these make “chat” merely the UI skin over a disciplined, auditable machine-to-machine protocol.
SEG (Shared Evidence Graph): evidence is a graph, time-sliced and exportable.
SDF-CVF (Atomic Evolution): code, docs, tags, and traces evolve as one through gates.
VIF (Verifiable Intelligence Fabric): every claim ships with lineage, uncertainty, and replayability.
APOE (Prompt Orchestration Engine): compiles reasoning into typed plans, not one-shot guesses.
CMC (Context Memory Core): converts ephemeral context into structured, queryable, reversible memory.
AIMOS/APOE turns this thesis into an operating system:
Large models are not “chatbots.” They are machine-communication engines: mediators that translate among people, documents, tools, files, networks, and code—while remembering, orchestrating, witnessing, and evolving in verifiable ways.
Thesis
1.1 The Machine-Communication Thesis (Beyond “chat”)
Chapter 1 — The Why
Appendices & Back Matter
Part XIII Ch.33–34 14. 
Part XII Ch.30–32 13. 
11. Part XI Ch.27–29 12. 
10. Part X Ch.24–26 
 9. Part IX Ch.22–23 
8. Part VIII Ch.20–21
7. Part VII Ch.18–19 
6. Part VI Ch.16–17 
5. Part V Ch.14–15 
4. Part IV Ch.11–13 
3. Part III Ch.8–10 
2. Part II Ch.4–7 
1. Part I Ch.1–3 
Glance) * Invariants → Components → Gates → KPIs * Data Flow (Write/Read) → Traces → Compliance Duties * Roles (APOE) → Tools → Budget Classes --- ### Expansion Plan (Serial Order for Subsequent Chats) 
a
J. Risk Taxonomy & Playbooks --- ## Back Matter * Bibliography * Subject Index * Author/Editor Notes --- ### Crosswalk Matrices (At
I. Compliance Artifacts (sample exports) 
H. Troubleshooting Guide 
G. Quickstarts & Labs 
reference) 
F. Index of Indexes (HHNI cross
E. Change Log 
D. Figures & Tables List 
end traces) 
to
C. Extended Examples (end
B. Acronyms
A. Glossary (expanded) 
## Appendices 
34.3 Ethics & Use Policies --- 
34.2 Review Rotations 
34.1 ADR Templates 
**Chapter 34. Community & Contribution** 
33.3 Resourcing & Budgets 
33.2 Risks & Dependencies 
33.1 Milestones 
90** 
60
30
**Chapter 33. 0
## Part XIII — Roadmap & Governance 
32.3 Soundness Notes --- 
32.2 Symbolic Checkers 
32.1 ACL Types & Effects 
**Chapter 32. Type Systems & Logic** 
31.3 Stability Regions 
31.2 Convergence Proof Sketches 
31.1 GODN Potentials & Forces 
**Chapter 31. Dynamics** 
30.3 UQ Theory (entropy, variance, calibration) 
30.2 Normalization & Calibration 
30.1 RS/QS/IDS/DD definitions & bounds 
**Chapter 30. Retrieval Math** 
## Part XII — Mathematics & Formal Methods 
29.3 CLI --- 
29.2 Python 
29.1 JS/TS 
**Chapter 29. SDKs & Clients** 
only) 
28.3 Audit API (read
28.2 Orchestration API 
28.1 Memory API 
**Chapter 28. APIs** 
27.3 ACL AST 
LD 
27.2 SEG JSON
27.1 Atom/Edge 
**Chapter 27. Data Schemas** 
## Part XI — Reference Implementations 
26.3 Safe Autoremediation --- 
26.2 RCA with VIF/SEG 
26.1 Log Forensics 
**Chapter 26. Ops & Incidents** 
Critical Workflow 
25.3 Compliance
25.2 Brownfield Refactor 
25.1 Greenfield App 
**Chapter 25. Builder Programs** 
24.3 Device & File Diplomacy 
24.2 Negotiation & Mediation 
24.1 Protocol Translation 
**Chapter 24. Machine Communication** 
## Part X — Case Studies & Patterns 
23.4 SLOs & Error Budgets --- 
rot Monitors 
23.3 Drift & Prompt
23.2 Token/Latency Budgets 
23.1 OpenTelemetry for Agents 
**Chapter 23. Observability & Costing** 
22.4 Gold Sets & Adversarial Suites 
Horizon Tasks 
22.3 Streamed Agents & Long
lift 22.2 κ/ECE Dashboards 
22.1 p@k, nDCG, RS
**Chapter 22. Retrieval & Reasoning Benchmarks** 
## Part IX — Evaluation, Benchmarks, & Observability 
21.4 Incident Response & Notifications --- 
21.3 Data Retention vs. Minimization 
21.2 SOC2/ISO Mapping 
21.1 EU AI Act (logging, synthetic labeling) 
**Chapter 21. Compliance Engineering** 
20.4 Abstention & Containment 
20.3 Redaction & Differential Privacy 
 20.2 Tooling Sandboxes & Capability Tokens 
 20.1 Prompt Injection, Exfiltration, SSRF
**Chapter 20. Threat Model & Guardrails**
 ## Part VIII — Security, Safety, & Compliance 
19.4 Cost & Energy Budgets ---
19.3 Integration Patterns (tools, APIs) 
19.2 Policy Packs (PII, licenses) 
19.1 UI, API, Auth, Data 
**Chapter 19. Templates & Components** 
18.6 Parity Enforcement (spec↔code) 
18.5 Preview Environments & Telemetry 
18.4 Testing Pyramid & Coverage Gates 
18.3 Codegen & Refactors 
18.1 Blueprint YAML 18.2 Scaffolding Strategies 
**Chapter 18. Blueprint→Scaffold→Code→Test→Deploy→Observe** 
Loop: From Prompt to Running App 
the
in
## Part VII — IDE
17.4 Training Data Hygiene --- 
17.3 Audit Trails & Accountability 
17.2 Review UX & Diff Semantics 
Key Approval 
17.1 Risk Scoring & Two
Loop (HITL)** 
the
in
**Chapter 17. Human
aligned Metrics (CFR, MTTR) 
16.4 DORA
Fix, Quarantine, Rollback 
16.3 Auto
16.2 ADRs & Branching Strategy 
16.1 Gate Catalog (parity, tests, safety, provenance, HITL) 
**Chapter 16. Atomic Commits Across Code/Docs/Tags/Traces** 
CVF 
## Part VI — Atomic Evolution: SDF
15.4 Export & Regulatory Packages --- 
15.3 Claim→Evidence→Decision Lineage 
Slicing 
15.2 Temporal Graphs & Time
LD Schema & SHACL 
15.1 JSON
**Chapter 15. Shared Evidence Graph (SEG)** 
14.4 Reproducibility & Replays 
14.3 Confidence Bands & UI Cues 
14.2 UQ Methods (temperature sweeps, ensembles, ECE) 
14.1 VIF Metadata (model, weights hash, prompts, data slices, tools) 
**Chapter 14. Provenance & Uncertainty** 
## Part V — Verifiable Intelligence: VIF & SEG 
13.4 Examples (research, coding, operations) --- 
13.3 Static Checks & Type System 
13.2 Core Constructs (pipeline, step, gate, budget, inputs) 
13.1 Grammar (EBNF) 
13. ACL — AIMOS Chain Language** 
Scale Planning (thousands of nodes) **Chapter 
12.4 Large
12.3 Chain Health Metrics (κ_chain, budget adherence) 
Rewrite via Evidence 
12.2 Self
12.1 Master Chain as Graph 
12. Dynamic Emergent Prompt Pipeline (DEPP)** 
11.4 Routing & Parallelization **Chapter 
11.3 κ & Uncertainty Emission at Boundaries 
11.2 Budgets (tokens,time,tools) 
11.1 Roles & Contracts (planner, retriever, reasoner, verifier, builder, critic, operator, witness) 
**Chapter 11. Cognitive Compilation (APOE)** 
## Part IV — Orchestration: APOE & DEPP 
10.4 Visualization & Telemetry --- 
10.3 Failure Modes (oscillation, collapse) 
10.2 Parameter Tuning (G,k,δ,c,α,β,γ) 
k 
10.1 Online Refinement on Top
**Chapter 10. Implementation Patterns** 
9.4 Empirical Lift vs. Static KNN 
Index Precomputation 
9.3 Super
 9.2 Convergence & Complexity 
 9.1 Force Integration (Verlet vs. Euler)
**Chapter 9. Algorithms & Analysis**
Aware Geometry (forbidden crossings) 
8.4 Policy
8.3 Stability & Abstention 
8.2 Path Cost C(P) (length, smoothness, blocks, density) 
8.1 GODN Recap (grav, elastic, repulse, damping) 
Inspired Retrieval** 
**Chapter 8. Physics
## Part III — Dynamic Vector Navigation System (DVNS) 
7.4 Snapshot Log & Rollback --- 
addressed) 
7.3 Object Store (content
7.2 Evidence Graph Store (temporal) 
7.1 Vector Store & KNN 
**Chapter 7. Storage Substrate** 
 6.4 Performance Targets & SLOs 
6.3 Caching & Preloading (Markov traversals)
6.2 Hierarchical Read with Dumbbell Compression 
6.1 Ingest→Atomize→Propose→DD→Gate→Snapshot 
**Chapter 6. Write/Read Pipelines** 
5.4 Retrieval Score RS (QS · IDS · (1−DD)) — normalization & calibration 
5.3 Priority & Decay (TPV dynamics) 
5.2 Dependency Hashing & Impact Previews 
word 
5.1 Indices from System→Section→Paragraph→Sentence→Word→Sub
Hierarchical Neural Indexing (HHNI)** 
**Chapter 5. Hyper
4.4 Embeddings, Tags, and TPV 
4.3 Modality Independence & Payload Abstraction 
4.2 Atomicity, Recursion, Emergence 
4.1 Atoms & Molecules (schemas) 
 **Chapter 4. Fractal Memory Hierarchy** 
## Part II — Context Memory Core (CMC) & HHNI
3.4 Threat & Misuse Model (policy surface) --- 
Loop Rationale 
the
in
3.3 IDE
gating) 
3.2 Safety as Capability (abstention, κ
Workshop: Roles & Scopes 
a
with
3PO
3.1 C
Star** 
**Chapter 3. Design North
2.6 Axioms → Design Constraints (traceability table) 
2.5 Substrate Invariant (SEG) — Graph theoretic underpinnings 
CVF) — Compositionality & parity 
2.4 Atomic Evolution (SDF
2.3 Witness Invariant (VIF) — Trust calculus & auditability 
2.2 Orchestration Invariant (APOE) — Formal statement & proofs 
2.1 Memory Invariant (CMC) — Formal statement & proofs 
**Chapter 2. System Axioms** 
1.6 From Documents to Evidence Graphs (SEG) 
CVF) 
1.5 From Drift to Atomic Evolution (SDF
1.4 From Claims to Witness (VIF) 
1.3 From Improvisation to Compilation (APOE) 
1.2 From Context to Memory (CMC) 
Communication Thesis (Beyond “chat”) 
 1.1 The Machine
**Chapter 1. The Why**
Makers) --- ## Part I — First Principles & Invariants 
page Brief for Decision
CVF, SEG) * Executive Overview (5
CVF, etc.) * Summary of Core Invariants (CMC, APOE, VIF, SDF
Native, Verifiable, Agentic Intelligence** Edition v0.1 (Master Index) --- ## Front Matter * Foreword (Origins, Intent, Acknowledgments) * Preface (How to Read This Book; Reading Roadmaps: Researcher • Engineer • Builder) * Conventions (Typography, Symbols, Units, Pseudocode, ACL formatting) * Notation & Symbols Quick Reference (RS, IDS, DD, κ, û, TPV, SEG, SDF
**A Total System of Memory